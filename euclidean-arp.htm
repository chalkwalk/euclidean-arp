<html>
<head>
    <title>MPE Euclidean Arpeggiator</title>
    <style>
        /* Styles remain the same */
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step { width: 25px; height: 25px; border: 1px solid #ccc; text-align: center; line-height: 25px; font-size: 12px; margin-right: 2px; border-radius: 3px; background-color: #f0f0f0; color: #333; }
        .rhythm-step.beat { background-color: #b2f0b2; border-color: #8fcc8f; color: #005000; }
        .rhythm-step.rest { background-color: #f0b2b2; border-color: #cc8f8f; color: #500000; }
        .rhythm-step.skip { background-color: #b2b2f0; border-color: #8f8fcc; color: #000050; }
        .rhythm-step.note { background-color: #f0f0b2; border-color: #ccf08f; color: #505000; }
        .rhythm-step.current-step { border: 2px solid blue; }
        .rhythm-step.disabled-step { background-color: #e0e0e0; border-color: #bbb; color: #999; }
        .rhythm-step.gate-extended-step { background-color: #cceeff; border-color: #aaccdd; }
        .parameter-group { margin-bottom: 10px; border: 1px solid #ccc; padding: 10px; border-radius: 5px; background-color: #fafafa; }
        .parameter-group h3 { margin-top: 0; color: #555; }
        .note-selector { margin-bottom: 10px; }
        .piano-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; }
        .key { height: 80px; border-left: 1px solid #ddd; border-bottom: 1px solid #bbb; box-sizing: border-box; cursor: pointer; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 5px; font-size: 10px; user-select: none; transition: background-color 0.1s ease; }
        .white-key { width: 30px; background-color: white; color: black; }
        .black-key { width: 20px; background-color: black; color: white; height: 55px; margin-left: -10px; margin-right: -10px; z-index: 1; border-bottom: 1px solid #333; }
        .key.key-held-ui { background-color: #aaddff; color: black; border-bottom: unset; }
        .key.key-held-midi { background-color: #aaffaa; color: black; border-bottom: unset; }
        .key.key-current { border: 2px solid #ccc; background-color: #ffddaa; border-bottom: unset; }
        .playback-keyboard-container { display: flex; justify-content: center; margin-bottom: 10px; }
        .playback-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; width: 600px; height: 40px; }
        .playback-key { height: 100%; border-left: 1px solid #ddd; border-bottom: 1px solid #bbb; box-sizing: border-box; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 2px; font-size: 8px; user-select: none; transition: background-color 0.1s ease; cursor: default; }
        .playback-white-key { width: calc(600px / 25 * 3/5); background-color: white; color: black; }
        .playback-black-key { width: calc(600px / 25 * 2/5); background-color: black; color: white; height: 70%; margin-left: calc(-600px / 25 * 1/5); margin-right: calc(-600px / 25 * 1/5); z-index: 1; border-bottom: 1px solid #333; }
        .playback-key.key-held-ui { background-color: #99ccee; border-bottom: unset; }
        .playback-key.key-held-midi { background-color: #ccffcc; border-bottom: unset; }
        .playback-key.key-held-octave-expanded { background-color: #cceeff; color: black; border-bottom: unset; }
        .playback-key.key-current { background-color: #ffddaa; border: 1px solid #ccc; border-bottom: unset; }
        .playback-key.key-gate-extended { background-color: #ffddee; border-bottom: unset; }
        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; background-color: #eee; border-radius: 3px; padding-left: 5px; }
        .playback-step { width: 20px; height: 20px; border: 1px solid #ddd; margin-right: 2px; text-align: center; line-height: 20px; font-size: 10px; border-radius: 2px; background-color: #fff; }
        .playback-step.note { background-color: #ffffdd; }
        .playback-step.rest { background-color: #ffdddd; }
        .playback-step.skip { background-color: #ddddff; }
        .device-selector { margin-bottom: 10px; }
        .slider-container { display: flex; align-items: center; margin-bottom: 5px; }
        .slider-container label { margin-right: 10px; width: 120px; text-align: right; font-size: 0.9em; color: #666; }
        .slider-container input[type="range"] { width: 300px; }
        .number-display { width: 30px; text-align: center; margin-left: 5px; font-size: 0.9em; color: #777; }
        #tempoBPM { display: inline-block; margin-left: 10px; font-weight: bold; font-size: 1.2em; color: #333; border: none; background-color: transparent; width: auto; padding: 0; text-align: left; }
        #tempoBPM:read-only { cursor: default; color: #777; font-weight: normal; }
        #midiStatus { margin-bottom: 10px; font-size: 0.9em; color: #777; }
        h1 { color: #333; border-bottom: 2px solid #ddd; padding-bottom: 5px; }
        h3 { margin-top: 0; color: #555; }
        label { font-size: 0.95em; color: #444; margin-right: 5px; }
        select, input[type="number"], input[type="range"], button, input[type="checkbox"] { padding: 5px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; margin-bottom: 5px; }
        button { background-color: #eee; cursor: pointer; transition: background-color 0.2s ease; }
        button:hover { background-color: #ddd; }
        button:disabled { background-color: #f0f0f0; color: #999; cursor: default; }
        #startButton.playing { background-color: lightgreen; }
        #stopButton.playing { background-color: lightcoral; }
        .tab-container { border: 1px solid #ccc; border-radius: 5px; overflow: hidden; background-color: #fafafa; margin-bottom: 10px; }
        .tab-buttons { display: flex; background-color: #eee; border-bottom: 1px solid #ccc; }
        .tab-button { padding: 10px 15px; border: none; background-color: transparent; cursor: pointer; border-right: 1px solid #ccc; font-size: 0.9em; color: #555; }
        .tab-button:last-child { border-right: none; }
        .tab-button.active { background-color: #fafafa; color: #333; font-weight: bold; }
        .tab-content { padding: 10px; }
        .tab-pane { display: none; }
        .tab-pane.active { display: block; }
    </style>
</head>
<body>
    <h1>MPE Euclidean Arpeggiator</h1>

    <div class="note-selector" title="Use this keyboard to select notes with the mouse.">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="midi-mpe-tab">MIDI & MPE</button>
            <button class="tab-button" data-tab="pattern-tab">Pattern</button>
            <button class="tab-button" data-tab="rhythm-tab">Rhythm</button>
            <button class="tab-button" data-tab="arp-tab">Arp</button>
        </div>

        <div id="midi-mpe-tab" class="tab-content tab-pane active">
            <fieldset class="parameter-group">
                <legend><h3>MIDI & MPE Settings</h3></legend>

			    <div id="midiStatus">MIDI Status: Initializing...</div>

			    <div class="device-selector" title="Select your MIDI input device.">
			        <label for="midiInputSelect">MIDI Input:</label>
			        <select id="midiInputSelect" title="Choose the MIDI input device to receive notes and clock from.">
			            <option value="">No input device selected</option>
			        </select>
			    </div>

			    <div class="device-selector" title="Select your MIDI output device.">
			        <label for="midiOutputSelect">MIDI Output:</label>
			        <select id="midiOutputSelect" title="Choose the MIDI output device to send arpeggiated notes to.">
			            <option value="">No output device selected</option>
			        </select>
			    </div>

                <div class="slider-container" title="Source of tempo: internal BPM or external MIDI clock.">
                    <label for="tempoSource">Tempo Source:</label>
                    <select id="tempoSource" title="Choose whether the tempo is controlled internally or by external MIDI clock.">
                        <option value="internal">Internal</option>
                        <option value="external">External MIDI Clock</option>
                    </select>
                </div>

                <div class="slider-container" title="Tempo in Beats Per Minute (BPM). Only active when Tempo Source is Internal.">
                    <label for="tempoBPM">Tempo:</label>
                    <input type="number" id="tempoBPM" value="120" min="10" max="300" title="Set the tempo in BPM for internal clock.">
                </div>

                <div class="slider-container" title="Enable or disable MPE input processing.">
                    <input type="checkbox" id="enableMPE" title="Enable MPE (MIDI Polyphonic Expression) input for per-note control.">
                    <label for="enableMPE" style="text-align: left; width: auto;">Enable MPE Input</label>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global messages or Omni for all channels.">
                    <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
                    <select id="mpeGlobalInputChannel" title="Set the MIDI channel for MPE global control messages, or Omni to listen to all channels.">
                        <option value="omni">Omni</option>
                        <option value="1">Channel 1</option> <option value="2">Channel 2</option> <option value="3">Channel 3</option> <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option> <option value="6">Channel 6</option> <option value="7">Channel 7</option> <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option> <option value="10">Channel 10</option> <option value="11">Channel 11</option> <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option> <option value="14">Channel 14</option> <option value="15">Channel 15</option> <option value="16">Channel 16</option>
                    </select>
                </div>

                <div class="slider-container" title="Number of MIDI channels used for MPE voice messages.">
                    <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
                    <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15" title="Specify the number of MIDI channels to use for MPE voice messages.">
                </div>

                <div class="slider-container" title="Output mode: Non-MPE (single channel) or MPE.">
                    <label for="mpeOutputMode">MPE Output Mode:</label>
                    <select id="mpeOutputMode" title="Choose the MIDI output mode: Non-MPE (single channel) or MPE.">
                        <option value="non-mpe">Non-MPE (Single Channel)</option>
                        <option value="mpe">MPE</option>
                    </select>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global output or base channel for non-MPE.">
                    <label for="mpeGlobalOutputChannel">MPE Global Output / Base Channel:</label>
                    <select id="mpeGlobalOutputChannel" title="Set the MIDI channel for MPE global output or the base channel for non-MPE output.">
                        <option value="1">Channel 1</option> <option value="2">Channel 2</option> <option value="3">Channel 3</option> <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option> <option value="6">Channel 6</option> <option value="7">Channel 7</option> <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option> <option value="10">Channel 10</option> <option value="11">Channel 11</option> <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option> <option value="14">Channel 14</option> <option value="15">Channel 15</option> <option value="16">Channel 16</option>
                    </select>
                </div>
            </fieldset>
        </div>

        <div id="pattern-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Pattern Settings</h3></legend>
                <div class="slider-container" title="Enable or disable the pattern rhythm.">
                    <input type="checkbox" id="enablePattern" checked title="Enable pattern rhythm to introduce skips.">
                    <label for="enablePattern" style="text-align: left; width: auto;">Enable Pattern</label>
                </div>
                <div class="slider-container" title="Number of steps in the pattern rhythm.">
                    <label for="patternSteps">Steps:</label>
                    <input type="range" id="patternSteps" value="5" min="1" max="32" step="1" title="Adjust the number of steps in the pattern.">
                    <span id="patternStepsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Number of beats within the pattern steps.">
                    <label for="patternBeats">Beats:</label>
                    <input type="range" id="patternBeats" value="3" min="1" max="5" step="1" title="Adjust the number of beats in the pattern rhythm.">
                    <span id="patternBeatsValue" class="number-display">3</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the pattern rhythm.">
                    <label for="patternOffset">Offset:</label>
                    <input type="range" id="patternOffset" value="0" min="-2" max="2" step="1" title="Shift the pattern rhythm forwards or backwards.">
                    <span id="patternOffsetValue" class="number-display">0</span>
                </div>
                <div id="patternDisplay" class="rhythm-display" title="Visual representation of the pattern rhythm (Note/Skip)."></div>
            </fieldset>
        </div>

        <div id="rhythm-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Rhythm Settings</h3></legend>
                 <div class="slider-container" title="Enable or disable the arpeggio rhythm.">
                    <input type="checkbox" id="enableRhythm" checked title="Enable arpeggio rhythm to introduce rests.">
                    <label for="enableRhythm" style="text-align: left; width: auto;">Enable Rhythm</label>
                </div>
                <div class="slider-container" title="Number of steps in the arpeggio rhythm.">
                    <label for="rhythmSteps">Steps:</label>
                    <input type="range" id="rhythmSteps" value="7" min="1" max="32" step="1" title="Adjust the number of steps in the arpeggio rhythm.">
                    <span id="rhythmStepsValue" class="number-display">7</span>
                </div>
                <div class="slider-container" title="Number of beats within the arpeggio rhythm steps.">
                    <label for="rhythmBeats">Beats:</label>
                    <input type="range" id="rhythmBeats" value="5" min="1" max="7" step="1" title="Adjust the number of beats in the arpeggio rhythm.">
                    <span id="rhythmBeatsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the arpeggio rhythm.">
                    <label for="rhythmOffset">Offset:</label>
                    <input type="range" id="rhythmOffset" value="0" min="-4" max="4" step="1" title="Shift the arpeggio rhythm forwards or backwards.">
                    <span id="rhythmOffsetValue" class="number-display">0</span>
                </div>
                <div id="rhythmDisplay" class="rhythm-display" title="Visual representation of the arpeggio rhythm (Beat/Rest)."></div>
            </fieldset>
        </div>

        <div id="arp-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Arp Settings</h3></legend>

                <div class="slider-container" title="Clock division for arpeggiator step timing.">
                    <label for="clockDivision">Clock Division:</label>
                    <select id="clockDivision" title="Set the clock division to control the speed of the arpeggio steps.">
                        <option value="1/1">1/1</option> <option value="1/2">1/2</option> <option value="1/4" selected="selected">1/4</option>
                        <option value="1/8">1/8</option> <option value="1/16">1/16</option> <option value="1/32">1/32</option>
                        <option value="1/2T">1/2T</option> <option value="1/4T">1/4T</option> <option value="1/8T">1/8T</option>
                        <option value="1/16T">1/16T</option> <option value="1/32T">1/32T</option>
                    </select>
                </div>

                <div class="slider-container" title="Arpeggio mode determines the order notes are played.">
                    <label for="arpMode">Arp Mode:</label>
                    <select id="arpMode" title="Select the arpeggio playback mode.">
                        <option value="up" selected="selected">Up</option> <option value="down">Down</option> <option value="upDown">Up/Down</option> <option value="upDownInclusive">Up/Down (Incl.)</option>
                        <option value="random">Random</option> <option value="converge">Converge</option> <option value="diverge">Diverge</option>
                        <option value="played">Played</option> <option value="shuffled">Shuffled</option> <option value="stableShuffled">Stable Shuffled</option>
                        <option value="chord">Chord</option> <option value="chordN">ChordN</option>
                        <option value="convergeDiverge">Converge/Diverge</option> <option value="convergeDivergeInclusive">Converge/Diverge (Incl.)</option>
                        <option value="walk">Walk</option> <option value="normalWalk">Normal Walk</option>
                    </select>
                </div>

                <div id="chordNControls" style="display: none;">
                     <div class="slider-container" title="Number of notes in each chord for ChordN mode.">
                         <label for="chordNValue">N:</label> <input type="range" id="chordNValue" value="2" min="1" max="16" step="1"> <span id="chordNValueDisplay" class="number-display">2</span>
                     </div>
                     <div class="slider-container" title="Ordering mode for ChordN chords.">
                         <label for="chordNOrdering">ChordN Ordering:</label> <select id="chordNOrdering"><option value="up">Up</option><option value="down">Down</option><option value="upDown">Up/Down</option><option value="upDownInclusive">Up/Down (Incl.)</option><option value="converge">Converge</option><option value="diverge">Diverge</option></select>
                     </div>
                     <div class="slider-container" title="Maximum number of consecutive chords a note can be held across in ChordN mode. 1 means no extension.">
                         <label for="maxChordExtension">Max Chord Extend:</label> <input type="range" id="maxChordExtension" value="2" min="1" max="16" step="1"> <span id="maxChordExtensionValue" class="number-display">2</span>
                     </div>
                     <div class="slider-container" title="Maximum number of clock divisions a note's gate can be extended in ChordN mode.">
                         <label for="maxTimeExtension">Max Time Extend (Divs):</label> <input type="range" id="maxTimeExtension" value="16" min="1" max="64" step="1"> <span id="maxTimeExtensionValue" class="number-display">16</span>
                     </div>
                </div>

                <div id="walkParams" style="display: none;">
                     <div class="slider-container" title="Skew parameter for Walk arpeggio mode.">
                         <label for="walkSkew">Walk Skew:</label> <input type="range" id="walkSkew" value="0" min="-1" max="1" step="0.01"> <span id="walkSkewValue" class="number-display">0</span>
                     </div>
                     <div class="slider-container" id="walkDistanceContainer" style="display: none;">
                         <label for="walkDistance">Walk Distance:</label> <input type="range" id="walkDistance" value="0" min="0" max="1" step="0.01"> <span id="walkDistanceValue" class="number-display">0</span>
                     </div>
                </div>

                <div class="slider-container" title="Percentage of clock division used for sub-arpeggiation of chords.">
                    <label for="subArpScale">Sub Arp Scale (%):</label> <input type="range" id="subArpScale" value="0" min="0" max="100" step="1"> <span id="subArpScaleValue" class="number-display">0</span>
                </div>
                <div class="slider-container" title="Arpeggio mode for sub-arpeggiation of chords.">
                    <label for="subArpMode">Sub Arp Mode:</label> <select id="subArpMode"> <option value="up">Up</option> <option value="down">Down</option> <option value="random">Random</option> <option value="converge">Converge</option> <option value="diverge">Diverge</option> </select>
                </div>

                <div class="slider-container" title="Synchronization mode for the arpeggiator.">
                    <label for="arpSyncMode">Arp Sync Mode:</label> <select id="arpSyncMode"> <option value="free">Free Sync</option> <option value="key" selected="selected">Key Sync</option> <option value="transport">Transport Sync (Placeholder)</option> </select>
                </div>

                <div class="slider-container" title="Number of octaves to expand held notes across.">
                    <label for="octaves">Octaves:</label> <input type="range" id="octaves" value="1" min="1" max="4" step="1"> <span id="octavesValue" class="number-display">1</span>
                </div>
                <div class="slider-container" title="Base velocity for arpeggiated notes.">
                    <label for="baseVelocity">Base Velocity:</label> <input type="range" id="baseVelocity" value="96" min="1" max="127" step="1"> <span id="baseVelocityValue" class="number-display">96</span>
                </div>
                <div class="slider-container" title="Maximum velocity for arpeggiated notes.">
                    <label for="maxVelocity">Max Velocity:</label> <input type="range" id="maxVelocity" value="127" min="1" max="127" step="1"> <span id="maxVelocityValue" class="number-display">127</span>
                </div>
                <div class="slider-container" title="Gate length as a percentage of the clock division.">
                    <label for="gateLength">Gate Length (%):</label> <input type="range" id="gateLength" value="50" min="1" max="150" step="1"> <span id="gateLengthValue" class="number-display">50</span>
                </div>
                <div class="slider-container" title="Enable gate flex to extend note gates based on rhythm density.">
                    <input type="checkbox" id="enableGateFlex"> <label for="enableGateFlex" style="text-align: left; width: auto;">Enable Gate Flex</label>
                </div>
            </fieldset>
        </div>
    </div>

    <div class="playback-keyboard-container" title="Visual display of held and playing notes. Not interactive.">
        <div class="playback-keyboard" id="playbackKeyboardDisplay"></div>
    </div>

    <div class="playback-display" id="playbackDisplay" title="Displays the sequence of played notes and rhythms."></div>

    <button id="startButton" title="Start the arpeggiator." class="control-button">Start Arpeggiator</button>
    <button id="stopButton" disabled title="Stop the arpeggiator." class="control-button">Stop Arpeggiator</button>

    <script>
        /**
         * @fileoverview Euclidean MPE Arpeggiator Prototype
         * Refactored Active Note management (A6).
         * Refactored MIDI Manager (A5).
         * Refactored Note Input Manager (A2).
         * Refactored Clock Manager (A4).
         * Refactored Rhythm Manager (A3).
         */

        // --- Utility Functions ---
        function arraysAreEqual(arr1, arr2) {
            /* ... unchanged ... */
            if (!arr1 || !arr2 || arr1.length !== arr2.length) return !1;
            for (let i = 0; i < arr1.length; i++)
                if (arr1[i] !== arr2[i]) return !1;
            return !0
        }

        // --- *** Refactor: MidiManager Module (A5) *** ---
        const MidiManager = (function() {
            /* ... unchanged from previous step ... */
            let _midiAccess = null;
            let _selectedInput = null;
            let _selectedOutput = null;
            let _status = "Initializing...";
            let _inputsList = [];
            let _outputsList = [];
            let _isMPEEnabled = false;
            let _globalInputChannel = 'omni';
            let _inputVoiceChannels = 8;
            let _outputMode = 'non-mpe';
            let _globalOutputChannel = '1';
            let _callbacks = {
                onReady: () => {},
                onInputSelected: (i) => {},
                onOutputSelected: (o) => {},
                onStatusUpdate: (s) => {}
            };

            function _updateStatus(s) {
                _status = s;
                _callbacks.onStatusUpdate(_status);
            }

            function _onMIDISuccess(m) {
                _midiAccess = m;
                _updateStatus("Connected");
                _inputsList = [];
                _midiAccess.inputs.forEach(i => {
                    _inputsList.push({
                        id: i.id,
                        name: i.name || `In ${_inputsList.length+1}`
                    });
                });
                _outputsList = [];
                _midiAccess.outputs.forEach(o => {
                    _outputsList.push({
                        id: o.id,
                        name: o.name || `Out ${_outputsList.length+1}`
                    });
                });
                _callbacks.onReady(_inputsList, _outputsList);
            }

            function _onMIDIFailure(e) {
                _updateStatus("MIDI failed: " + e);
                _callbacks.onReady([], []);
            }
            return {
                initialize: (c) => {
                    _callbacks = {
                        ..._callbacks,
                        ...c
                    };
                    _updateStatus("Requesting...");
                    if (navigator.requestMIDIAccess) navigator.requestMIDIAccess().then(_onMIDISuccess, _onMIDIFailure);
                    else {
                        _updateStatus("Web MIDI not supported.");
                        _callbacks.onReady([], []);
                    }
                },
                selectInput: (id) => {
                    if (_selectedInput) {
                        _selectedInput.onmidimessage = null;
                        _selectedInput = null;
                    }
                    if (id && _midiAccess) {
                        _selectedInput = _midiAccess.inputs.get(id);
                        if (_selectedInput) _callbacks.onInputSelected(_selectedInput);
                        else {
                            console.warn(`Input ${id} not found.`);
                            _callbacks.onInputSelected(null);
                        }
                    } else _callbacks.onInputSelected(null);
                },
                selectOutput: (id) => {
                    _selectedOutput = null;
                    if (id && _midiAccess) {
                        _selectedOutput = _midiAccess.outputs.get(id);
                        if (!_selectedOutput) console.warn(`Output ${id} not found.`);
                    }
                    _callbacks.onOutputSelected(_selectedOutput);
                },
                setMPEEnabled: (e) => {
                    _isMPEEnabled = !!e;
                },
                setMPEGlobalInputChannel: (c) => {
                    _globalInputChannel = c;
                },
                setMPEInputVoiceChannels: (c) => {
                    _inputVoiceChannels = parseInt(c) || 8;
                },
                setMPEOutputMode: (m) => {
                    _outputMode = m;
                },
                setMPEGlobalOutputChannel: (c) => {
                    _globalOutputChannel = c;
                },
                isMPEEnabled: () => _isMPEEnabled,
                getOutputChannel: () => parseInt(_globalOutputChannel) - 1,
                isMPEOutput: () => _outputMode === 'mpe',
                getMPEInputConfig: () => ({
                    isEnabled: _isMPEEnabled,
                    globalChannel: _globalInputChannel,
                    voiceChannelCount: _inputVoiceChannels
                }),
                getSelectedOutputDevice: () => _selectedOutput,
            };
        })();

        // --- *** Refactor: ActiveNoteManager Module (A6) *** ---
        const ActiveNoteManager = (function() {
            /* ... unchanged from previous step ... */
            let activeArpNotes = new Map();
            let config = {
                midiOutput: null,
                updatePlaybackKeyCallback: (n) => {},
                getMPEOutputMode: () => false
            };

            function sendNoteOnHelper(n, v, c) {
                if (config.midiOutput && n >= 0 && n <= 127 && v > 0 && v <= 127 && c >= 0 && c <= 15) {
                    const m = config.getMPEOutputMode();
                    config.midiOutput.send([0x90 + c, n, v]);
                }
            }

            function sendNoteOffHelper(n, c, v = 0) {
                if (config.midiOutput && n >= 0 && n <= 127 && c >= 0 && c <= 15) {
                    const m = config.getMPEOutputMode();
                    config.midiOutput.send([0x80 + c, n, v]);
                }
            }

            function cancelNoteOff(n) {
                const s = activeArpNotes.get(n);
                if (s && s.noteOffTimeoutId !== null) {
                    clearTimeout(s.noteOffTimeoutId);
                    activeArpNotes.set(n, {
                        ...s,
                        noteOffTimeoutId: null
                    });
                    config.updatePlaybackKeyCallback(n);
                }
            }

            function stopNote(n, c) {
                cancelNoteOff(n);
                if (activeArpNotes.has(n)) {
                    sendNoteOffHelper(n, c);
                    activeArpNotes.delete(n);
                    config.updatePlaybackKeyCallback(n);
                }
            }

            function scheduleNoteOff(n, d, c) {
                cancelNoteOff(n);
                const t = setTimeout(() => stopNote(n, c), Math.max(0, d));
                const s = activeArpNotes.get(n);
                if (s) {
                    activeArpNotes.set(n, {
                        ...s,
                        noteOffTimeoutId: t,
                        isExtended: false
                    });
                    config.updatePlaybackKeyCallback(n);
                }
            }

            function startNote(n, v, c) {
                if (activeArpNotes.has(n)) cancelNoteOff(n);
                sendNoteOnHelper(n, v, c);
                activeArpNotes.set(n, {
                    noteOffTimeoutId: null,
                    isExtended: false,
                    chordsHeldCount: 0,
                    timeHeldDivisions: 0,
                    outputChannel: c
                });
                config.updatePlaybackKeyCallback(n);
            }

            function allNotesOff() {
                const nS = Array.from(activeArpNotes.entries());
                nS.forEach(([n, s]) => stopNote(n, s.outputChannel));
                if (activeArpNotes.size > 0) {
                    console.warn("ANM: Map !empty");
                    activeArpNotes.clear();
                }
            }
            return {
                initialize: (cfg) => {
                    config.updatePlaybackKeyCallback = cfg.updatePlaybackKeyCallback || ((n) => {});
                    config.getMPEOutputMode = cfg.getMPEOutputMode || (() => false);
                },
                setMidiOutput: (o) => {
                    allNotesOff();
                    config.midiOutput = o;
                },
                getActiveNotesMap: () => activeArpNotes,
                startNote,
                stopNote,
                scheduleNoteOff,
                cancelNoteOff,
                allNotesOff,
                hasNote: (n) => activeArpNotes.has(n),
                updateNoteState: (n, pS) => {
                    const s = activeArpNotes.get(n);
                    if (s) {
                        activeArpNotes.set(n, {
                            ...s,
                            ...pS
                        });
                        config.updatePlaybackKeyCallback(n);
                    }
                }
            };
        })();

        // --- *** Refactor: NoteInputManager Module (A2) *** ---
        const NoteInputManager = (function() {
            /* ... unchanged from previous step ... */
            let _rawHeldNotes = [];
            let _heldNotes = [];
            let _heldNotesUI = new Set();
            let _heldNotesMIDI = new Set();
            let _playedNoteOrder = [];
            let _octaveExpandedNoteMap = new Map();
            let _notePressures = new Map();
            let _noteMPEYAxis = new Map();
            let _mpeChannelNotes = new Array(16).fill(null);
            let _octaveCount = 1;
            let _isSustainPedalPressed = false;
            let _sustainedNotesMIDI = new Set();
            let config = {
                onNotesChanged: (h, rH, pO) => {},
                getMPEInputConfig: () => ({
                    isEnabled: false
                }),
                updatePianoKeyCallback: (n, s) => {},
                updatePlaybackKeyboardCallback: () => {}
            };
            const defP = 0;
            const defY = 0;

            function _genOctExp(inp, oct) {
                const exp = [];
                const seen = new Set();
                _octaveExpandedNoteMap.clear();
                for (let i = 0; i < oct; i++) {
                    for (const o of inp) {
                        const eN = o + (12 * i);
                        if (!seen.has(eN) && eN <= 127) {
                            exp.push(eN);
                            seen.add(eN);
                            _octaveExpandedNoteMap.set(eN, o);
                        }
                    }
                }
                return exp;
            }

            function _findOrig(expN) {
                if (_rawHeldNotes.includes(expN)) return expN;
                return _octaveExpandedNoteMap.get(expN) || null;
            }

            function _updateAndNotify() {
                _rawHeldNotes.sort((a, b) => a - b);
                _heldNotes = _genOctExp(_rawHeldNotes, _octaveCount);
                config.onNotesChanged([..._heldNotes], [..._rawHeldNotes], getPlayedNoteOrderFiltered());
            }

            function _add(n, src = 'ui', ch = null) {
                const isUI = src === 'ui';
                const hS = isUI ? _heldNotesUI : _heldNotesMIDI;
                let added = false;
                const mCfg = config.getMPEInputConfig();
                if (isUI) {
                    if (!hS.has(n)) {
                        hS.add(n);
                        _rawHeldNotes.push(n);
                        _playedNoteOrder.push(n);
                        added = true;
                    } else {
                        hS.delete(n);
                        const i = _rawHeldNotes.indexOf(n);
                        if (i > -1) {
                            _rawHeldNotes.splice(i, 1);
                            const pI = _playedNoteOrder.indexOf(n);
                            if (pI > -1) _playedNoteOrder.splice(pI, 1);
                        }
                    }
                    _updateAndNotify();
                    config.updatePianoKeyCallback(n, src);
                    config.updatePlaybackKeyboardCallback();
                } else {
                    if (!_heldNotesMIDI.has(n)) {
                        _heldNotesMIDI.add(n);
                        _rawHeldNotes.push(n);
                        _playedNoteOrder.push(n);
                        added = true;
                    }
                    if (added) _updateAndNotify();
                    config.updatePianoKeyCallback(n, 'midi');
                    config.updatePlaybackKeyboardCallback();
                    if (mCfg.isEnabled && ch !== null && ch >= 0 && ch < 16) _mpeChannelNotes[ch] = n;
                }
                if (added) {
                    _notePressures.set(n, defP);
                    _noteMPEYAxis.set(n, defY);
                }
            }

            function _remove(n, src = 'midi', ch = null) {
                let removed = false;
                const mCfg = config.getMPEInputConfig();
                if (src === 'midi') {
                    if (_isSustainPedalPressed) {
                        _sustainedNotesMIDI.add(n);
                        return;
                    }
                    if (_heldNotesMIDI.has(n)) {
                        _heldNotesMIDI.delete(n);
                        const i = _rawHeldNotes.indexOf(n);
                        if (i > -1) {
                            _rawHeldNotes.splice(i, 1);
                            const pI = _playedNoteOrder.indexOf(n);
                            if (pI > -1) _playedNoteOrder.splice(pI, 1);
                            removed = true;
                        }
                        config.updatePianoKeyCallback(n, null);
                        if (mCfg.isEnabled && ch !== null && ch >= 0 && ch < 16 && _mpeChannelNotes[ch] === n) _mpeChannelNotes[ch] = null;
                    }
                } else {
                    console.warn("NIM: _remove UI");
                    return;
                }
                if (removed) {
                    _notePressures.delete(n);
                    _noteMPEYAxis.delete(n);
                    _updateAndNotify();
                    config.updatePlaybackKeyboardCallback();
                }
            }

            function getPlayedNoteOrderFiltered() {
                return _playedNoteOrder.filter(n => _rawHeldNotes.includes(n));
            }
            return {
                initialize: (cfg) => {
                    config = {
                        ...config,
                        ...cfg
                    };
                },
                handleNoteOn: (n, s = 'ui', c = null) => {
                    _add(n, s, c);
                },
                handleNoteOff: (n, s = 'midi', c = null) => {
                    _remove(n, s, c);
                },
                handleSustain: (isP) => {
                    const was = _isSustainPedalPressed;
                    _isSustainPedalPressed = isP;
                    if (was && !isP) {
                        let rel = [..._sustainedNotesMIDI];
                        _sustainedNotesMIDI.clear();
                        rel.forEach(sN => {
                            if (!_heldNotesMIDI.has(sN)) {
                                let ch = -1;
                                if (config.getMPEInputConfig().isEnabled) ch = _mpeChannelNotes.findIndex(n => n === sN);
                                _remove(sN, 'midi', ch !== -1 ? ch : null);
                            }
                        });
                    }
                },
                handlePressureUpdate: (n, p, isP = false) => {
                    const o = isP ? _findOrig(n) : n;
                    if (o !== null && _notePressures.has(o)) _notePressures.set(o, p);
                },
                handleMPEYAxisUpdate: (n, v) => {
                    const o = _findOrig(n);
                    if (o !== null) _noteMPEYAxis.set(o, v);
                },
                setOctaveCount: (c) => {
                    const nC = Math.max(1, Math.min(4, parseInt(c) || 1));
                    if (nC !== _octaveCount) {
                        _octaveCount = nC;
                        _updateAndNotify();
                        config.updatePlaybackKeyboardCallback();
                    }
                },
                getHeldNotes: () => [..._heldNotes],
                getRawHeldNotes: () => [..._rawHeldNotes],
                getPlayedNoteOrderFiltered,
                getNotePressure: (o) => _notePressures.get(o) ?? defP,
                getNoteMPEYAxis: (o) => _noteMPEYAxis.get(o) ?? defY,
                findOriginalNote: _findOrig,
                getMPEChannelNote: (c) => _mpeChannelNotes[c] ?? null,
                hasHeldNotes: () => _rawHeldNotes.length > 0,
                hasHeldUINote: (n) => _heldNotesUI.has(n),
                hasHeldMIDINote: (n) => _heldNotesMIDI.has(n),
            };
        })();

        // --- *** Refactor: ClockManager Module (A4) *** ---
        const ClockManager = (function() {
            /* ... unchanged from previous step ... */
            let _tempoSource = 'internal';
            let _bpm = 120;
            let _clockDivision = '1/4';
            let _clkDivMax = 24;
            let _tickCounter = -1;
            let _intClock = null;
            let _clkDivDurMs = (1000 / (120 / 60 * 24)) * 24;
            const _histSz = 24;
            let _tickHist = new Array(_histSz).fill(performance.now());
            let _tickIdx = _histSz;
            let config = {
                onArpStep: () => {},
                onTempoUpdate: (b, s) => {}
            };

            function _calcClkDivMax(d) {
                switch (d) {
                    case '1/1':
                        return 96;
                    case '1/2':
                        return 48;
                    case '1/4':
                        return 24;
                    case '1/8':
                        return 12;
                    case '1/16':
                        return 6;
                    case '1/32':
                        return 3;
                    case '1/2T':
                        return 32;
                    case '1/4T':
                        return 16;
                    case '1/8T':
                        return 8;
                    case '1/16T':
                        return 4;
                    case '1/32T':
                        return 2;
                    default:
                        return 24;
                }
            }

            function _tickProc() {
                _tickCounter++;
                if (_tickCounter >= 0 && (_tickCounter % _clkDivMax === 0)) config.onArpStep();
            }

            function _handleIntTick() {
                _tickProc();
            }

            function _updateDur() {
                if (_tempoSource === 'internal' && _bpm > 0) {
                    const tps = (_bpm / 60) * 24;
                    const iMs = 1000 / tps;
                    _clkDivDurMs = iMs * _clkDivMax;
                }
            }

            function _setupIntClock() {
                clearInterval(_intClock);
                if (_bpm <= 0) _bpm = 1;
                _updateDur();
                const tps = (_bpm / 60) * 24;
                const iMs = 1000 / tps;
                _intClock = setInterval(_handleIntTick, iMs);
                _tickCounter = -1;
            }

            function _estExtBPM() {
                const now = performance.now();
                for (let i = 0; i < _histSz - 1; i++) _tickHist[i] = _tickHist[i + 1];
                _tickHist[_histSz - 1] = now;
                _tickIdx++;
                let avgI = 0;
                let latestI = 0;
                if (_tickIdx > 1) latestI = _tickHist[_histSz - 1] - _tickHist[_histSz - 2];
                if (_tickIdx >= _histSz) {
                    const fT = _tickHist[0];
                    const lT = _tickHist[_histSz - 1];
                    const tD = lT - fT;
                    avgI = tD / (_histSz - 1);
                    if (avgI > 0) {
                        _bpm = Math.round(60000 / (avgI * 24));
                        _clkDivDurMs = (latestI > 0 ? latestI : avgI) * _clkDivMax;
                        config.onTempoUpdate(_bpm, _tempoSource);
                    }
                } else if (_tickIdx > 1 && latestI > 0) {
                    _bpm = Math.round(60000 / (latestI * 24));
                    _clkDivDurMs = latestI * _clkDivMax;
                    config.onTempoUpdate(_bpm, _tempoSource);
                }
            }
            return {
                initialize: (cfg) => {
                    config = {
                        ...config,
                        ...cfg
                    };
                    _tempoSource = cfg.initialTempoSource || 'internal';
                    _bpm = cfg.initialBPM || 120;
                    _clockDivision = cfg.initialClockDivision || '1/4';
                    _clkDivMax = _calcClkDivMax(_clockDivision);
                    _updateDur();
                    config.onTempoUpdate(_bpm, _tempoSource);
                },
                setTempoSource: (s) => {
                    if (s !== _tempoSource) {
                        _tempoSource = s;
                        if (_tempoSource === 'internal') _setupIntClock();
                        else {
                            clearInterval(_intClock);
                            _intClock = null;
                            _tickCounter = -1;
                            _tickHist = new Array(_histSz).fill(performance.now());
                            _tickIdx = _histSz;
                            _updateDur();
                        }
                        config.onTempoUpdate(_bpm, _tempoSource);
                    }
                },
                setBPM: (b) => {
                    const bV = parseInt(b) || 120;
                    if (bV !== _bpm) {
                        _bpm = bV;
                        if (_tempoSource === 'internal') _setupIntClock();
                        config.onTempoUpdate(_bpm, _tempoSource);
                    }
                },
                setClockDivision: (d) => {
                    if (d !== _clockDivision) {
                        _clockDivision = d;
                        _clkDivMax = _calcClkDivMax(d);
                        if (_tempoSource === 'internal') _setupIntClock();
                        else {
                            let lI = 0;
                            if (_tickIdx > 1) lI = _tickHist[_histSz - 1] - _tickHist[_histSz - 2];
                            if (lI > 0) _clkDivDurMs = lI * _clkDivMax;
                            else _updateDur();
                        }
                    }
                },
                start: () => {
                    _tickCounter = -1;
                    if (_tempoSource === 'internal' && !_intClock) _setupIntClock();
                },
                stop: () => {
                    if (_intClock) {
                        clearInterval(_intClock);
                        _intClock = null;
                    }
                    _tickCounter = -1;
                },
                externalTick: () => {
                    if (_tempoSource === 'external') {
                        _estExtBPM();
                        _tickProc();
                    }
                },
                getBPM: () => _bpm,
                getClockDivisionDurationMs: () => _clkDivDurMs
            };
        })();

        // --- *** Refactor: RhythmManager Module (A3) *** ---
        const RhythmManager = (function() {
            // --- Rhythm Event Constants --- (Copied locally)
            const RHYTHM_BEAT = 'B';
            const RHYTHM_REST = 'R';
            const PATTERN_NOTE = 'N';
            const PATTERN_SKIP = 'S';

            // --- State ---
            let _patternSteps = 5;
            let _patternBeats = 3;
            let _patternOffset = 0;
            let _isPatternDisabled = false;
            let _rhythmSteps = 7;
            let _rhythmBeats = 5;
            let _rhythmOffset = 0;
            let _isRhythmDisabled = false;
            let _isGateFlexEnabled = false;

            let _patternRhythm = [];
            let _rhythm = [];
            let _rhythmGateMultipliers = [];

            // --- Config / Callbacks ---
            let config = {
                onPatternDisplayUpdate: (rhythmArray, isDisabled) => {},
                onRhythmDisplayUpdate: (rhythmArray, isDisabled) => {},
                onPatternControlsUpdate: (isDisabled) => {},
                onRhythmControlsUpdate: (isDisabled) => {}
            };

            // --- Internal Methods ---

            /** Generates Euclidean rhythm pattern. */
            function _generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent, isDisabled = false) {
                if (isDisabled || steps <= 0) {
                    return new Array(steps > 0 ? steps : 0).fill(beatEvent);
                }
                beats = Math.min(beats, steps);
                const rhythmArr = new Array(steps).fill(restEvent);
                let beatIndex = 0;
                for (let i = 0; i < steps; i++) {
                    if (Math.floor((beatIndex * steps) / beats) === i) {
                        rhythmArr[i] = beatEvent;
                        beatIndex++;
                    }
                }
                const actualOffset = offset % steps;
                const positiveOffset = actualOffset >= 0 ? actualOffset : steps + actualOffset;
                if (positiveOffset > 0) {
                    return [...rhythmArr.slice(steps - positiveOffset), ...rhythmArr.slice(0, steps - positiveOffset)];
                }
                return rhythmArr;
            }

            /** Generates gate multipliers based on the rhythm array. */
            function _generateRhythmGateMultipliers(rhythmArray) {
                const len = rhythmArray.length;
                if (len === 0) return [];
                const multipliers = new Array(len).fill(0);
                for (let i = 0; i < len; i++) {
                    if (rhythmArray[i] === RHYTHM_BEAT) {
                        let stepsToNextBeat = 1;
                        let nextIndex = (i + 1) % len;
                        while (nextIndex !== i && rhythmArray[nextIndex] !== RHYTHM_BEAT) {
                            stepsToNextBeat++;
                            nextIndex = (nextIndex + 1) % len;
                        }
                        if (nextIndex === i && stepsToNextBeat === len && rhythmArray.filter(s => s === RHYTHM_BEAT).length === 1) {
                            multipliers[i] = len; // Full length if only one beat
                        } else if (nextIndex !== i) {
                            multipliers[i] = stepsToNextBeat;
                        } else {
                            multipliers[i] = 1; // Fallback for single beat weirdness
                        }
                    }
                }
                return multipliers;
            }

            /** Recalculates rhythms and notifies UI callbacks. */
            function _updateRhythmsAndNotify() {
                // Generate Pattern
                _patternRhythm = _generateEuclideanRhythm(_patternSteps, _patternBeats, _patternOffset, PATTERN_NOTE, PATTERN_SKIP, _isPatternDisabled);
                config.onPatternDisplayUpdate([..._patternRhythm], _isPatternDisabled); // Pass copy
                config.onPatternControlsUpdate(_isPatternDisabled);

                // Generate Rhythm
                _rhythm = _generateEuclideanRhythm(_rhythmSteps, _rhythmBeats, _rhythmOffset, RHYTHM_BEAT, RHYTHM_REST, _isRhythmDisabled);
                _rhythmGateMultipliers = _generateRhythmGateMultipliers(_rhythm);
                config.onRhythmDisplayUpdate([..._rhythm], _isRhythmDisabled); // Pass copy
                config.onRhythmControlsUpdate(_isRhythmDisabled);
            }

            // --- Public Interface ---
            return {
                initialize: (initialConfig) => {
                    config = {
                        ...config,
                        ...initialConfig
                    };
                    // Set initial values from config or defaults
                    _patternSteps = initialConfig.initialPatternSteps || 5;
                    _patternBeats = initialConfig.initialPatternBeats || 3;
                    _patternOffset = initialConfig.initialPatternOffset || 0;
                    _isPatternDisabled = initialConfig.initialIsPatternDisabled || false;
                    _rhythmSteps = initialConfig.initialRhythmSteps || 7;
                    _rhythmBeats = initialConfig.initialRhythmBeats || 5;
                    _rhythmOffset = initialConfig.initialRhythmOffset || 0;
                    _isRhythmDisabled = initialConfig.initialIsRhythmDisabled || false;
                    _isGateFlexEnabled = initialConfig.initialIsGateFlexEnabled || false;

                    _updateRhythmsAndNotify(); // Generate initial rhythms and update UI
                    // console.log("RhythmManager Initialized");
                },

                // --- Setters ---
                setPatternSteps: (v) => {
                    _patternSteps = parseInt(v) || 1;
                    _updateRhythmsAndNotify();
                },
                setPatternBeats: (v) => {
                    _patternBeats = parseInt(v) || 1;
                    _updateRhythmsAndNotify();
                },
                setPatternOffset: (v) => {
                    _patternOffset = parseInt(v) || 0;
                    _updateRhythmsAndNotify();
                },
                setPatternEnabled: (enabled) => {
                    _isPatternDisabled = !enabled;
                    _updateRhythmsAndNotify();
                },
                setRhythmSteps: (v) => {
                    _rhythmSteps = parseInt(v) || 1;
                    _updateRhythmsAndNotify();
                },
                setRhythmBeats: (v) => {
                    _rhythmBeats = parseInt(v) || 1;
                    _updateRhythmsAndNotify();
                },
                setRhythmOffset: (v) => {
                    _rhythmOffset = parseInt(v) || 0;
                    _updateRhythmsAndNotify();
                },
                setRhythmEnabled: (enabled) => {
                    _isRhythmDisabled = !enabled;
                    _updateRhythmsAndNotify();
                },
                setGateFlexEnabled: (enabled) => {
                    _isGateFlexEnabled = !!enabled; /* No rhythm recalc needed */
                },

                // --- Getters ---
                getPatternEvent: (index) => {
                    if (!_patternRhythm || _patternRhythm.length === 0) return PATTERN_NOTE; // Default if invalid
                    return _patternRhythm[index % _patternRhythm.length];
                },
                getRhythmEvent: (index) => {
                    if (!_rhythm || _rhythm.length === 0) return RHYTHM_BEAT; // Default if invalid
                    return _rhythm[index % _rhythm.length];
                },
                getRhythmGateMultiplier: (index) => {
                    if (!_rhythmGateMultipliers || _rhythmGateMultipliers.length === 0) return 1;
                    return _rhythmGateMultipliers[index % _rhythmGateMultipliers.length] || 1;
                },
                isGateFlexEnabled: () => _isGateFlexEnabled,
                isPatternActive: () => !_isPatternDisabled, // Getter for checking if pattern affects logic
                isRhythmActive: () => !_isRhythmDisabled, // Getter for checking if rhythm affects logic

                // Getters for rhythm lengths if needed externally (e.g. for loop limits)
                getPatternLength: () => _patternRhythm.length,
                getRhythmLength: () => _rhythm.length,
            };
        })();
        // --- *** End RhythmManager Module *** ---


        // --- MIDI Variables ---
        let currentMidiInputDevice = null;

        // --- Rhythm Event Constants --- (Removed globals, internal to RhythmManager)
        // const RHYTHM_BEAT = 'B'; const RHYTHM_REST = 'R'; const PATTERN_NOTE = 'N'; const PATTERN_SKIP = 'S';

        // --- Rhythm Pattern Variables (Removed globals, managed by RhythmManager) ---
        // let patternRhythm = []; let rhythm = []; let rhythmGateMultipliers = [];
        // let isPatternDisabled = false; let isRhythmDisabled = false;

        // --- Arpeggiator State Variables ---
        let arpRunning = false;
        let currentNoteIndex = 0;
        let currentRhythmIndex = 0;
        let currentPatternIndex = 0; // Indices remain global for now
        let arpMode = 'up';
        let arpSyncMode = 'key';
        let currentModeNoteList = [];
        let chordNValue = 2;

        // --- ChordN Gate Extension ---
        let maxChordExtension = 2;
        let maxTimeExtensionDivisions = 16;

        // --- Walk Mode Parameters ---
        let walkSkew = 0;
        let walkDistance = 0;

        // --- Sub Arp ---
        let subArpScalePercentage = 0;
        let subArpMode = 'up';

        // --- Gate Flex (Removed global, managed by RhythmManager) ---
        // let isGateFlexEnabled = false;

        // --- Arpeggio Mode Specific State ---
        let shuffledNotesOrder = [];
        let stableShuffledOrder = [];
        let stableShuffleIndex = 0;
        let lastNotesToArp = [];

        // --- UI Elements and Display ---
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 20;
        let highlightedPianoKey = null;
        let highlightedPlaybackPianoKey = null;
        const midiStatusDisplay = document.getElementById('midiStatus');
        const midiInputSelectElem = document.getElementById('midiInputSelect');
        const midiOutputSelectElem = document.getElementById('midiOutputSelect');
        const tempoBPMDisplay = document.getElementById('tempoBPM');


        // --- Velocity Settings ---
        let baseVelocityValue = 96;
        let maxVelocityValue = 127;

        // --- Gate Length ---
        let gateLengthPercentage = 50;
        let gateLengthValueDisplay = document.getElementById('gateLengthValue');

        // -- Miscellaneous constants --
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const LOOKAHEAD_MAX_STEPS = 64;


        // --- Event Listener Setup ---
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        startButton.addEventListener('click', startArpeggiator);
        stopButton.addEventListener('click', stopArpeggiator);
        midiInputSelectElem.addEventListener('change', function() {
            MidiManager.selectInput(this.value);
        });
        midiOutputSelectElem.addEventListener('change', function() {
            MidiManager.selectOutput(this.value);
        });
        document.getElementById('arpMode').addEventListener('change', function() {
            /* ... unchanged ... */
            arpMode = this.value;
            const cN = document.getElementById('chordNControls');
            const wP = document.getElementById('walkParams');
            const wD = document.getElementById('walkDistanceContainer');
            cN.style.display = (arpMode === 'chordN') ? 'block' : 'none';
            wP.style.display = (arpMode === 'walk' || arpMode === 'normalWalk') ? 'block' : 'none';
            wD.style.display = (arpMode === 'normalWalk') ? 'block' : 'none';
            updateArpeggiatorNoteListAndIndex();
        });
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });
        document.getElementById('enableMPE').addEventListener('change', function() {
            MidiManager.setMPEEnabled(this.checked);
        });
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            MidiManager.setMPEGlobalInputChannel(this.value);
        });
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            MidiManager.setMPEInputVoiceChannels(this.value);
        });
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            MidiManager.setMPEOutputMode(this.value);
        });
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            MidiManager.setMPEGlobalOutputChannel(this.value);
        });
        document.getElementById('octaves').addEventListener('input', function() {
            NoteInputManager.setOctaveCount(this.value);
            document.getElementById('octavesValue').textContent = this.value;
        });
        document.getElementById('tempoSource').addEventListener('change', function() {
            ClockManager.setTempoSource(this.value);
        });
        tempoBPMDisplay.addEventListener('change', function() {
            ClockManager.setBPM(this.value);
        });
        document.getElementById('clockDivision').addEventListener('change', function() {
            ClockManager.setClockDivision(this.value);
        });
        document.getElementById('chordNValue').addEventListener('input', function() {
            chordNValue = parseInt(this.value);
            document.getElementById('chordNValueDisplay').textContent = chordNValue;
            updateModeNoteList();
        });
        document.getElementById('chordNOrdering').addEventListener('change', function() {
            updateModeNoteList();
        });
        document.getElementById('maxChordExtension').addEventListener('input', function() {
            maxChordExtension = parseInt(this.value);
            document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        });
        document.getElementById('maxTimeExtension').addEventListener('input', function() {
            maxTimeExtensionDivisions = parseInt(this.value);
            document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        });
        document.getElementById('walkSkew').addEventListener('input', function() {
            walkSkew = parseFloat(this.value);
            document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        });
        document.getElementById('walkDistance').addEventListener('input', function() {
            walkDistance = parseFloat(this.value);
            document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        });
        document.getElementById('baseVelocity').addEventListener('input', function() {
            baseVelocityValue = parseInt(this.value);
            document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        });
        document.getElementById('maxVelocity').addEventListener('input', function() {
            maxVelocityValue = parseInt(this.value);
            document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        });
        document.getElementById('gateLength').addEventListener('input', function() {
            gateLengthPercentage = parseInt(this.value);
            document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        });
        document.getElementById('subArpScale').addEventListener('input', function() {
            subArpScalePercentage = parseInt(this.value);
            document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        });
        document.getElementById('subArpMode').addEventListener('change', function() {
            subArpMode = this.value;
        });

        // *** Refactor: Rhythm/Pattern Listeners use RhythmManager ***
        document.getElementById('patternSteps').addEventListener('input', function() {
            RhythmManager.setPatternSteps(this.value);
            document.getElementById('patternStepsValue').textContent = this.value;
            // Adjust max beats for pattern
            document.getElementById('patternBeats').max = this.value;
            if (parseInt(document.getElementById('patternBeats').value) > parseInt(this.value)) {
                document.getElementById('patternBeats').value = this.value;
                RhythmManager.setPatternBeats(this.value); // Also update manager if changed
                document.getElementById('patternBeatsValue').textContent = this.value;
            }
            // Adjust offset limits
            const maxOff = Math.floor(parseInt(this.value) / 2);
            document.getElementById('patternOffset').min = -maxOff;
            document.getElementById('patternOffset').max = maxOff;
            if (Math.abs(parseInt(document.getElementById('patternOffset').value)) > maxOff) {
                document.getElementById('patternOffset').value = 0;
                RhythmManager.setPatternOffset(0);
                document.getElementById('patternOffsetValue').textContent = 0;
            }
        });
        document.getElementById('patternBeats').addEventListener('input', function() {
            RhythmManager.setPatternBeats(this.value);
            document.getElementById('patternBeatsValue').textContent = this.value;
        });
        document.getElementById('patternOffset').addEventListener('input', function() {
            RhythmManager.setPatternOffset(this.value);
            document.getElementById('patternOffsetValue').textContent = this.value;
        });
        document.getElementById('rhythmSteps').addEventListener('input', function() {
            RhythmManager.setRhythmSteps(this.value);
            document.getElementById('rhythmStepsValue').textContent = this.value;
            // Adjust max beats for rhythm
            document.getElementById('rhythmBeats').max = this.value;
            if (parseInt(document.getElementById('rhythmBeats').value) > parseInt(this.value)) {
                document.getElementById('rhythmBeats').value = this.value;
                RhythmManager.setRhythmBeats(this.value);
                document.getElementById('rhythmBeatsValue').textContent = this.value;
            }
            // Adjust offset limits
            const maxOff = Math.floor(parseInt(this.value) / 2);
            document.getElementById('rhythmOffset').min = -maxOff;
            document.getElementById('rhythmOffset').max = maxOff;
            if (Math.abs(parseInt(document.getElementById('rhythmOffset').value)) > maxOff) {
                document.getElementById('rhythmOffset').value = 0;
                RhythmManager.setRhythmOffset(0);
                document.getElementById('rhythmOffsetValue').textContent = 0;
            }
        });
        document.getElementById('rhythmBeats').addEventListener('input', function() {
            RhythmManager.setRhythmBeats(this.value);
            document.getElementById('rhythmBeatsValue').textContent = this.value;
        });
        document.getElementById('rhythmOffset').addEventListener('input', function() {
            RhythmManager.setRhythmOffset(this.value);
            document.getElementById('rhythmOffsetValue').textContent = this.value;
        });
        document.getElementById('enablePattern').addEventListener('change', function() {
            RhythmManager.setPatternEnabled(this.checked);
        });
        document.getElementById('enableRhythm').addEventListener('change', function() {
            RhythmManager.setRhythmEnabled(this.checked);
        });
        document.getElementById('enableGateFlex').addEventListener('change', function() {
            RhythmManager.setGateFlexEnabled(this.checked);
        });

        // TAB SWITCHING (unchanged)
        document.querySelectorAll('.tab-button').forEach(b => {
            b.addEventListener('click', () => {
                const id = b.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                b.classList.add('active');
                document.getElementById(id).classList.add('active');
            });
        });
        // --- End Event Listener Setup ---

        function updateTempoDisplay(bpmValue, sourceValue) {
            /* ... unchanged ... */
            tempoBPMDisplay.value = bpmValue;
            const isInt = sourceValue === 'internal';
            tempoBPMDisplay.title = `Tempo (BPM): ${isInt?'Editable':'External Clock'}`;
            tempoBPMDisplay.readOnly = !isInt;
        }

        function populateDeviceSelect(selectElement, devices, includeNoneOption = true) {
            /* ... unchanged ... */
            while (selectElement.options.length > (includeNoneOption ? 1 : 0)) selectElement.remove(includeNoneOption ? 1 : 0);
            devices.forEach(d => {
                const o = document.createElement('option');
                o.value = d.id;
                o.text = d.name;
                selectElement.appendChild(o);
            });
        }

        function handleNotesChanged(newHeldNotes, newRawHeldNotes, newPlayedOrder) {
            /* ... unchanged ... */
            updateArpeggiatorNoteListAndIndex();
            updatePlaybackKeyboardUI();
            if (arpSyncMode === 'key') {
                if (newRawHeldNotes.length > 0 && !arpRunning) startArpeggiator();
                else if (newRawHeldNotes.length === 0 && arpRunning) stopArpeggiator();
            }
            if (arpRunning) {
                const added = newRawHeldNotes.filter(n => !lastNotesToArp.includes(n));
                const removed = lastNotesToArp.filter(n => !newRawHeldNotes.includes(n));
                if (arpMode === 'shuffled') {
                    added.forEach(n => {
                        const i = Math.floor(Math.random() * (shuffledNotesOrder.length + 1));
                        shuffledNotesOrder.splice(i, 0, n);
                        if (i <= currentNoteIndex) currentNoteIndex++;
                    });
                    removed.forEach(n => {
                        const i = shuffledNotesOrder.indexOf(n);
                        if (i !== -1) {
                            shuffledNotesOrder.splice(i, 1);
                            if (i < currentNoteIndex && currentNoteIndex > 0) currentNoteIndex--;
                            if (currentNoteIndex >= shuffledNotesOrder.length && shuffledNotesOrder.length > 0) currentNoteIndex = shuffledNotesOrder.length - 1;
                            else if (shuffledNotesOrder.length === 0) currentNoteIndex = 0;
                        }
                    });
                } else if (arpMode === 'stableShuffled') {
                    added.forEach(n => {
                        const i = Math.floor(Math.random() * (stableShuffledOrder.length + 1));
                        stableShuffledOrder.splice(i, 0, n);
                        if (i <= stableShuffleIndex) stableShuffleIndex++;
                    });
                    removed.forEach(n => {
                        const i = stableShuffledOrder.indexOf(n);
                        if (i !== -1) {
                            stableShuffledOrder.splice(i, 1);
                            if (i < stableShuffleIndex && stableShuffleIndex > 0) stableShuffleIndex--;
                            if (stableShuffleIndex >= stableShuffledOrder.length && stableShuffledOrder.length > 0) stableShuffleIndex = stableShuffledOrder.length - 1;
                            else if (stableShuffledOrder.length === 0) stableShuffleIndex = 0;
                        }
                    });
                }
            }
            lastNotesToArp = newRawHeldNotes;
        }

        // MidiManager Callbacks (unchanged)
        const midiManagerCallbacks = {
            onReady: (i, o) => {
                populateDeviceSelect(midiInputSelectElem, i);
                populateDeviceSelect(midiOutputSelectElem, o);
                if (i.length > 0) {
                    midiInputSelectElem.selectedIndex = 1;
                    MidiManager.selectInput(i[0].id);
                }
                if (o.length > 0) {
                    midiOutputSelectElem.selectedIndex = 1;
                    MidiManager.selectOutput(o[0].id);
                } else {
                    midiStatusDisplay.innerText += " No MIDI output.";
                    ActiveNoteManager.setMidiOutput(null);
                }
            },
            onInputSelected: (d) => {
                if (currentMidiInputDevice) currentMidiInputDevice.onmidimessage = null;
                currentMidiInputDevice = d;
                if (currentMidiInputDevice) currentMidiInputDevice.onmidimessage = onMIDIMessage;
            },
            onOutputSelected: (d) => {
                ActiveNoteManager.setMidiOutput(d);
            },
            onStatusUpdate: (s) => {
                midiStatusDisplay.innerText = `MIDI Status: ${s}`;
            }
        };

        function updateArpeggiatorNoteListAndIndex() {
            /* ... unchanged, uses NIM getters ... */
            const prevL = [...currentModeNoteList];
            const prevI = currentNoteIndex;
            const newL = updateModeNoteList();
            if (prevL.length > 0 && newL.length > 0 && arpRunning) {
                if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge', 'convergeDiverge', 'convergeDivergeInclusive', 'walk', 'normalWalk', 'played'].includes(arpMode)) {
                    const pN = (arpMode !== 'chordN' && prevL.length > 0) ? prevL[prevI % prevL.length] : null;
                    if (pN !== null) currentNoteIndex = findClosestNoteIndex(pN, prevL, newL, prevI);
                    else {
                        currentNoteIndex = (prevI % prevL.length) % newL.length;
                        if (!currentNoteIndex) currentNoteIndex = 0;
                    }
                } else if (arpMode === 'chordN') {
                    currentNoteIndex = Math.floor((prevI / prevL.length) * newL.length) % newL.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                } else {
                    currentNoteIndex = (prevI % prevL.length) % newL.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                }
            } else {
                currentNoteIndex = 0;
            }
        }

        function updatePianoUIForNote(note, source) {
            updatePianoKeyboardUI(note, source);
        }

        function midiNoteToName(note) {
            /* ... unchanged ... */
            const oct = Math.floor(note / 12) - 1;
            const name = notes[note % 12];
            return name + oct;
        }
        // generateEuclideanRhythm removed (internal to RhythmManager)
        // generateRhythmGateMultipliers removed (internal to RhythmManager)
        // updateRhythmDisplays removed (replaced by RhythmManager updates)

        // --- *** Refactor: UI update functions called by RhythmManager *** ---
        /** Updates pattern controls enabled state */
        function updatePatternControlsState(isDisabled) {
            document.getElementById('patternSteps').disabled = isDisabled;
            document.getElementById('patternBeats').disabled = isDisabled;
            document.getElementById('patternOffset').disabled = isDisabled;
        }
        /** Updates rhythm controls enabled state */
        function updateRhythmControlsState(isDisabled) {
            document.getElementById('rhythmSteps').disabled = isDisabled;
            document.getElementById('rhythmBeats').disabled = isDisabled;
            document.getElementById('rhythmOffset').disabled = isDisabled;
        }
        /** Displays rhythm in UI (remains global, called by RhythmManager) */
        function displayRhythm(rhythmArray, displayElementId, isDisabled) {
            const disp = document.getElementById(displayElementId);
            disp.innerHTML = '';
            if (!rhythmArray || rhythmArray.length === 0) return;
            rhythmArray.forEach((ev, idx) => {
                const el = document.createElement('div');
                el.classList.add('rhythm-step');
                el.innerText = ev;
                el.id = `${displayElementId}-step-${idx}`;
                if (ev === RhythmManager.RHYTHM_BEAT) el.classList.add('beat');
                else if (ev === RhythmManager.RHYTHM_REST) el.classList.add('rest');
                else if (ev === RhythmManager.PATTERN_SKIP) el.classList.add('skip');
                else if (ev === RhythmManager.PATTERN_NOTE) el.classList.add('note');
                if (isDisabled) el.classList.add('disabled-step');
                disp.appendChild(el);
            });
        }
        // Add constants to RhythmManager public interface if needed by displayRhythm
        RhythmManager.RHYTHM_BEAT = 'B';
        RhythmManager.RHYTHM_REST = 'R';
        RhythmManager.PATTERN_NOTE = 'N';
        RhythmManager.PATTERN_SKIP = 'S';


        // --- Arpeggio Mode Note List Generators (Use NoteInputManager getters) ---
        function generateAlternatingVariant(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 2) return [...(notes || [])];
            return [...notes, ...[...notes].reverse().slice(1, -1)];
        }

        function generateInclusiveAlternatingVariant(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length === 0) return [];
            return [...notes, ...[...notes].reverse()];
        }

        function generateUpNoteList(notes) {
            /* ... unchanged ... */
            return [...(notes || [])].sort((a, b) => a - b);
        }

        function generateDownNoteList(notes) {
            /* ... unchanged ... */
            return [...(notes || [])].sort((a, b) => b - a);
        }

        function generateUpDownNoteList(notes) {
            return generateAlternatingVariant(generateUpNoteList(notes));
        }

        function generateUpDownInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateUpNoteList(notes));
        }

        function generateConvergeNoteList(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sN = [...notes].sort((a, b) => a - b);
            const cL = [];
            let s = 0;
            let e = sN.length - 1;
            while (s <= e) {
                cL.push(sN[s]);
                if (s !== e) cL.push(sN[e]);
                s++;
                e--;
            }
            return cL;
        }

        function generateDivergeNoteList(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sN = [...notes].sort((a, b) => a - b);
            const dL = [];
            let s = Math.floor((sN.length - 1) / 2);
            let e = Math.ceil((sN.length - 1) / 2);
            while (s >= 0 || e < sN.length) {
                if (s >= 0) dL.push(sN[s]);
                if (s !== e && e < sN.length) dL.push(sN[e]);
                s--;
                e++;
            }
            return dL;
        }

        function generateConvergeDivergeNoteList(notes) {
            return generateAlternatingVariant(generateConvergeNoteList(notes));
        }

        function generateConvergeDivergeInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateConvergeNoteList(notes));
        }

        function generatePlayedNoteList(notes) {
            return NoteInputManager.getPlayedNoteOrderFiltered();
        }

        function generateRandomNoteList(notes) {
            return [];
        }

        function generateShuffledNoteList(notes) {
            return [...(notes || [])].sort(() => Math.random() - 0.5);
        }

        function generateStableShuffledNoteList(notes) {
            return stableShuffledOrder;
        }

        function generateChordNoteList(notes) {
            return notes && notes.length > 0 ? [
                [...notes]
            ] : [];
        }

        function generateChordNNoteList(notes, n, orderingMode = 'up') {
            /* ... unchanged ... */
            if (!notes || notes.length === 0 || n <= 0) return [];
            const sN = [...notes].sort((a, b) => a - b);
            n = Math.min(n, sN.length);
            const c = [];

            function cmb(cur, sI) {
                if (cur.length === n) {
                    c.push([...cur]);
                    return;
                }
                if (sI >= sN.length) return;
                for (let i = sI; i < sN.length; i++) {
                    if (cur.length + (sN.length - i) < n) break;
                    cur.push(sN[i]);
                    cmb(cur, i + 1);
                    cur.pop();
                }
            }
            cmb([], 0);
            if (c.length === 0) return [];
            let o = c;
            switch (orderingMode) {
                case 'down':
                    o = [...c].reverse();
                    break;
                case 'upDown':
                    o = generateAlternatingVariantCombinations(c);
                    break;
                case 'upDownInclusive':
                    o = generateInclusiveAlternatingVariantCombinations(c);
                    break;
                case 'converge':
                    o.sort((a, b) => a[0] - b[0]);
                    o = generateConvergeCombinations(c);
                    break;
                case 'diverge':
                    o.sort((a, b) => a[0] - b[0]);
                    o = generateDivergeCombinations(c);
                    break;
            }
            return o;
        }

        function generateAlternatingVariantCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 2) return [...(combinations || [])];
            return [...combinations, ...[...combinations].reverse().slice(1, -1)];
        }

        function generateInclusiveAlternatingVariantCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length === 0) return [];
            return [...combinations, ...[...combinations].reverse()];
        }

        function generateConvergeCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const l = [];
            let s = 0;
            let e = combinations.length - 1;
            while (s <= e) {
                l.push(combinations[s]);
                if (s !== e) l.push(combinations[e]);
                s++;
                e--;
            }
            return l;
        }

        function generateDivergeCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const l = [];
            let s = Math.floor((combinations.length - 1) / 2);
            let e = Math.ceil((combinations.length - 1) / 2);
            while (s >= 0 || e < combinations.length) {
                if (s >= 0) l.push(combinations[s]);
                if (s !== e && e < combinations.length) l.push(combinations[e]);
                s--;
                e++;
            }
            return l;
        }

        function updateModeNoteList() {
            /* ... Uses NoteInputManager getters ... */
            let notesToArp = NoteInputManager.getHeldNotes();
            let rawNotes = NoteInputManager.getRawHeldNotes();
            if (!arraysAreEqual(rawNotes, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                if (arpMode === 'stableShuffled' && arpRunning) stableShuffleIndex = 0;
            }
            switch (arpMode) {
                case 'up':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                case 'down':
                    currentModeNoteList = generateDownNoteList(notesToArp);
                    break;
                case 'upDown':
                    currentModeNoteList = generateUpDownNoteList(notesToArp);
                    break;
                case 'upDownInclusive':
                    currentModeNoteList = generateUpDownInclusiveNoteList(notesToArp);
                    break;
                case 'converge':
                    currentModeNoteList = generateConvergeNoteList(notesToArp);
                    break;
                case 'diverge':
                    currentModeNoteList = generateDivergeNoteList(notesToArp);
                    break;
                case 'convergeDiverge':
                    currentModeNoteList = generateConvergeDivergeNoteList(notesToArp);
                    break;
                case 'convergeDivergeInclusive':
                    currentModeNoteList = generateConvergeDivergeInclusiveNoteList(notesToArp);
                    break;
                case 'played':
                    currentModeNoteList = generatePlayedNoteList(notesToArp);
                    break;
                case 'random':
                    currentModeNoteList = [];
                    break;
                case 'shuffled':
                    if (!arpRunning || !arraysAreEqual(rawNotes, lastNotesToArp)) shuffledNotesOrder = generateShuffledNoteList(notesToArp);
                    currentModeNoteList = shuffledNotesOrder;
                    break;
                case 'stableShuffled':
                    currentModeNoteList = stableShuffledOrder;
                    break;
                case 'chord':
                    currentModeNoteList = generateChordNoteList(notesToArp);
                    break;
                case 'chordN':
                    const o = document.getElementById('chordNOrdering').value;
                    currentModeNoteList = generateChordNNoteList(notesToArp, chordNValue, o);
                    break;
                case 'walk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                case 'normalWalk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                default:
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
            }
            return currentModeNoteList;
        }

        function findClosestNoteIndex(noteToFind, oldNoteList, newNoteList, previousIndex) {
            /* ... unchanged ... */
            if (!newNoteList || newNoteList.length === 0) return 0;
            if (arpMode === 'chordN' || arpMode === 'chord') {
                const oL = oldNoteList?.length || 1;
                const nL = newNoteList.length;
                return Math.floor((previousIndex / oL) * nL) % nL || 0;
            }
            for (let i = 0; i < newNoteList.length; i++) {
                const cI = (previousIndex + i) % newNoteList.length;
                if (newNoteList[cI] === noteToFind) return cI;
            }
            const f = newNoteList.indexOf(noteToFind);
            if (f !== -1) return f;
            const oLf = oldNoteList?.length || 1;
            const nLf = newNoteList.length;
            return Math.floor((previousIndex / oLf) * nLf) % nLf || 0;
        }

        function advanceRhythmIndex(steps = 1) {
            /* ... unchanged ... */
            let len = RhythmManager.getRhythmLength();
            if (len > 0) currentRhythmIndex = (currentRhythmIndex + steps) % len;
            else currentRhythmIndex = 0;
        }

        function resetRhythmIndex() {
            /* ... unchanged ... */
            currentRhythmIndex = 0;
        }

        function advancePatternIndex(steps = 1) {
            /* ... unchanged ... */
            let len = RhythmManager.getPatternLength();
            if (len > 0) currentPatternIndex = (currentPatternIndex + steps) % len;
            else currentPatternIndex = 0;
        }

        function resetPatternIndex() {
            /* ... unchanged ... */
            currentPatternIndex = 0;
        }

        function calculateGateDuration(stepDurationMs, gateLengthPercent, gateMultiplier = 1) {
            /* ... unchanged ... */
            if (stepDurationMs <= 0 || gateLengthPercent <= 0) return 5;
            const base = (stepDurationMs * gateLengthPercent) / 100;
            return Math.max(5, base * gateMultiplier);
        }

        function startArpeggiator() {
            /* ... unchanged ... */
            if (arpRunning) return;
            updateModeNoteList();
            if (arpMode === 'shuffled') {
                shuffledNotesOrder = generateShuffledNoteList(NoteInputManager.getHeldNotes());
                currentModeNoteList = shuffledNotesOrder;
            }
            arpRunning = true;
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.classList.add('playing');
            stopButton.classList.remove('playing'); /* RhythmManager.initialize(); Re-init rhythms? Or just reset indices? */
            resetRhythmIndex();
            resetPatternIndex();
            currentNoteIndex = 0;
            stableShuffleIndex = 0;
            if ((arpMode === 'walk' || arpMode === 'normalWalk') && currentModeNoteList && currentModeNoteList.length > 0) currentNoteIndex = Math.floor(currentModeNoteList.length / 2);
            playbackDisplayElem.innerHTML = '';
            ActiveNoteManager.allNotesOff();
            ClockManager.start();
        }

        function stopArpeggiator() {
            /* ... unchanged ... */
            if (!arpRunning) return;
            arpRunning = false;
            ClockManager.stop();
            startButton.disabled = false;
            stopButton.disabled = true;
            stopButton.classList.add('playing');
            startButton.classList.remove('playing');
            ActiveNoteManager.allNotesOff();
            unhighlightCurrentStep();
            unhighlightPlaybackPianoKeys();
        }

        /** Handles incoming MIDI - Uses ClockManager */
        function onMIDIMessage(message) {
            /* ... unchanged ... */
            const cmd = message.data[0];
            if (cmd === 0xF8) {
                ClockManager.externalTick();
                return;
            }
            if (cmd === 0xFA) {
                if (arpSyncMode === 'transport') {
                    resetRhythmIndex();
                    resetPatternIndex();
                    currentNoteIndex = 0;
                    stableShuffleIndex = 0;
                    ClockManager.start();
                    if (!arpRunning) startArpeggiator();
                }
                return;
            }
            if (cmd === 0xFC) {
                if (arpSyncMode === 'transport') {
                    if (arpRunning) stopArpeggiator();
                }
                return;
            }
            if (cmd === 0xFB) {
                if (arpSyncMode === 'transport') {
                    if (!arpRunning) startArpeggiator();
                }
                return;
            }
            const hi = (cmd & 0xF0) >> 4;
            const lo = cmd & 0x0F;
            const b1 = message.data.length > 1 ? message.data[1] : 0;
            const b2 = message.data.length > 2 ? message.data[2] : 0;
            let proc = false;
            let iCh = lo;
            const mCfg = MidiManager.getMPEInputConfig();
            const bOutCh = MidiManager.getOutputChannel();
            if (mCfg.isEnabled) {
                const g = mCfg.globalChannel;
                const v = mCfg.voiceChannelCount;
                if (g === 'omni') proc = true;
                else {
                    const gN = parseInt(g);
                    if (!isNaN(gN)) {
                        const bG = (gN - 1);
                        if (iCh === bG || (iCh > bG && iCh <= bG + v)) proc = true;
                    }
                }
            } else {
                if (iCh === bOutCh) proc = true;
            }
            if (proc) {
                if (hi === 0x9) {
                    const n = b1;
                    const vl = b2;
                    if (vl > 0) NoteInputManager.handleNoteOn(n, 'midi', iCh);
                    else NoteInputManager.handleNoteOff(n, 'midi', iCh);
                } else if (hi === 0x8) {
                    const n = b1;
                    NoteInputManager.handleNoteOff(n, 'midi', iCh);
                } else if (hi === 0xA) {
                    const n = b1;
                    const p = b2;
                    NoteInputManager.handlePressureUpdate(n, p, true);
                } else if (hi === 0xB) {
                    const cc = b1;
                    const v = b2;
                    if (cc === 64) NoteInputManager.handleSustain(v >= 64);
                    else if (mCfg.isEnabled && cc === 74) {
                        const cN = NoteInputManager.getMPEChannelNote(iCh);
                        if (cN !== null) NoteInputManager.handleMPEYAxisUpdate(cN, v);
                    }
                } else if (hi === 0xD) {
                    const p = b1;
                    if (mCfg.isEnabled) {
                        const cN = NoteInputManager.getMPEChannelNote(iCh);
                        if (cN !== null) NoteInputManager.handlePressureUpdate(cN, p, false);
                    } else {
                        if (iCh === bOutCh) {
                            NoteInputManager.getRawHeldNotes().forEach(rN => {
                                if (NoteInputManager.hasHeldMIDINote(rN)) NoteInputManager.handlePressureUpdate(rN, p, false);
                            });
                        }
                    }
                }
            }
        }

        /** Executes Arp Step - Uses RhythmManager getters */
        function arpStep() {
            if (!arpRunning) return;
            unhighlightCurrentStep();

            // Update time held (uses ActiveNoteManager) - unchanged
            let notesToStop = [];
            ActiveNoteManager.getActiveNotesMap().forEach((s, n) => {
                if (s.isExtended && s.noteOffTimeoutId === null) {
                    const nT = s.timeHeldDivisions + 1;
                    ActiveNoteManager.updateNoteState(n, {
                        timeHeldDivisions: nT
                    });
                    if (nT >= maxTimeExtensionDivisions) notesToStop.push(n);
                } else if (!s.isExtended) {
                    if (s.timeHeldDivisions !== 0 || s.chordsHeldCount !== 0) ActiveNoteManager.updateNoteState(n, {
                        timeHeldDivisions: 0,
                        chordsHeldCount: 0
                    });
                }
            });
            notesToStop.forEach(n => {
                const s = ActiveNoteManager.getActiveNotesMap().get(n);
                if (s) {
                    ActiveNoteManager.updateNoteState(n, {
                        isExtended: false
                    });
                    ActiveNoteManager.stopNote(n, s.outputChannel);
                }
            });

            // Determine notes (uses NoteInputManager) - unchanged
            let notesToArp = NoteInputManager.getHeldNotes();
            if (arpSyncMode === 'free' && notesToArp.length === 0) {
                advanceRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null);
                highlightCurrentStep('rest', null);
                return;
            }
            if (notesToArp.length === 0 && arpSyncMode !== 'free') {
                stopArpeggiator();
                return;
            }

            // --- *** Refactor: Rhythm/Pattern logic uses RhythmManager getters *** ---
            let noteForStep = '';
            let chordForStep = null;
            let stepType = null;
            let advanceNoteIndices = true;

            const currentRhythmEvent = RhythmManager.getRhythmEvent(currentRhythmIndex); // Use getter
            const patternEventActive = RhythmManager.isPatternActive(); // Use getter
            const rhythmEventActive = RhythmManager.isRhythmActive(); // Use getter

            let effectiveRhythmEvent = rhythmEventActive ? currentRhythmEvent : RhythmManager.RHYTHM_BEAT; // Use constant

            if (effectiveRhythmEvent === RhythmManager.RHYTHM_BEAT) {
                let patternProcessed = false;
                let patternIterations = 0;
                const maxPatternIterations = (RhythmManager.getPatternLength() || 1) * 2; // Use getter

                while (!patternProcessed && patternIterations < maxPatternIterations) {
                    const currentPatternEvent = RhythmManager.getPatternEvent(currentPatternIndex); // Use getter
                    const effectivePatternEvent = patternEventActive ? currentPatternEvent : RhythmManager.PATTERN_NOTE; // Use constant

                    if (effectivePatternEvent === RhythmManager.PATTERN_NOTE) {
                        // Note selection logic remains the same
                        chordForStep = null;
                        noteForStep = '';
                        if (arpMode === 'chord' || arpMode === 'chordN') {
                            /*..*/
                            if (currentModeNoteList && currentModeNoteList.length > 0) {
                                const i = currentNoteIndex % currentModeNoteList.length;
                                chordForStep = currentModeNoteList[i];
                                if (chordForStep && chordForStep.length > 0) {
                                    playNotes(chordForStep, subArpMode);
                                    stepType = 'note';
                                    highlightCurrentStep('note', chordForStep, true);
                                } else {
                                    stepType = 'rest';
                                    highlightCurrentStep('rest', null);
                                    advanceNoteIndices = false;
                                }
                            } else {
                                stepType = 'rest';
                                highlightCurrentStep('rest', null);
                                advanceNoteIndices = false;
                            }
                        } else if (arpMode === 'random') {
                            if (notesToArp.length > 0) noteForStep = notesToArp[Math.floor(Math.random() * notesToArp.length)];
                            else advanceNoteIndices = false;
                        } else if (arpMode === 'walk' || arpMode === 'normalWalk') {
                            if (currentModeNoteList && currentModeNoteList.length > 0) noteForStep = currentModeNoteList[currentNoteIndex % currentModeNoteList.length];
                            else advanceNoteIndices = false;
                        } else {
                            if (currentModeNoteList && currentModeNoteList.length > 0) noteForStep = currentModeNoteList[currentNoteIndex % currentModeNoteList.length];
                            else advanceNoteIndices = false;
                        }
                        // Play note logic remains the same
                        if (noteForStep !== '' && arpMode !== 'chord' && arpMode !== 'chordN') {
                            playNotes(noteForStep);
                            stepType = 'note';
                            highlightCurrentStep('note', noteForStep);
                        } else if (stepType !== 'note' && stepType !== 'rest') {
                            stepType = 'rest';
                            highlightCurrentStep('rest', null);
                            advanceNoteIndices = false;
                        }
                        patternProcessed = true;
                        advancePatternIndex();
                    } else if (effectivePatternEvent === RhythmManager.PATTERN_SKIP) {
                        // Skip logic remains the same
                        advancePatternIndex();
                        if (arpMode !== 'random' && arpMode !== 'walk' && arpMode !== 'normalWalk') {
                            currentNoteIndex++;
                            if (arpMode === 'stableShuffled') stableShuffleIndex++;
                        }
                        stepType = 'skip';
                        patternIterations++;
                    } else {
                        console.error("Unknown pattern event:", currentPatternEvent);
                        stepType = 'error';
                        patternProcessed = true;
                        advancePatternIndex();
                        advanceNoteIndices = false;
                    }
                    if (patternIterations >= maxPatternIterations && !patternProcessed) {
                        console.warn("Pattern loop limit");
                        stepType = 'rest';
                        advanceNoteIndices = false;
                        patternProcessed = true;
                    }
                } // End while
            } else if (effectiveRhythmEvent === RhythmManager.RHYTHM_REST) {
                stepType = 'rest';
                highlightCurrentStep('rest', null);
                advanceNoteIndices = false;
            } else {
                console.error("Unknown rhythm event:", currentRhythmEvent);
                stepType = 'error_arp_rhythm';
                highlightCurrentStep('error', null);
                advanceNoteIndices = false;
            }
            // --- End Rhythm/Pattern logic refactor ---

            // Update Playback Display (unchanged)
            if (stepType !== null) {
                let nD = null;
                let iC = (stepType === 'note' && !!chordForStep);
                if (stepType === 'note' && !iC) nD = noteForStep;
                updatePlaybackDisplay(stepType, nD, iC);
            }

            // Advance Indices (unchanged)
            advanceRhythmIndex();
            if (advanceNoteIndices) {
                if (arpMode === 'walk') advanceWalkIndex();
                else if (arpMode === 'normalWalk') advanceNormalWalkIndex();
                else if (arpMode === 'stableShuffled') {
                    stableShuffleIndex++;
                    if (stableShuffledOrder && stableShuffledOrder.length > 0) stableShuffleIndex %= stableShuffledOrder.length;
                    else stableShuffleIndex = 0;
                } else if (arpMode !== 'random') {
                    currentNoteIndex++;
                    if (currentModeNoteList && currentModeNoteList.length > 0) currentNoteIndex %= currentModeNoteList.length;
                    else currentNoteIndex = 0;
                }
            }
        }


        function calculateVelocity(pressure) {
            /* ... unchanged ... */
            pressure = Math.max(0, Math.min(127, pressure || 0));
            let v = baseVelocityValue + (maxVelocityValue - baseVelocityValue) * (pressure / 127);
            return Math.max(1, Math.min(127, Math.round(v)));
        }

        function findNextPlayedChordInfo(maxLookahead = LOOKAHEAD_MAX_STEPS) {
            /* ... unchanged, uses RhythmManager getters ... */
            // Need to use RhythmManager getters inside the loop simulation
            if (arpMode !== 'chordN' || !currentModeNoteList || currentModeNoteList.length === 0) return {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: 0
            };
            let simR = currentRhythmIndex;
            let simP = currentPatternIndex;
            let simC = currentNoteIndex;
            let st = 0;
            for (let i = 0; i < maxLookahead; i++) {
                st++;
                simR = (simR + 1) % (RhythmManager.getRhythmLength() || 1); // Use getter for length
                const rE = RhythmManager.isRhythmActive() ? RhythmManager.getRhythmEvent(simR) : RhythmManager.RHYTHM_BEAT; // Use getters

                if (rE === RhythmManager.RHYTHM_BEAT) {
                    simP = (simP + 1) % (RhythmManager.getPatternLength() || 1); // Use getter for length
                    const pE = RhythmManager.isPatternActive() ? RhythmManager.getPatternEvent(simP) : RhythmManager.PATTERN_NOTE; // Use getters

                    if (pE === RhythmManager.PATTERN_NOTE) {
                        simC = (simC + 1) % currentModeNoteList.length;
                        return {
                            nextChordIndex: simC,
                            nextChordNotes: currentModeNoteList[simC],
                            stepsToNextChord: st
                        };
                    } else if (pE === RhythmManager.PATTERN_SKIP) {
                        simC = (simC + 1) % currentModeNoteList.length;
                    }
                }
            }
            return {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: st
            }; // Lookahead failed
        }

        /** Plays notes - Uses ClockManager & RhythmManager */
        function playNotes(notesOrChord, subArpModeOverride = subArpMode) {
            const outputChannel = MidiManager.getOutputChannel();
            const notesArray = Array.isArray(notesOrChord) ? notesOrChord : [notesOrChord];
            if (notesArray.length === 0) return;

            const isChordModeActive = arpMode === 'chord' || arpMode === 'chordN';
            const useSubArp = isChordModeActive && notesArray.length > 1 && subArpScalePercentage > 0;
            let nextPlayedInfo = {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: 0
            };
            if (arpMode === 'chordN') nextPlayedInfo = findNextPlayedChordInfo(); // Uses RhythmManager getters internally

            // *** Refactor: Use RhythmManager getter ***
            const useGateFlex = RhythmManager.isGateFlexEnabled();
            const currentGateMultiplier = useGateFlex ?
                (RhythmManager.getRhythmGateMultiplier(currentRhythmIndex) || 1) :
                1;

            const stepDurationMs = ClockManager.getClockDivisionDurationMs();

            if (useSubArp) {
                /* ... sub arp logic unchanged, uses ActiveNoteManager ... */
                const subDur = (stepDurationMs * subArpScalePercentage) / 100;
                const spacing = notesArray.length > 1 ? subDur / notesArray.length : 0;
                let subN = [...notesArray];
                switch (subArpModeOverride) {
                    case 'up':
                        subN.sort((a, b) => a - b);
                        break;
                    case 'down':
                        subN.sort((a, b) => b - a);
                        break;
                    case 'random':
                        subN.sort(() => Math.random() - 0.5);
                        break;
                    case 'converge':
                        subN = generateConvergeNoteList(subN);
                        break;
                    case 'diverge':
                        subN = generateDivergeNoteList(subN);
                        break;
                    default:
                        subN.sort((a, b) => a - b);
                        break;
                }
                subN.forEach((eN, idx) => {
                    const oN = NoteInputManager.findOriginalNote(eN);
                    if (oN === null) return;
                    const pr = NoteInputManager.getNotePressure(oN);
                    const vl = calculateVelocity(pr);
                    const d = spacing * idx;
                    setTimeout(() => {
                        const act = ActiveNoteManager.hasNote(eN);
                        const st = act ? ActiveNoteManager.getActiveNotesMap().get(eN) : null;
                        const ext = act && st && st.isExtended;
                        if (!ext) {
                            ActiveNoteManager.startNote(eN, vl, outputChannel);
                            const sGD = calculateGateDuration(spacing > 0 ? spacing : stepDurationMs, gateLengthPercentage, 1);
                            ActiveNoteManager.scheduleNoteOff(eN, sGD, outputChannel);
                        }
                    }, d);
                });
            } else {
                /* ... simultaneous play logic unchanged, uses ActiveNoteManager & NoteInputManager ... */
                notesArray.forEach(eN => {
                    const oN = NoteInputManager.findOriginalNote(eN);
                    if (oN === null) return;
                    const pr = NoteInputManager.getNotePressure(oN);
                    const vl = calculateVelocity(pr);
                    const act = ActiveNoteManager.hasNote(eN);
                    const st = act ? ActiveNoteManager.getActiveNotesMap().get(eN) : null;
                    const isInNxt = (arpMode === 'chordN' && nextPlayedInfo.nextChordNotes?.includes(eN));
                    if (act && st) {
                        ActiveNoteManager.cancelNoteOff(eN);
                        const ccc = st.chordsHeldCount < (maxChordExtension - 1);
                        const et = st.timeHeldDivisions + nextPlayedInfo.stepsToNextChord;
                        const cct = et <= maxTimeExtensionDivisions;
                        const ce = arpMode === 'chordN' && isInNxt && ccc && cct;
                        if (ce) ActiveNoteManager.updateNoteState(eN, {
                            isExtended: true,
                            chordsHeldCount: st.chordsHeldCount + 1,
                            noteOffTimeoutId: null
                        });
                        else {
                            ActiveNoteManager.updateNoteState(eN, {
                                isExtended: false,
                                chordsHeldCount: 0
                            });
                            const gD = calculateGateDuration(stepDurationMs, gateLengthPercentage, currentGateMultiplier);
                            ActiveNoteManager.scheduleNoteOff(eN, gD, outputChannel);
                        }
                    } else {
                        const cse = maxChordExtension > 1;
                        const cst = nextPlayedInfo.stepsToNextChord <= maxTimeExtensionDivisions;
                        const se = arpMode === 'chordN' && isInNxt && cse && cst;
                        ActiveNoteManager.startNote(eN, vl, outputChannel);
                        const nS = ActiveNoteManager.getActiveNotesMap().get(eN);
                        if (se && nS) ActiveNoteManager.updateNoteState(eN, {
                            isExtended: true,
                            chordsHeldCount: 1,
                            timeHeldDivisions: 0,
                            noteOffTimeoutId: null
                        });
                        else if (nS) {
                            const gD = calculateGateDuration(stepDurationMs, gateLengthPercentage, currentGateMultiplier);
                            ActiveNoteManager.scheduleNoteOff(eN, gD, outputChannel);
                        }
                    }
                });
            }
        }


        function updatePlaybackDisplay(stepType, note, isChord = false) {
            /* ... unchanged ... */
            if (stepType === null) return;
            const el = document.createElement('div');
            el.classList.add('playback-step');
            el.classList.add(stepType);
            if (stepType === 'note') {
                if (isChord) {
                    if (arpMode === 'chordN' && currentModeNoteList && currentModeNoteList.length > 0) {
                        const dI = (currentNoteIndex % currentModeNoteList.length) + 1;
                        el.textContent = `Ch${dI}`;
                    } else {
                        el.textContent = 'Ch';
                    }
                } else if (note !== null) {
                    el.textContent = midiNoteToName(note);
                } else {
                    el.textContent = '?';
                }
            } else if (stepType === 'rest') {
                el.textContent = 'R';
            } else if (stepType === 'skip') {
                el.textContent = 'S';
            } else if (stepType === 'error') {
                el.textContent = '!';
            }
            playbackDisplayElem.appendChild(el);
            while (playbackDisplayElem.children.length > maxPlaybackSteps) playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        function generatePianoKeyboardUI() {
            /* ... unchanged ... */
            const pk = document.getElementById('pianoKeyboard');
            pk.innerHTML = '';
            const sN = 48;
            const nK = 25;
            for (let i = 0; i < nK; i++) {
                const nV = sN + i;
                if (nV > 127) break;
                const nN = notes[nV % 12];
                const k = document.createElement('div');
                k.classList.add('key');
                k.dataset.note = nV;
                k.title = midiNoteToName(nV);
                k.id = `pianoKey-${nV}`;
                if (nN.includes('#')) k.classList.add('black-key');
                else k.classList.add('white-key');
                k.addEventListener('click', function() {
                    NoteInputManager.handleNoteOn(nV, 'ui');
                });
                pk.appendChild(k);
            }
        }

        function updatePianoKeyboardUI(note, source) {
            /* ... unchanged ... */
            const k = document.getElementById(`pianoKey-${note}`);
            if (!k) return;
            k.classList.remove('key-held-ui', 'key-held-midi', 'key-current');
            if (source === 'ui' && NoteInputManager.getRawHeldNotes().includes(note)) k.classList.add('key-held-ui');
            else if (source === 'midi' && NoteInputManager.getRawHeldNotes().includes(note)) k.classList.add('key-held-midi');
        }

        function highlightPianoKeys(notesToHighlight) {
            /* ... unchanged ... */
            unhighlightPianoKeys();
            if (!notesToHighlight) return;
            const a = Array.isArray(notesToHighlight) ? notesToHighlight : [notesToHighlight];
            if (a.length > 0) {
                a.forEach(n => {
                    const k = document.getElementById(`pianoKey-${n}`);
                    if (k) k.classList.add('key-current');
                });
                highlightedPianoKey = a[0];
            }
        }

        function unhighlightPianoKeys() {
            /* ... unchanged ... */
            const c = document.querySelectorAll('#pianoKeyboard .key.key-current');
            c.forEach(k => k.classList.remove('key-current'));
            highlightedPianoKey = null;
        }

        function highlightRhythmStep(displayElementId, stepIndex, gateExtension = 0) {
            /* ... unchanged ... */
            unhighlightRhythmStep(displayElementId);
            const rL = (displayElementId === 'patternDisplay' ? RhythmManager.getPatternLength() : RhythmManager.getRhythmLength()) || 0;
            if (rL === 0) return;
            const idx = stepIndex % rL;
            const el = document.getElementById(`${displayElementId}-step-${idx}`);
            if (el) {
                el.classList.add('current-step');
                if (RhythmManager.isGateFlexEnabled() && displayElementId === 'rhythmDisplay' && gateExtension > 1) {
                    for (let i = 1; i < gateExtension; i++) {
                        const eI = (idx + i) % rL;
                        const eE = document.getElementById(`${displayElementId}-step-${eI}`);
                        if (eE) eE.classList.add('gate-extended-step');
                    }
                }
            }
        }

        function unhighlightRhythmStep(displayElementId) {
            /* ... unchanged ... */
            const c = document.querySelector(`#${displayElementId} .current-step`);
            if (c) c.classList.remove('current-step');
            if (displayElementId === 'rhythmDisplay') {
                const e = document.querySelectorAll('#rhythmDisplay .rhythm-step.gate-extended-step');
                e.forEach(s => s.classList.remove('gate-extended-step'));
            }
        }

        function highlightCurrentPatternStep() {
            /* ... uses RhythmManager getter ... */
            if (RhythmManager.isPatternActive() && RhythmManager.getPatternLength() > 0) highlightRhythmStep('patternDisplay', currentPatternIndex % RhythmManager.getPatternLength());
            else unhighlightRhythmStep('patternDisplay');
        }

        function highlightCurrentArpRhythmStep() {
            /* ... uses RhythmManager getters ... */
            if (RhythmManager.isRhythmActive() && RhythmManager.getRhythmLength() > 0) {
                const idx = currentRhythmIndex % RhythmManager.getRhythmLength();
                const ext = RhythmManager.isGateFlexEnabled() ? (RhythmManager.getRhythmGateMultiplier(idx) || 0) : 0;
                highlightRhythmStep('rhythmDisplay', idx, ext);
            } else unhighlightRhythmStep('rhythmDisplay');
        }

        function unhighlightCurrentStep() {
            /* ... unchanged ... */
            unhighlightRhythmStep('patternDisplay');
            unhighlightRhythmStep('rhythmDisplay');
            unhighlightPianoKeys();
        }

        function highlightCurrentStep(stepType, noteOrChord, isChord = false) {
            /* ... unchanged ... */
            unhighlightPianoKeys();
            highlightCurrentArpRhythmStep();
            highlightCurrentPatternStep();
            if (stepType === 'note') {
                if (isChord && noteOrChord) highlightPianoKeys(noteOrChord);
                else if (!isChord && noteOrChord !== null) highlightPianoKeys(noteOrChord);
            }
        }

        function generatePlaybackPianoKeyboardUI() {
            /* ... unchanged ... */
            const pk = document.getElementById('playbackKeyboardDisplay');
            pk.innerHTML = '';
            const sN = 36;
            const nK = 61;
            for (let i = 0; i < nK; i++) {
                const nV = sN + i;
                if (nV > 127) break;
                const nN = notes[nV % 12];
                const k = document.createElement('div');
                k.classList.add('playback-key');
                k.dataset.note = nV;
                k.id = `playbackKey-${nV}`;
                if (nN && nN.includes('#')) k.classList.add('playback-black-key');
                else k.classList.add('playback-white-key');
                pk.appendChild(k);
            }
        }

        function updatePlaybackKeyboardUI() {
            /* ... unchanged ... */
            const keys = document.querySelectorAll('.playback-key');
            keys.forEach(k => updatePlaybackKeyboardKey(parseInt(k.dataset.note)));
        }

        function updatePlaybackKeyboardKey(note) {
            /* ... unchanged ... */
            const k = document.getElementById(`playbackKey-${note}`);
            if (!k) return;
            const raw = NoteInputManager.getRawHeldNotes();
            const heldE = NoteInputManager.getHeldNotes();
            const hUI = NoteInputManager.hasHeldUINote(note);
            const hMIDI = NoteInputManager.hasHeldMIDINote(note);
            const hOct = heldE.includes(note) && !raw.includes(note);
            const actA = ActiveNoteManager.hasNote(note);
            const stA = actA ? ActiveNoteManager.getActiveNotesMap().get(note) : null;
            const gExt = actA && stA && stA.isExtended;
            k.classList.remove('key-held-ui', 'key-held-midi', 'key-held-octave-expanded', 'key-current', 'key-gate-extended');
            if (gExt) k.classList.add('key-gate-extended');
            else if (actA) k.classList.add('key-current');
            else if (hUI) k.classList.add('key-held-ui');
            else if (hMIDI) k.classList.add('key-held-midi');
            else if (hOct) k.classList.add('key-held-octave-expanded');
        }

        function unhighlightPlaybackPianoKeys() {
            /* ... unchanged ... */
            const c = document.querySelectorAll('#playbackKeyboardDisplay .playback-key.key-current, #playbackKeyboardDisplay .playback-key.key-gate-extended');
            c.forEach(k => {
                k.classList.remove('key-current', 'key-gate-extended');
                updatePlaybackKeyboardKey(parseInt(k.dataset.note));
            });
        }

        function unhighlightPlaybackPianoKeysAll() {
            updatePlaybackKeyboardUI();
        }

        // --- WALK MODE FUNCTIONS (unchanged) ---
        function advanceWalkIndex() {
            /*..*/
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const p = calculateWalkProbabilities(walkSkew);
                const r = Math.random();
                if (r < p.prev) currentNoteIndex = (currentNoteIndex - 1 + currentModeNoteList.length) % currentModeNoteList.length;
                else if (r >= p.prev + p.current) currentNoteIndex = (currentNoteIndex + 1) % currentModeNoteList.length;
            }
        }

        function calculateWalkProbabilities(s) {
            /*..*/
            s = Math.max(-1, Math.min(1, s));
            let pn, pc, pv;
            pv = Math.max(0, (1 / 3) * (1 - s));
            pn = Math.max(0, (1 / 3) * (1 + s));
            pc = Math.max(0, 1 - pv - pn);
            const t = pv + pc + pn;
            if (t > 0) {
                pv /= t;
                pc /= t;
                pn /= t;
            } else {
                pv = 1 / 3;
                pc = 1 / 3;
                pn = 1 / 3;
            }
            return {
                next: pn,
                current: pc,
                prev: pv
            };
        }

        function advanceNormalWalkIndex() {
            /*..*/
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const sig = 0.3 + walkDistance * 2;
                const mu = walkSkew * (currentModeNoteList.length / 4);
                const step = sampleNormalDistribution(mu, sig);
                const maxS = Math.ceil(currentModeNoteList.length / 2);
                const clampS = Math.max(-maxS, Math.min(maxS, Math.round(step)));
                currentNoteIndex = (currentNoteIndex + clampS + currentModeNoteList.length) % currentModeNoteList.length;
            }
        }

        function sampleNormalDistribution(m, s) {
            /*..*/
            let u1 = 0,
                u2 = 0;
            while (u1 === 0) u1 = Math.random();
            while (u2 === 0) u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * s + m;
        }

        // --- Initialization ---
        generatePianoKeyboardUI();
        generatePlaybackPianoKeyboardUI();
        // updateRhythmDisplays removed (done in RhythmManager init)
        // UI updates (unchanged)
        document.getElementById('chordNValueDisplay').textContent = chordNValue;
        document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        // updatePatternControlsState / updateRhythmControlsState removed (done in RhythmManager init/updates)

        // Initialize Managers
        ActiveNoteManager.initialize({
            updatePlaybackKeyCallback: updatePlaybackKeyboardKey,
            getMPEOutputMode: MidiManager.isMPEOutput
        });
        NoteInputManager.initialize({
            onNotesChanged: handleNotesChanged,
            getMPEInputConfig: MidiManager.getMPEInputConfig,
            updatePianoKeyCallback: updatePianoKeyboardUI,
            updatePlaybackKeyboardCallback: updatePlaybackKeyboardUI
        });
        ClockManager.initialize({
            initialTempoSource: document.getElementById('tempoSource').value,
            initialBPM: parseInt(document.getElementById('tempoBPM').value),
            initialClockDivision: document.getElementById('clockDivision').value,
            onArpStep: arpStep,
            onTempoUpdate: updateTempoDisplay
        });
        // *** Refactor: Initialize RhythmManager ***
        RhythmManager.initialize({
            initialPatternSteps: parseInt(document.getElementById('patternSteps').value),
            initialPatternBeats: parseInt(document.getElementById('patternBeats').value),
            initialPatternOffset: parseInt(document.getElementById('patternOffset').value),
            initialIsPatternDisabled: !document.getElementById('enablePattern').checked,
            initialRhythmSteps: parseInt(document.getElementById('rhythmSteps').value),
            initialRhythmBeats: parseInt(document.getElementById('rhythmBeats').value),
            initialRhythmOffset: parseInt(document.getElementById('rhythmOffset').value),
            initialIsRhythmDisabled: !document.getElementById('enableRhythm').checked,
            initialIsGateFlexEnabled: document.getElementById('enableGateFlex').checked,
            // Pass UI update functions
            onPatternDisplayUpdate: (rhythmArr, isDisabled) => displayRhythm(rhythmArr, 'patternDisplay', isDisabled),
            onRhythmDisplayUpdate: (rhythmArr, isDisabled) => displayRhythm(rhythmArr, 'rhythmDisplay', isDisabled),
            onPatternControlsUpdate: updatePatternControlsState,
            onRhythmControlsUpdate: updateRhythmControlsState
        });
        MidiManager.initialize(midiManagerCallbacks); // Start MIDI (must be after other inits if they need MIDI state)

        // Trigger initial update based on default state
        handleNotesChanged(NoteInputManager.getHeldNotes(), NoteInputManager.getRawHeldNotes(), NoteInputManager.getPlayedNoteOrderFiltered());
        lastNotesToArp = NoteInputManager.getRawHeldNotes();
    </script>
</body>
</html>
