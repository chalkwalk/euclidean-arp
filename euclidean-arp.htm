<html>
<head>
    <title>MPE Euclidean Arpeggiator</title>
    <style>
        /* Styles remain the same */
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step {
            width: 25px; /* Slightly wider steps for better visual clarity */
            height: 25px; /* Slightly taller steps for better visual clarity */
            border: 1px solid #ccc; /* Reduced border weight */
            text-align: center;
            line-height: 25px; /* Match line-height to height */
            font-size: 12px;
            margin-right: 2px; /* Add spacing between steps */
            border-radius: 3px; /* Slightly rounded corners for a softer look */
            background-color: #f0f0f0; /* Default step background color */
            color: #333; /* Darker text for better contrast */
        }
        .rhythm-step.beat { background-color: #b2f0b2; border-color: #8fcc8f; color: #005000; /* Muted green for beats */ }
        .rhythm-step.rest { background-color: #f0b2b2; border-color: #cc8f8f; color: #500000; /* Muted red for rests */ }
        .rhythm-step.skip { background-color: #b2b2f0; border-color: #8f8fcc; color: #000050; /* Muted blue for skips */ }
        .rhythm-step.note { background-color: #f0f0b2; border-color: #ccf08f; color: #505000; /* Muted yellow for notes */ }
        .rhythm-step.current-step { border: 2px solid blue; /* Stronger current step highlight */ }
        .rhythm-step.disabled-step {
            background-color: #e0e0e0; /* Greyed out background */
            border-color: #bbb;       /* Lighter border */
            color: #999;              /* Lighter text color */
        }
        .rhythm-step.gate-extended-step {
            background-color: #cceeff; /* Light blue for gate extension */
            border-color: #aaccdd;
        }


        .parameter-group { margin-bottom: 10px; border: 1px solid #ccc; padding: 10px; border-radius: 5px; /* Added border and padding to parameter groups */ background-color: #fafafa; /* Lighter background for parameter groups */ }
        .parameter-group h3 { margin-top: 0; color: #555; /* Slightly darker heading text */ }
        .note-selector { margin-bottom: 10px; }
        .piano-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; /* Added border to keyboard */ }
        .key {
            height: 80px;
            border-left: 1px solid #ddd; /* Lighter key borders */
            border-bottom: 1px solid #bbb; /* Slightly darker bottom border for depth */
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            user-select: none; /* Prevent text selection on click */
            transition: background-color 0.1s ease; /* Smooth background color transition */
        }
        .white-key {
            width: 30px;
            background-color: white;
            color: black;
        }
        .black-key {
            width: 20px;
            background-color: black;
            color: white;
            height: 55px;
            margin-left: -10px;
            margin-right: -10px;
            z-index: 1; /* Ensure black keys are on top */
            border-bottom: 1px solid #333; /* Darker bottom border for black keys */
        }
        .key.key-held-ui {
            background-color: #aaddff; /* Distinct light blue for UI held keys */
            color: black; /* Ensure text is readable on highlight */
            border-bottom: unset;
        }
        .key.key-held-midi {
            background-color: #aaffaa; /* Distinct light green for MIDI held keys */
            color: black; /* Ensure text is readable on highlight */
            border-bottom: unset;
        }
        .key.key-current {
            border: 2px solid #ccc; /* Example highlight style */
            background-color: #ffddaa; /* Softer yellow for current note highlight */
            border-bottom: unset;
        }

        .playback-keyboard-container { display: flex; justify-content: center; margin-bottom: 10px; } /* Center the playback keyboard */
        .playback-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; width: 600px; height: 40px; /* Fixed width and height for mini keyboard */ }
        .playback-key {
            height: 100%; /* Keys fill the height of the playback keyboard */
            border-left: 1px solid #ddd;
            border-bottom: 1px solid #bbb;
            box-sizing: border-box;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 2px; /* Reduced padding */
            font-size: 8px; /* Smaller font size */
            user-select: none;
            transition: background-color 0.1s ease;
            cursor: default; /* Non-interactive cursor */
        }
        .playback-white-key {
            width: calc(600px / 25 * 3/5); /* Adjust width based on total width and number of keys */
            background-color: white;
            color: black;
        }
        .playback-black-key {
            width: calc(600px / 25 * 2/5); /* Adjust width based on total width and number of keys */
            background-color: black;
            color: white;
            height: 70%; /* Black keys are shorter */
            margin-left: calc(-600px / 25 * 1/5);
            margin-right: calc(-600px / 25 * 1/5);
            z-index: 1;
            border-bottom: 1px solid #333;
        }
        .playback-key.key-held-ui { /* Style for UI held notes on playback keyboard */
            background-color: #99ccee; /* Lighter shade of blue */
            border-bottom: unset;
        }
        .playback-key.key-held-midi { /* Style for MIDI held notes on playback keyboard */
            background-color: #ccffcc; /* Lighter shade of green */
            border-bottom: unset;
        }
        .playback-key.key-held-octave-expanded { /* New style for octave-expanded notes */
            background-color: #cceeff; /* A very light blue/grey, less prominent than UI/MIDI held */
            color: black; /* Ensure text is readable if you decide to add text to these keys */
            border-bottom: unset;
        }
        .playback-key.key-current { /* Style for currently playing notes on playback keyboard */
            background-color: #ffddaa; /* Very light yellow */
            border: 1px solid #ccc; /* Add border to current key on playback keyboard */
            border-bottom: unset;
        }
        /* Style for ChordN gate extended notes on playback keyboard */
        .playback-key.key-gate-extended {
            background-color: #ffddee; /* Light pink/purple to indicate held */
            border-bottom: unset;
        }

        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; background-color: #eee; border-radius: 3px; /* Added background and border-radius to playback display */ padding-left: 5px; }
        .playback-step {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd; /* Lighter border for playback steps */
            margin-right: 2px;
            text-align: center;
            line-height: 20px;
            font-size: 10px;
            border-radius: 2px; /* Slightly rounded corners for playback steps */
            background-color: #fff; /* Default playback step background */
        }
        .playback-step.note { background-color: #ffffdd; /* Light yellow for note playback */ }
        .playback-step.rest { background-color: #ffdddd; /* Light red for rest playback */ }
        .playback-step.skip { background-color: #ddddff; /* Light blue for skip playback */ }
        .device-selector { margin-bottom: 10px; }
        .slider-container {
            display: flex;
            align-items: center; /* Vertically align label and slider */
            margin-bottom: 5px; /* Add spacing between slider containers */
        }
        .slider-container label {
            margin-right: 10px; /* Space between label and slider */
            width: 120px; /* Wider fixed width for labels to align them */
            text-align: right; /* Right-align label text */
            font-size: 0.9em; /* Slightly smaller label font size */
            color: #666; /* Muted label color */
        }
        .slider-container input[type="range"] {
            width: 300px; /* Adjust slider width as needed */
        }
        .number-display {
            width: 30px; /* Fixed width for number display */
            text-align: center;
            margin-left: 5px;
            font-size: 0.9em; /* Slightly smaller number display font size */
            color: #777; /* Muted number display color */
        }

        #tempoBPM { /* Tempo BPM input now serves as display as well */
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            font-size: 1.2em; /* Larger tempo display */
            color: #333; /* Darker tempo text */
            border: none; /* Remove border */
            background-color: transparent; /* Make background transparent */
            width: auto; /* Adjust width to content */
            padding: 0; /* Remove padding */
            text-align: left; /* Align text left */
        }
        #tempoBPM:read-only { /* Style for read-only state */
            cursor: default; /* Default cursor for read-only */
            color: #777; /* Muted color when read-only */
            font-weight: normal; /* Normal font weight when read-only */
        }

        #midiStatus {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #777;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #ddd;
            padding-bottom: 5px;
        }
        h3 {
            margin-top: 0;
            color: #555;
        }
        label {
            font-size: 0.95em;
            color: #444;
            margin-right: 5px;
        }
        select, input[type="number"], input[type="range"], button, input[type="checkbox"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        button {
            background-color: #eee;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #ddd;
        }
        button:disabled {
            background-color: #f0f0f0;
            color: #999;
            cursor: default;
        }
        #startButton.playing {
            background-color: lightgreen;
        }
        #stopButton.playing {
            background-color: lightcoral;
        }

        /* --- TAB STYLES --- */
        .tab-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fafafa;
            margin-bottom: 10px;
        }

        .tab-buttons {
            display: flex;
            background-color: #eee;
            border-bottom: 1px solid #ccc;
        }

        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            border-right: 1px solid #ccc;
            font-size: 0.9em;
            color: #555;
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button.active {
            background-color: #fafafa;
            color: #333;
            font-weight: bold;
        }

        .tab-content {
            padding: 10px;
        }

        .tab-pane {
            display: none; /* Initially hide all tab panes */
        }

        .tab-pane.active {
            display: block; /* Show active tab pane */
        }
    </style>
</head>
<body>
    <h1>MPE Euclidean Arpeggiator</h1>

    <div class="note-selector" title="Use this keyboard to select notes with the mouse.">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="midi-mpe-tab">MIDI & MPE</button>
            <button class="tab-button" data-tab="pattern-tab">Pattern</button>
            <button class="tab-button" data-tab="rhythm-tab">Rhythm</button>
            <button class="tab-button" data-tab="arp-tab">Arp</button>
        </div>

        <div id="midi-mpe-tab" class="tab-content tab-pane active">
            <fieldset class="parameter-group">
                <legend><h3>MIDI & MPE Settings</h3></legend>

			    <div id="midiStatus">MIDI Status: Initializing...</div>

			    <div class="device-selector" title="Select your MIDI input device.">
			        <label for="midiInputSelect">MIDI Input:</label>
			        <select id="midiInputSelect" title="Choose the MIDI input device to receive notes and clock from.">
			            <option value="">No input device selected</option>
			        </select>
			    </div>

			    <div class="device-selector" title="Select your MIDI output device.">
			        <label for="midiOutputSelect">MIDI Output:</label>
			        <select id="midiOutputSelect" title="Choose the MIDI output device to send arpeggiated notes to.">
			            <option value="">No output device selected</option>
			        </select>
			    </div>

                <div class="slider-container" title="Source of tempo: internal BPM or external MIDI clock.">
                    <label for="tempoSource">Tempo Source:</label>
                    <select id="tempoSource" title="Choose whether the tempo is controlled internally or by external MIDI clock.">
                        <option value="internal">Internal</option>
                        <option value="external">External MIDI Clock</option>
                    </select>
                </div>

                <div class="slider-container" title="Tempo in Beats Per Minute (BPM). Only active when Tempo Source is Internal.">
                    <label for="tempoBPM">Tempo:</label>
                    <input type="number" id="tempoBPM" value="120" min="10" max="300" title="Set the tempo in BPM for internal clock.">
                </div>

                <div class="slider-container" title="Enable or disable MPE input processing.">
                    <input type="checkbox" id="enableMPE" title="Enable MPE (MIDI Polyphonic Expression) input for per-note control.">
                    <label for="enableMPE" style="text-align: left; width: auto;">Enable MPE Input</label>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global messages or Omni for all channels.">
                    <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
                    <select id="mpeGlobalInputChannel" title="Set the MIDI channel for MPE global control messages, or Omni to listen to all channels.">
                        <option value="omni">Omni</option>
                        <option value="1">Channel 1</option>
                        <option value="2">Channel 2</option>
                        <option value="3">Channel 3</option>
                        <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option>
                        <option value="6">Channel 6</option>
                        <option value="7">Channel 7</option>
                        <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option>
                        <option value="10">Channel 10</option>
                        <option value="11">Channel 11</option>
                        <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option>
                        <option value="14">Channel 14</option>
                        <option value="15">Channel 15</option>
                        <option value="16">Channel 16</option>
                    </select>
                </div>

                <div class="slider-container" title="Number of MIDI channels used for MPE voice messages.">
                    <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
                    <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15" title="Specify the number of MIDI channels to use for MPE voice messages.">
                </div>

                <div class="slider-container" title="Output mode: Non-MPE (single channel) or MPE.">
                    <label for="mpeOutputMode">MPE Output Mode:</label>
                    <select id="mpeOutputMode" title="Choose the MIDI output mode: Non-MPE (single channel) or MPE.">
                        <option value="non-mpe">Non-MPE (Single Channel)</option>
                        <option value="mpe">MPE</option>
                    </select>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global output or base channel for non-MPE.">
                    <label for="mpeGlobalOutputChannel">MPE Global Output / Base Channel:</label>
                    <select id="mpeGlobalOutputChannel" title="Set the MIDI channel for MPE global output or the base channel for non-MPE output.">
                        <option value="1">Channel 1</option>
                        <option value="2">Channel 2</option>
                        <option value="3">Channel 3</option>
                        <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option>
                        <option value="6">Channel 6</option>
                        <option value="7">Channel 7</option>
                        <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option>
                        <option value="10">Channel 10</option>
                        <option value="11">Channel 11</option>
                        <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option>
                        <option value="14">Channel 14</option>
                        <option value="15">Channel 15</option>
                        <option value="16">Channel 16</option>
                    </select>
                </div>
            </fieldset>
        </div>

        <div id="pattern-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Pattern Settings</h3></legend>
                <div class="slider-container" title="Enable or disable the pattern rhythm.">
                    <input type="checkbox" id="enablePattern" checked title="Enable pattern rhythm to introduce skips.">
                    <label for="enablePattern" style="text-align: left; width: auto;">Enable Pattern</label>
                </div>
                <div class="slider-container" title="Number of steps in the pattern rhythm.">
                    <label for="patternSteps">Steps:</label>
                    <input type="range" id="patternSteps" value="5" min="1" max="32" step="1" title="Adjust the number of steps in the pattern.">
                    <span id="patternStepsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Number of beats within the pattern steps.">
                    <label for="patternBeats">Beats:</label>
                    <input type="range" id="patternBeats" value="3" min="1" max="5" step="1" title="Adjust the number of beats in the pattern rhythm.">
                    <span id="patternBeatsValue" class="number-display">3</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the pattern rhythm.">
                    <label for="patternOffset">Offset:</label>
                    <input type="range" id="patternOffset" value="0" min="-2" max="2" step="1" title="Shift the pattern rhythm forwards or backwards.">
                    <span id="patternOffsetValue" class="number-display">0</span>
                </div>
                <div id="patternDisplay" class="rhythm-display" title="Visual representation of the pattern rhythm (Note/Skip)."></div>
            </fieldset>
        </div>

        <div id="rhythm-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Rhythm Settings</h3></legend>
                 <div class="slider-container" title="Enable or disable the arpeggio rhythm.">
                    <input type="checkbox" id="enableRhythm" checked title="Enable arpeggio rhythm to introduce rests.">
                    <label for="enableRhythm" style="text-align: left; width: auto;">Enable Rhythm</label>
                </div>
                <div class="slider-container" title="Number of steps in the arpeggio rhythm.">
                    <label for="rhythmSteps">Steps:</label>
                    <input type="range" id="rhythmSteps" value="7" min="1" max="32" step="1" title="Adjust the number of steps in the arpeggio rhythm.">
                    <span id="rhythmStepsValue" class="number-display">7</span>
                </div>
                <div class="slider-container" title="Number of beats within the arpeggio rhythm steps.">
                    <label for="rhythmBeats">Beats:</label>
                    <input type="range" id="rhythmBeats" value="5" min="1" max="7" step="1" title="Adjust the number of beats in the arpeggio rhythm.">
                    <span id="rhythmBeatsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the arpeggio rhythm.">
                    <label for="rhythmOffset">Offset:</label>
                    <input type="range" id="rhythmOffset" value="0" min="-4" max="4" step="1" title="Shift the arpeggio rhythm forwards or backwards.">
                    <span id="rhythmOffsetValue" class="number-display">0</span>
                </div>
                <div id="rhythmDisplay" class="rhythm-display" title="Visual representation of the arpeggio rhythm (Beat/Rest)."></div>
            </fieldset>
        </div>

        <div id="arp-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Arp Settings</h3></legend>

                <div class="slider-container" title="Clock division for arpeggiator step timing.">
                    <label for="clockDivision">Clock Division:</label>
                    <select id="clockDivision" title="Set the clock division to control the speed of the arpeggio steps.">
                        <option value="1/1">1/1</option>
                        <option value="1/2">1/2</option>
                        <option value="1/4" selected="selected">1/4</option>
                        <option value="1/8">1/8</option>
                        <option value="1/16">1/16</option>
                        <option value="1/32">1/32</option>
                        <option value="1/2T">1/2T</option>
                        <option value="1/4T">1/4T</option>
                        <option value="1/8T">1/8T</option>
                        <option value="1/16T">1/16T</option>
                        <option value="1/32T">1/32T</option>
                    </select>
                </div>

                <div class="slider-container" title="Arpeggio mode determines the order notes are played.">
                    <label for="arpMode">Arp Mode:</label>
                    <select id="arpMode" title="Select the arpeggio playback mode.">
                        <option value="up" selected="selected">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up/Down</option>
                        <option value="upDownInclusive">Up/Down (Incl.)</option>
                        <option value="random">Random</option>
                        <option value="converge">Converge</option>
                        <option value="diverge">Diverge</option>
                        <option value="played">Played</option>
                        <option value="shuffled">Shuffled</option>
                        <option value="stableShuffled">Stable Shuffled</option>
                        <option value="chord">Chord</option>
                        <option value="chordN">ChordN</option>
                        <option value="convergeDiverge">Converge/Diverge</option>
                        <option value="convergeDivergeInclusive">Converge/Diverge (Incl.)</option>
                        <option value="walk">Walk</option>
                        <option value="normalWalk">Normal Walk</option>
                    </select>
                </div>

                <div id="chordNControls" style="display: none;">
                    <div class="slider-container" title="Number of notes in each chord for ChordN mode.">
                        <label for="chordNValue">N:</label>
                        <input type="range" id="chordNValue" value="2" min="1" max="16" step="1" title="Set the number of notes per chord in ChordN arpeggio mode.">
                        <span id="chordNValueDisplay" class="number-display">2</span>
                    </div>
                    <div class="slider-container" title="Ordering mode for ChordN chords.">
                        <label for="chordNOrdering">ChordN Ordering:</label>
                        <select id="chordNOrdering" title="Select the ordering mode for ChordN chords.">
                            <option value="up">Up</option>
                            <option value="down">Down</option>
                            <option value="upDown">Up/Down</option>
                            <option value="upDownInclusive">Up/Down (Incl.)</option>
                            <option value="converge">Converge</option>
                            <option value="diverge">Diverge</option>
                        </select>
                    </div>
                    <div class="slider-container" title="Maximum number of consecutive chords a note can be held across in ChordN mode. 1 means no extension.">
                        <label for="maxChordExtension">Max Chord Extend:</label>
                        <input type="range" id="maxChordExtension" value="2" min="1" max="16" step="1" title="Maximum number of consecutive chords a note can be held across in ChordN mode.">
                        <span id="maxChordExtensionValue" class="number-display">2</span>
                    </div>
                    <div class="slider-container" title="Maximum number of clock divisions a note's gate can be extended in ChordN mode.">
                        <label for="maxTimeExtension">Max Time Extend (Divs):</label>
                        <input type="range" id="maxTimeExtension" value="16" min="1" max="64" step="1" title="Maximum number of clock divisions a note's gate can be extended in ChordN mode.">
                        <span id="maxTimeExtensionValue" class="number-display">16</span>
                    </div>
                </div>

                <div id="walkParams" style="display: none;">
                    <div class="slider-container" title="Skew parameter for Walk arpeggio mode.">
                        <label for="walkSkew">Walk Skew:</label>
                        <input type="range" id="walkSkew" value="0" min="-1" max="1" step="0.01" title="Adjust the skew for Walk arpeggio mode, affecting probability of steps.">
                        <span id="walkSkewValue" class="number-display">0</span>
                    </div>
                    <div class="slider-container" id="walkDistanceContainer" style="display: none;">
                        <label for="walkDistance">Walk Distance:</label>
                        <input type="range" id="walkDistance" value="0" min="0" max="1" step="0.01" title="Adjust the distance for Normal Walk arpeggio mode, affecting step size.">
                        <span id="walkDistanceValue" class="number-display">0</span>
                    </div>
                </div>

                <div class="slider-container" title="Percentage of clock division used for sub-arpeggiation of chords.">
                    <label for="subArpScale">Sub Arp Scale (%):</label>
                    <input type="range" id="subArpScale" value="0" min="0" max="100" step="1" title="Control the timing spread of notes within chords. 0% for no sub-arp, 100% to fill clock division.">
                    <span id="subArpScaleValue" class="number-display">0</span>
                </div>
                <div class="slider-container" title="Arpeggio mode for sub-arpeggiation of chords.">
                    <label for="subArpMode">Sub Arp Mode:</label>
                    <select id="subArpMode" title="Select the arpeggio mode for sub-arpeggiation within chords.">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="random">Random</option>
                        <option value="converge">Converge</option>
                        <option value="diverge">Diverge</option>
                    </select>
                </div>

                <div class="slider-container" title="Synchronization mode for the arpeggiator.">
                    <label for="arpSyncMode">Arp Sync Mode:</label>
                    <select id="arpSyncMode" title="Choose the synchronization mode for starting and stopping the arpeggiator.">
                        <option value="free">Free Sync</option>
                        <option value="key" selected="selected">Key Sync</option>
                        <option value="transport">Transport Sync (Placeholder)</option>
                    </select>
                </div>

                <div class="slider-container" title="Number of octaves to expand held notes across.">
                    <label for="octaves">Octaves:</label>
                    <input type="range" id="octaves" value="1" min="1" max="4" step="1" title="Expand the range of arpeggiated notes by adding octaves above the held notes.">
                    <span id="octavesValue" class="number-display">1</span>
                </div>
                <div class="slider-container" title="Base velocity for arpeggiated notes.">
                    <label for="baseVelocity">Base Velocity:</label>
                    <input type="range" id="baseVelocity" value="96" min="1" max="127" step="1" title="Set the base velocity for arpeggiated notes. Velocity can be further modified by MPE or aftertouch.">
                    <span id="baseVelocityValue" class="number-display">96</span>
                </div>
                <div class="slider-container" title="Maximum velocity for arpeggiated notes.">
                    <label for="maxVelocity">Max Velocity:</label>
                    <input type="range" id="maxVelocity" value="127" min="1" max="127" step="1" title="Set the maximum velocity for arpeggiated notes. Used in conjunction with base velocity and pressure.">
                    <span id="maxVelocityValue" class="number-display">127</span>
                </div>
                <div class="slider-container" title="Gate length as a percentage of the clock division.">
                    <label for="gateLength">Gate Length (%):</label>
                    <input type="range" id="gateLength" value="50" min="1" max="150" step="1" title="Adjust the gate length of arpeggiated notes as a percentage of the clock division duration.">
                    <span id="gateLengthValue" class="number-display">50</span>
                </div>
                <div class="slider-container" title="Enable gate flex to extend note gates based on rhythm density.">
                    <input type="checkbox" id="enableGateFlex" title="Enable Gate Flex to make gates longer before rests.">
                    <label for="enableGateFlex" style="text-align: left; width: auto;">Enable Gate Flex</label>
                </div>
            </fieldset>
        </div>
    </div>

    <div class="playback-keyboard-container" title="Visual display of held and playing notes. Not interactive.">
        <div class="playback-keyboard" id="playbackKeyboardDisplay">
            <!-- Playback piano keys will be generated here by JavaScript -->
        </div>
    </div>

    <div class="playback-display" id="playbackDisplay" title="Displays the sequence of played notes and rhythms."></div>

    <button id="startButton" title="Start the arpeggiator." class="control-button">Start Arpeggiator</button>
    <button id="stopButton" disabled title="Stop the arpeggiator." class="control-button">Stop Arpeggiator</button>

    <script>
        /**
         * @fileoverview Euclidean MPE Arpeggiator Prototype
         * Refactored Active Note management (A6).
         * Refactored MIDI Manager (A5).
         * Refactored Note Input Manager (A2).
         */

        // --- Utility Functions ---
        function arraysAreEqual(arr1, arr2) {
            /* ... unchanged ... */
            if (!arr1 || !arr2 || arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        // --- *** Refactor: MidiManager Module (A5) *** ---
        const MidiManager = (function() {
            /* ... unchanged from previous step ... */
            let _midiAccess = null;
            let _selectedInput = null;
            let _selectedOutput = null;
            let _status = "Initializing...";
            let _inputsList = [];
            let _outputsList = [];
            let _isMPEEnabled = false;
            let _globalInputChannel = 'omni';
            let _inputVoiceChannels = 8;
            let _outputMode = 'non-mpe';
            let _globalOutputChannel = '1';
            let _callbacks = {
                onReady: () => {},
                onInputSelected: (input) => {},
                onOutputSelected: (output) => {},
                onStatusUpdate: (status) => {}
            };

            function _updateStatus(newStatus) {
                _status = newStatus;
                _callbacks.onStatusUpdate(_status);
            }

            function _onMIDISuccess(midi) {
                _midiAccess = midi;
                _updateStatus("Connected");
                _inputsList = [];
                _midiAccess.inputs.forEach(input => {
                    _inputsList.push({
                        id: input.id,
                        name: input.name || `MIDI Input ${_inputsList.length + 1}`
                    });
                });
                _outputsList = [];
                _midiAccess.outputs.forEach(output => {
                    _outputsList.push({
                        id: output.id,
                        name: output.name || `MIDI Output ${_outputsList.length + 1}`
                    });
                });
                _callbacks.onReady(_inputsList, _outputsList);
            }

            function _onMIDIFailure(error) {
                _updateStatus("MIDI access failed: " + error);
                _callbacks.onReady([], []);
            }
            return {
                initialize: (callbacks) => {
                    _callbacks = {
                        ..._callbacks,
                        ...callbacks
                    };
                    _updateStatus("Requesting MIDI access...");
                    if (navigator.requestMIDIAccess) {
                        navigator.requestMIDIAccess().then(_onMIDISuccess, _onMIDIFailure);
                    } else {
                        _updateStatus("Web MIDI API not supported.");
                        _callbacks.onReady([], []);
                    }
                },
                selectInput: (inputId) => {
                    if (_selectedInput) {
                        _selectedInput.onmidimessage = null;
                        _selectedInput = null;
                    }
                    if (inputId && _midiAccess) {
                        _selectedInput = _midiAccess.inputs.get(inputId);
                        if (_selectedInput) {
                            _callbacks.onInputSelected(_selectedInput);
                        } else {
                            console.warn(`Input ${inputId} not found.`);
                            _callbacks.onInputSelected(null);
                        }
                    } else {
                        _callbacks.onInputSelected(null);
                    }
                },
                selectOutput: (outputId) => {
                    _selectedOutput = null;
                    if (outputId && _midiAccess) {
                        _selectedOutput = _midiAccess.outputs.get(outputId);
                        if (!_selectedOutput) console.warn(`Output ${outputId} not found.`);
                    }
                    _callbacks.onOutputSelected(_selectedOutput);
                },
                setMPEEnabled: (enabled) => {
                    _isMPEEnabled = !!enabled;
                },
                setMPEGlobalInputChannel: (channel) => {
                    _globalInputChannel = channel;
                },
                setMPEInputVoiceChannels: (count) => {
                    _inputVoiceChannels = parseInt(count) || 8;
                },
                setMPEOutputMode: (mode) => {
                    _outputMode = mode;
                },
                setMPEGlobalOutputChannel: (channel) => {
                    _globalOutputChannel = channel;
                },
                isMPEEnabled: () => _isMPEEnabled,
                getOutputChannel: () => parseInt(_globalOutputChannel) - 1,
                isMPEOutput: () => _outputMode === 'mpe',
                getMPEInputConfig: () => ({
                    isEnabled: _isMPEEnabled,
                    globalChannel: _globalInputChannel,
                    voiceChannelCount: _inputVoiceChannels
                }),
                getSelectedOutputDevice: () => _selectedOutput,
            };
        })();

        // --- *** Refactor: ActiveNoteManager Module (A6) *** ---
        const ActiveNoteManager = (function() {
            /* ... unchanged from previous step ... */
            let activeArpNotes = new Map();
            let config = {
                midiOutput: null,
                updatePlaybackKeyCallback: (note) => {},
                getMPEOutputMode: () => false
            };

            function sendNoteOnHelper(note, velocity, outputChannel) {
                if (config.midiOutput && note >= 0 && note <= 127 && velocity > 0 && velocity <= 127 && outputChannel >= 0 && outputChannel <= 15) {
                    const isMPE = config.getMPEOutputMode();
                    config.midiOutput.send([0x90 + outputChannel, note, velocity]);
                }
            }

            function sendNoteOffHelper(note, outputChannel, velocity = 0) {
                if (config.midiOutput && note >= 0 && note <= 127 && outputChannel >= 0 && outputChannel <= 15) {
                    const isMPE = config.getMPEOutputMode();
                    config.midiOutput.send([0x80 + outputChannel, note, velocity]);
                }
            }

            function cancelNoteOff(note) {
                const state = activeArpNotes.get(note);
                if (state && state.noteOffTimeoutId !== null) {
                    clearTimeout(state.noteOffTimeoutId);
                    activeArpNotes.set(note, {
                        ...state,
                        noteOffTimeoutId: null
                    });
                    config.updatePlaybackKeyCallback(note);
                }
            }

            function stopNote(note, outputChannel) {
                cancelNoteOff(note);
                if (activeArpNotes.has(note)) {
                    sendNoteOffHelper(note, outputChannel);
                    activeArpNotes.delete(note);
                    config.updatePlaybackKeyCallback(note);
                }
            }

            function scheduleNoteOff(note, delayMs, outputChannel) {
                cancelNoteOff(note);
                const timeoutId = setTimeout(() => stopNote(note, outputChannel), Math.max(0, delayMs));
                const state = activeArpNotes.get(note);
                if (state) {
                    activeArpNotes.set(note, {
                        ...state,
                        noteOffTimeoutId: timeoutId,
                        isExtended: false
                    });
                    config.updatePlaybackKeyCallback(note);
                }
            }

            function startNote(note, velocity, outputChannel) {
                if (activeArpNotes.has(note)) cancelNoteOff(note);
                sendNoteOnHelper(note, velocity, outputChannel);
                activeArpNotes.set(note, {
                    noteOffTimeoutId: null,
                    isExtended: false,
                    chordsHeldCount: 0,
                    timeHeldDivisions: 0,
                    outputChannel: outputChannel
                });
                config.updatePlaybackKeyCallback(note);
            }

            function allNotesOff() {
                const notesToStop = Array.from(activeArpNotes.entries());
                notesToStop.forEach(([note, state]) => stopNote(note, state.outputChannel));
                if (activeArpNotes.size > 0) {
                    console.warn("ANM: Map not empty after allNotesOff");
                    activeArpNotes.clear();
                }
            }
            return {
                initialize: (initialConfig) => {
                    config.updatePlaybackKeyCallback = initialConfig.updatePlaybackKeyCallback || ((note) => {});
                    config.getMPEOutputMode = initialConfig.getMPEOutputMode || (() => false);
                },
                setMidiOutput: (outputDevice) => {
                    allNotesOff();
                    config.midiOutput = outputDevice;
                },
                getActiveNotesMap: () => activeArpNotes,
                startNote,
                stopNote,
                scheduleNoteOff,
                cancelNoteOff,
                allNotesOff,
                hasNote: (note) => activeArpNotes.has(note),
                updateNoteState: (note, newStatePartial) => {
                    const state = activeArpNotes.get(note);
                    if (state) {
                        activeArpNotes.set(note, {
                            ...state,
                            ...newStatePartial
                        });
                        config.updatePlaybackKeyCallback(note);
                    }
                }
            };
        })();


        // --- *** Refactor: NoteInputManager Module (A2) *** ---
        const NoteInputManager = (function() {
            // --- State ---
            let _rawHeldNotes = [];
            let _heldNotes = []; // Octave expanded
            let _heldNotesUI = new Set();
            let _heldNotesMIDI = new Set();
            let _playedNoteOrder = [];
            let _octaveExpandedNoteMap = new Map();
            let _notePressures = new Map(); // Maps originalNote -> pressure
            let _noteMPEYAxis = new Map(); // Maps originalNote -> y-axis value
            let _mpeChannelNotes = new Array(16).fill(null); // Maps channel -> current raw note

            let _octaveCount = 1;
            let _isSustainPedalPressed = false;
            let _sustainedNotesMIDI = new Set();

            // --- Config / Callbacks ---
            let config = {
                onNotesChanged: (heldNotes, rawHeldNotes, playedOrder) => {}, // Callback when notes list changes
                getMPEInputConfig: () => ({
                    isEnabled: false
                }), // Function to get MPE config
                updatePianoKeyCallback: (note, source) => {}, // Callback to update UI
                updatePlaybackKeyboardCallback: () => {} // Callback to update playback UI
            };
            const defaultNotePressure = 0;
            const defaultMpeYAxis = 0;


            // --- Internal Methods ---

            /** Generates octave-expanded notes from raw held notes. */
            function _generateOctaveExpandedNotes(inputNotes, octaves) {
                const expandedNotes = [];
                const seenNotes = new Set();
                _octaveExpandedNoteMap.clear();
                for (let i = 0; i < octaves; i++) {
                    for (const originalNote of inputNotes) {
                        const expandedNote = originalNote + (12 * i);
                        if (!seenNotes.has(expandedNote) && expandedNote <= 127) {
                            expandedNotes.push(expandedNote);
                            seenNotes.add(expandedNote);
                            _octaveExpandedNoteMap.set(expandedNote, originalNote);
                        }
                    }
                }
                return expandedNotes;
            }

            /** Finds the original raw note corresponding to an octave-expanded note. */
            function _findOriginalNote(expandedNote) {
                if (_rawHeldNotes.includes(expandedNote)) {
                    return expandedNote; // It wasn't expanded or was the base note
                }
                return _octaveExpandedNoteMap.get(expandedNote) || null;
            }

            /** Updates the _heldNotes array and notifies listeners. */
            function _updateHeldNotesArraysAndNotify() {
                // Sort raw notes before expansion for consistent octave mapping
                _rawHeldNotes.sort((a, b) => a - b);
                _heldNotes = _generateOctaveExpandedNotes(_rawHeldNotes, _octaveCount);

                // Notify listeners
                config.onNotesChanged([..._heldNotes], [..._rawHeldNotes], getPlayedNoteOrderFiltered());
            }


            /** Internal logic to add a note. */
            function _addHeldNote(note, source = 'ui', channel = null) {
                const isUI = source === 'ui';
                const heldSet = isUI ? _heldNotesUI : _heldNotesMIDI;
                let noteAdded = false;
                const mpeConfig = config.getMPEInputConfig();

                if (isUI) {
                    if (!heldSet.has(note)) {
                        heldSet.add(note);
                        _rawHeldNotes.push(note);
                        _playedNoteOrder.push(note);
                        noteAdded = true;
                    } else { // UI click again toggles off
                        heldSet.delete(note);
                        const indexToRemove = _rawHeldNotes.indexOf(note);
                        if (indexToRemove > -1) {
                            _rawHeldNotes.splice(indexToRemove, 1);
                            const playedIndexToRemove = _playedNoteOrder.indexOf(note);
                            if (playedIndexToRemove > -1) {
                                _playedNoteOrder.splice(playedIndexToRemove, 1);
                            }
                        }
                        // No noteAdded = true here, it's a removal
                    }
                    // Update arrays and UI immediately for UI toggle
                    _updateHeldNotesArraysAndNotify();
                    config.updatePianoKeyCallback(note, source);
                    config.updatePlaybackKeyboardCallback(); // Update whole playback display

                } else { // source === 'midi'
                    if (!_heldNotesMIDI.has(note)) {
                        _heldNotesMIDI.add(note);
                        _rawHeldNotes.push(note);
                        _playedNoteOrder.push(note);
                        noteAdded = true;
                    }
                    if (noteAdded) {
                        // Only update arrays if a note was actually added
                        _updateHeldNotesArraysAndNotify();
                    }
                    // Update UI visuals
                    config.updatePianoKeyCallback(note, 'midi');
                    config.updatePlaybackKeyboardCallback();

                    if (mpeConfig.isEnabled && channel !== null && channel >= 0 && channel < 16) {
                        _mpeChannelNotes[channel] = note;
                    }
                }

                if (noteAdded) {
                    _notePressures.set(note, defaultNotePressure);
                    _noteMPEYAxis.set(note, defaultMpeYAxis);
                }
            }

            /** Internal logic to remove a note. */
            function _removeHeldNote(note, source = 'midi', channel = null) {
                let noteRemoved = false;
                const mpeConfig = config.getMPEInputConfig();

                if (source === 'midi') {
                    if (_isSustainPedalPressed) {
                        _sustainedNotesMIDI.add(note); // Sustain it
                        return; // Don't process removal yet
                    }
                    if (_heldNotesMIDI.has(note)) {
                        _heldNotesMIDI.delete(note);
                        const indexToRemove = _rawHeldNotes.indexOf(note);
                        if (indexToRemove > -1) {
                            _rawHeldNotes.splice(indexToRemove, 1);
                            const playedIndexToRemove = _playedNoteOrder.indexOf(note);
                            if (playedIndexToRemove > -1) {
                                _playedNoteOrder.splice(playedIndexToRemove, 1);
                            }
                            noteRemoved = true;
                        }
                        // Update UI visual state for this key
                        config.updatePianoKeyCallback(note, null); // Indicate removal for MIDI source

                        if (mpeConfig.isEnabled && channel !== null && channel >= 0 && channel < 16 && _mpeChannelNotes[channel] === note) {
                            _mpeChannelNotes[channel] = null;
                        }
                    }
                } else { // source === 'ui' - Removal handled by _addHeldNote toggle logic
                    // This path shouldn't normally be hit by external calls if UI uses toggle
                    console.warn("NoteInputManager: _removeHeldNote called for UI source unexpectedly.");
                    return; // Avoid double removal/notification
                }

                if (noteRemoved) {
                    _notePressures.delete(note);
                    _noteMPEYAxis.delete(note);
                    _updateHeldNotesArraysAndNotify(); // Update arrays and notify about change
                    config.updatePlaybackKeyboardCallback(); // Update whole playback display
                }
            }

            /** Filters playedNoteOrder to only include currently held raw notes. */
            function getPlayedNoteOrderFiltered() {
                return _playedNoteOrder.filter(note => _rawHeldNotes.includes(note));
            }

            // --- Public Interface ---
            return {
                initialize: (initialConfig) => {
                    config = {
                        ...config,
                        ...initialConfig
                    };
                    // console.log("NoteInputManager Initialized");
                },

                handleNoteOn: (note, source = 'ui', channel = null) => {
                    // console.log(`NIM: NoteOn ${note} src=${source} ch=${channel}`);
                    _addHeldNote(note, source, channel);
                },

                handleNoteOff: (note, source = 'midi', channel = null) => {
                    // console.log(`NIM: NoteOff ${note} src=${source} ch=${channel}`);
                    _removeHeldNote(note, source, channel);
                },

                handleSustain: (isPressed) => {
                    // console.log(`NIM: Sustain ${isPressed}`);
                    const wasPressed = _isSustainPedalPressed;
                    _isSustainPedalPressed = isPressed;

                    if (wasPressed && !isPressed) { // Pedal Up
                        let notesToRelease = [..._sustainedNotesMIDI];
                        _sustainedNotesMIDI.clear();
                        // Trigger note off for any notes that were sustained AND are not currently held by MIDI again
                        notesToRelease.forEach(sustainedNote => {
                            if (!_heldNotesMIDI.has(sustainedNote)) {
                                // Find channel if MPE
                                let noteChannel = -1;
                                if (config.getMPEInputConfig().isEnabled) {
                                    noteChannel = _mpeChannelNotes.findIndex(n => n === sustainedNote);
                                }
                                _removeHeldNote(sustainedNote, 'midi', noteChannel !== -1 ? noteChannel : null);
                            }
                        });
                    }
                },

                handlePressureUpdate: (note, pressure, isPolyAftertouch = false) => {
                    // Assumes 'note' is the raw MIDI note from the message
                    const originalNote = isPolyAftertouch ? _findOriginalNote(note) : note; // Channel pressure applies to original note directly
                    if (originalNote !== null && _notePressures.has(originalNote)) {
                        // console.log(`NIM: Pressure update ${originalNote}: ${pressure}`);
                        _notePressures.set(originalNote, pressure);
                    }
                },

                handleMPEYAxisUpdate: (note, value) => {
                    // Assumes 'note' is the raw MIDI note associated with the channel sending CC74
                    const originalNote = _findOriginalNote(note);
                    if (originalNote !== null) {
                        // console.log(`NIM: Y-Axis update ${originalNote}: ${value}`);
                        _noteMPEYAxis.set(originalNote, value);
                    }
                },

                setOctaveCount: (count) => {
                    const newCount = Math.max(1, Math.min(4, parseInt(count) || 1));
                    if (newCount !== _octaveCount) {
                        // console.log(`NIM: Octave Count set to ${newCount}`);
                        _octaveCount = newCount;
                        _updateHeldNotesArraysAndNotify(); // Regenerate expanded notes and notify
                        config.updatePlaybackKeyboardCallback(); // Update display
                    }
                },

                // --- Getters ---
                getHeldNotes: () => [..._heldNotes], // Return a copy
                getRawHeldNotes: () => [..._rawHeldNotes], // Return a copy
                getPlayedNoteOrderFiltered: getPlayedNoteOrderFiltered,
                getNotePressure: (originalNote) => _notePressures.get(originalNote) ?? defaultNotePressure,
                getNoteMPEYAxis: (originalNote) => _noteMPEYAxis.get(originalNote) ?? defaultMpeYAxis,
                findOriginalNote: _findOriginalNote,
                getMPEChannelNote: (channel) => _mpeChannelNotes[channel] ?? null,
                hasHeldNotes: () => _rawHeldNotes.length > 0,
                hasHeldUINote: (note) => _heldNotesUI.has(note),
                hasHeldMIDINote: (note) => _heldNotesMIDI.has(note),


            };
        })();
        // --- *** End NoteInputManager Module *** ---


        // --- MIDI Variables (Removed globals) ---
        let currentMidiInputDevice = null; // Keep track for attaching/detaching handler
        // isSustainPedalPressed moved to NoteInputManager
        // sustainedNotesMIDI moved to NoteInputManager

        // --- Rhythm Event Constants ---
        const RHYTHM_BEAT = 'B';
        const RHYTHM_REST = 'R';
        const PATTERN_NOTE = 'N';
        const PATTERN_SKIP = 'S';

        // --- Note Arrays and Sets (Removed globals, managed by NoteInputManager) ---
        // let rawHeldNotes = [];
        // let heldNotes = [];
        // let heldNotesUI = new Set();
        // let heldNotesMIDI = new Set();
        // let notePressures = new Map();
        // let noteMPEYAxis = new Map();
        // let octaveExpandedNoteMap = new Map();
        // let playedNoteOrder = [];
        // let mpeChannelNotes = new Array(16).fill(null);

        // --- Rhythm Pattern Variables ---
        let patternRhythm = [];
        let rhythm = [];
        let rhythmGateMultipliers = [];
        let isPatternDisabled = false;
        let isRhythmDisabled = false;

        // --- Arpeggiator State Variables ---
        let arpRunning = false;
        let arpInterval = null;
        let currentNoteIndex = 0;
        let currentRhythmIndex = 0;
        let currentPatternIndex = 0;
        let arpMode = 'up';
        let arpSyncMode = 'key';
        let currentModeNoteList = [];
        let chordNValue = 2;

        // --- ChordN Gate Extension ---
        let maxChordExtension = 2;
        let maxTimeExtensionDivisions = 16;

        // --- Walk Mode Parameters ---
        let walkSkew = 0;
        let walkDistance = 0;

        // --- Sub Arp ---
        let subArpScalePercentage = 0;
        let subArpMode = 'up';

        // --- Gate Flex ---
        let isGateFlexEnabled = false;

        // --- Tempo and Clock Variables ---
        let tempoSource = 'internal';
        let bpm = 120;
        let clockDivision = '1/4';
        let tickCounter = -1;
        let clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
        let internalClockInterval = null;
        let clockDivisionDurationMs = 0;
        const tempoBPMInput = document.getElementById('tempoBPM');

        // --- MIDI Clock Tick History ---
        const tickHistorySize = 24;
        let tickHistory = new Array(tickHistorySize).fill(performance.now());
        let tickIndex = tickHistorySize;

        // --- Arpeggio Mode Specific State ---
        let shuffledNotesOrder = [];
        let stableShuffledOrder = [];
        let stableShuffleIndex = 0;
        let lastNotesToArp = [];

        // --- UI Elements and Display ---
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 20;
        let highlightedPianoKey = null;
        let highlightedPlaybackPianoKey = null;
        const midiStatusDisplay = document.getElementById('midiStatus');
        const midiInputSelectElem = document.getElementById('midiInputSelect');
        const midiOutputSelectElem = document.getElementById('midiOutputSelect');


        // --- Octave Expansion (Removed global) ---
        // let octaveCount = 1;

        // --- Velocity Settings ---
        let baseVelocityValue = 96;
        let maxVelocityValue = 127;

        // --- Gate Length ---
        let gateLengthPercentage = 50;
        let gateLengthValueDisplay = document.getElementById('gateLengthValue');

        // -- Miscellaneous constants --
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const LOOKAHEAD_MAX_STEPS = 64;


        // --- Event Listener Setup ---
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        startButton.addEventListener('click', startArpeggiator);
        stopButton.addEventListener('click', stopArpeggiator);
        midiInputSelectElem.addEventListener('change', function() {
            MidiManager.selectInput(this.value);
        });
        midiOutputSelectElem.addEventListener('change', function() {
            MidiManager.selectOutput(this.value);
        });
        document.getElementById('arpMode').addEventListener('change', function() {
            /* ... unchanged ... */
            arpMode = this.value;
            const cN = document.getElementById('chordNControls');
            const wP = document.getElementById('walkParams');
            const wD = document.getElementById('walkDistanceContainer');
            cN.style.display = (arpMode === 'chordN') ? 'block' : 'none';
            wP.style.display = (arpMode === 'walk' || arpMode === 'normalWalk') ? 'block' : 'none';
            wD.style.display = (arpMode === 'normalWalk') ? 'block' : 'none';
            updateArpeggiatorNoteListAndIndex();
        });
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });
        document.getElementById('enableMPE').addEventListener('change', function() {
            MidiManager.setMPEEnabled(this.checked);
        });
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            MidiManager.setMPEGlobalInputChannel(this.value);
        });
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            MidiManager.setMPEInputVoiceChannels(this.value);
        });
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            MidiManager.setMPEOutputMode(this.value);
        });
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            MidiManager.setMPEGlobalOutputChannel(this.value);
        });
        // *** Refactor: Octave Listener uses NoteInputManager ***
        document.getElementById('octaves').addEventListener('input', function() {
            NoteInputManager.setOctaveCount(this.value);
            document.getElementById('octavesValue').textContent = this.value; // Keep UI update here
        });
        document.getElementById('tempoSource').addEventListener('change', function() {
            /* ... unchanged ... */
            tempoSource = this.value;
            if (tempoSource === 'internal') {
                setupInternalClock();
                updateTempoDisplay();
            } else {
                clearInterval(internalClockInterval);
                updateTempoDisplay('External MIDI Clock');
            }
        });
        tempoBPMInput.addEventListener('change', function() {
            /* ... unchanged ... */
            bpm = parseInt(this.value);
            if (tempoSource === 'internal') {
                setupInternalClock();
                updateTempoDisplay();
            }
        });
        document.getElementById('clockDivision').addEventListener('change', function() {
            /* ... unchanged ... */
            clockDivision = this.value;
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            if (tempoSource === 'internal') {
                setupInternalClock();
            }
        });
        // ChordN, Walk, Velocity, Gate, Sub Arp listeners (unchanged)
        document.getElementById('chordNValue').addEventListener('input', function() {
            chordNValue = parseInt(this.value);
            document.getElementById('chordNValueDisplay').textContent = chordNValue;
            updateModeNoteList();
        });
        document.getElementById('chordNOrdering').addEventListener('change', function() {
            updateModeNoteList();
        });
        document.getElementById('maxChordExtension').addEventListener('input', function() {
            maxChordExtension = parseInt(this.value);
            document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        });
        document.getElementById('maxTimeExtension').addEventListener('input', function() {
            maxTimeExtensionDivisions = parseInt(this.value);
            document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        });
        document.getElementById('walkSkew').addEventListener('input', function() {
            walkSkew = parseFloat(this.value);
            document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        });
        document.getElementById('walkDistance').addEventListener('input', function() {
            walkDistance = parseFloat(this.value);
            document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        });
        document.getElementById('baseVelocity').addEventListener('input', function() {
            baseVelocityValue = parseInt(this.value);
            document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        });
        document.getElementById('maxVelocity').addEventListener('input', function() {
            maxVelocityValue = parseInt(this.value);
            document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        });
        document.getElementById('gateLength').addEventListener('input', function() {
            gateLengthPercentage = parseInt(this.value);
            document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        });
        document.getElementById('subArpScale').addEventListener('input', function() {
            subArpScalePercentage = parseInt(this.value);
            document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        });
        document.getElementById('subArpMode').addEventListener('change', function() {
            subArpMode = this.value;
        });
        // Rhythm and Pattern listeners (unchanged)
        document.getElementById('patternSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('enablePattern').addEventListener('change', function() {
            isPatternDisabled = !this.checked;
            updateRhythmDisplays();
            updatePatternControlsState();
        });
        document.getElementById('enableRhythm').addEventListener('change', function() {
            isRhythmDisabled = !this.checked;
            updateRhythmDisplays();
            updateRhythmControlsState();
        });
        document.getElementById('enableGateFlex').addEventListener('change', function() {
            isGateFlexEnabled = this.checked;
        });
        // TAB SWITCHING (unchanged)
        document.querySelectorAll('.tab-button').forEach(button => {
            /* ... unchanged ... */
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });
        // --- End Event Listener Setup ---

        function updateTempoDisplay(source) {
            /* ... unchanged ... */
            if (!source) {
                source = tempoSource === 'internal' ? 'Internal' : 'External MIDI Clock';
            }
            tempoBPMInput.value = bpm;
            tempoBPMInput.title = `Tempo (BPM): ${source === 'Internal' ? 'Editable' : 'Ext Clock'}`;
            tempoBPMInput.readOnly = source !== 'Internal';
        }

        function populateDeviceSelect(selectElement, devices, includeNoneOption = true) {
            /* ... unchanged ... */
            while (selectElement.options.length > (includeNoneOption ? 1 : 0)) {
                selectElement.remove(includeNoneOption ? 1 : 0);
            }
            devices.forEach(device => {
                const option = document.createElement('option');
                option.value = device.id;
                option.text = device.name;
                selectElement.appendChild(option);
            });
        }

        // --- *** Refactor: Callback for NoteInputManager *** ---
        function handleNotesChanged(newHeldNotes, newRawHeldNotes, newPlayedOrder) {
            // This function is called by NoteInputManager when its state changes.

            // 1. Update Arpeggiator List and Index
            updateArpeggiatorNoteListAndIndex(); // Relies on global `arpMode` but uses NIM getters internally now

            // 2. Update Playback Keyboard UI
            updatePlaybackKeyboardUI(); // This function needs to be aware of the new state implicitly or updated

            // 3. Handle Arp Start/Stop based on Key Sync
            if (arpSyncMode === 'key') {
                if (newRawHeldNotes.length > 0 && !arpRunning) {
                    startArpeggiator();
                } else if (newRawHeldNotes.length === 0 && arpRunning) {
                    stopArpeggiator();
                }
            }

            // 4. Handle Shuffle Mode Updates (moved from add/remove)
            // *** Refactor: Needs access to arpRunning, arpMode, shuffledNotesOrder, stableShuffledOrder ***
            if (arpRunning) {
                // Find notes added/removed by comparing newRawHeldNotes with previous (lastNotesToArp)
                const addedNotes = newRawHeldNotes.filter(n => !lastNotesToArp.includes(n));
                const removedNotes = lastNotesToArp.filter(n => !newRawHeldNotes.includes(n)); // Need lastNotesToArp updated

                if (arpMode === 'shuffled') {
                    addedNotes.forEach(note => {
                        const insertionIndex = Math.floor(Math.random() * (shuffledNotesOrder.length + 1));
                        shuffledNotesOrder.splice(insertionIndex, 0, note);
                        if (insertionIndex <= currentNoteIndex) currentNoteIndex++;
                    });
                    removedNotes.forEach(note => {
                        const noteIndex = shuffledNotesOrder.indexOf(note);
                        if (noteIndex !== -1) {
                            shuffledNotesOrder.splice(noteIndex, 1);
                            if (noteIndex < currentNoteIndex && currentNoteIndex > 0) currentNoteIndex--;
                            if (currentNoteIndex >= shuffledNotesOrder.length && shuffledNotesOrder.length > 0) currentNoteIndex = shuffledNotesOrder.length - 1;
                            else if (shuffledNotesOrder.length === 0) currentNoteIndex = 0;
                        }
                    });
                } else if (arpMode === 'stableShuffled') {
                    addedNotes.forEach(note => {
                        const insertionIndex = Math.floor(Math.random() * (stableShuffledOrder.length + 1));
                        stableShuffledOrder.splice(insertionIndex, 0, note);
                        if (insertionIndex <= stableShuffleIndex) stableShuffleIndex++;
                    });
                    removedNotes.forEach(note => {
                        const noteIndex = stableShuffledOrder.indexOf(note);
                        if (noteIndex !== -1) {
                            stableShuffledOrder.splice(noteIndex, 1);
                            if (noteIndex < stableShuffleIndex && stableShuffleIndex > 0) stableShuffleIndex--;
                            if (stableShuffleIndex >= stableShuffledOrder.length && stableShuffledOrder.length > 0) stableShuffleIndex = stableShuffledOrder.length - 1;
                            else if (stableShuffledOrder.length === 0) stableShuffleIndex = 0;
                        }
                    });
                }
            }
            // Update lastNotesToArp *after* comparison
            lastNotesToArp = newRawHeldNotes; // Keep track for next change

        }

        // MidiManager Callbacks (unchanged from previous step)
        const midiManagerCallbacks = {
            /* ... unchanged ... */
            onReady: (inputs, outputs) => {
                populateDeviceSelect(midiInputSelectElem, inputs);
                populateDeviceSelect(midiOutputSelectElem, outputs);
                if (inputs.length > 0) {
                    midiInputSelectElem.selectedIndex = 1;
                    MidiManager.selectInput(inputs[0].id);
                }
                if (outputs.length > 0) {
                    midiOutputSelectElem.selectedIndex = 1;
                    MidiManager.selectOutput(outputs[0].id);
                } else {
                    midiStatusDisplay.innerText += " No MIDI output.";
                    ActiveNoteManager.setMidiOutput(null);
                }
            },
            onInputSelected: (inputDevice) => {
                if (currentMidiInputDevice) {
                    currentMidiInputDevice.onmidimessage = null;
                }
                currentMidiInputDevice = inputDevice;
                if (currentMidiInputDevice) {
                    currentMidiInputDevice.onmidimessage = onMIDIMessage;
                }
            },
            onOutputSelected: (outputDevice) => {
                ActiveNoteManager.setMidiOutput(outputDevice);
            },
            onStatusUpdate: (status) => {
                midiStatusDisplay.innerText = `MIDI Status: ${status}`;
            }
        };

        /** Updates Arpeggiator List/Index - Now uses NoteInputManager getters */
        function updateArpeggiatorNoteListAndIndex() {
            const previousModeNoteList = [...currentModeNoteList];
            const previousNoteIndexVal = currentNoteIndex;

            // *** Refactor: Update mode list using NoteInputManager ***
            const newModeNoteList = updateModeNoteList(); // This function internally uses NoteInputManager getters now

            if (previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                // Note finding logic needs the lists
                if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge', 'convergeDiverge', 'convergeDivergeInclusive', 'walk', 'normalWalk', 'played'].includes(arpMode)) {
                    const previousNote = (arpMode !== 'chordN' && previousModeNoteList.length > 0) ? previousModeNoteList[previousNoteIndexVal % previousModeNoteList.length] : null;
                    if (previousNote !== null) {
                        currentNoteIndex = findClosestNoteIndex(previousNote, previousModeNoteList, newModeNoteList, previousNoteIndexVal);
                    } else {
                        currentNoteIndex = (previousNoteIndexVal % previousModeNoteList.length) % newModeNoteList.length;
                        if (!currentNoteIndex) currentNoteIndex = 0;
                    }
                } else if (arpMode === 'chordN') {
                    currentNoteIndex = Math.floor((previousNoteIndexVal / previousModeNoteList.length) * newModeNoteList.length) % newModeNoteList.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                } else {
                    currentNoteIndex = (previousNoteIndexVal % previousModeNoteList.length) % newModeNoteList.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                }
            } else {
                currentNoteIndex = 0;
            }
        }

        // NoteOn/NoteOff/Add/Remove/GenerateOctave/UpdateHeld/FindOriginal Global functions removed (now in NoteInputManager)


        /** Updates interactive piano key UI */
        function updatePianoUIForNote(note, source) {
            // This function is now primarily called by NoteInputManager
            updatePianoKeyboardUI(note, source);
        }

        function midiNoteToName(note) {
            /* ... unchanged ... */
            const octave = Math.floor(note / 12) - 1;
            const noteName = notes[note % 12];
            return noteName + octave;
        }

        function generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent, isDisabled = false) {
            /* ... unchanged ... */
            if (isDisabled || steps <= 0) return new Array(steps > 0 ? steps : 0).fill(beatEvent);
            beats = Math.min(beats, steps);
            const r = new Array(steps).fill(restEvent);
            let bIdx = 0;
            for (let i = 0; i < steps; i++) {
                if (Math.floor((bIdx * steps) / beats) === i) {
                    r[i] = beatEvent;
                    bIdx++;
                }
            }
            const off = offset % steps;
            const pOff = off >= 0 ? off : steps + off;
            if (pOff > 0) return [...r.slice(steps - pOff), ...r.slice(0, steps - pOff)];
            return r;
        }

        function generateRhythmGateMultipliers(rhythmArray) {
            /* ... unchanged ... */
            const len = rhythmArray.length;
            if (len === 0) return [];
            const mult = new Array(len).fill(0);
            for (let i = 0; i < len; i++) {
                if (rhythmArray[i] === RHYTHM_BEAT) {
                    let steps = 1;
                    let next = (i + 1) % len;
                    while (next !== i && rhythmArray[next] !== RHYTHM_BEAT) {
                        steps++;
                        next = (next + 1) % len;
                    }
                    if (next === i && steps === len && rhythmArray.filter(s => s === RHYTHM_BEAT).length === 1) mult[i] = len;
                    else if (next !== i) mult[i] = steps;
                    else mult[i] = 1;
                }
            }
            return mult;
        }

        function updateRhythmDisplays() {
            /* ... unchanged ... */
            const pS = document.getElementById('patternSteps');
            const pB = document.getElementById('patternBeats');
            const pO = document.getElementById('patternOffset');
            const rS = document.getElementById('rhythmSteps');
            const rB = document.getElementById('rhythmBeats');
            const rO = document.getElementById('rhythmOffset');
            const pSteps = parseInt(pS.value);
            let pBeats = parseInt(pB.value);
            let pOff = parseInt(pO.value);
            pB.max = pSteps;
            if (pBeats > pSteps) {
                pB.value = pSteps;
                pBeats = pSteps;
            }
            const pOffMax = Math.floor(pSteps / 2);
            pO.min = -pOffMax;
            pO.max = pOffMax;
            if (pOff < -pOffMax || pOff > pOffMax) {
                pO.value = 0;
                pOff = 0;
            }
            patternRhythm = generateEuclideanRhythm(pSteps, pBeats, pOff, PATTERN_NOTE, PATTERN_SKIP, isPatternDisabled);
            displayRhythm(patternRhythm, 'patternDisplay', isPatternDisabled);
            document.getElementById('patternStepsValue').textContent = pSteps;
            document.getElementById('patternBeatsValue').textContent = pBeats;
            document.getElementById('patternOffsetValue').textContent = pOff;
            const rSteps = parseInt(rS.value);
            let rBeats = parseInt(rB.value);
            let rOff = parseInt(rO.value);
            rB.max = rSteps;
            if (rBeats > rSteps) {
                rB.value = rSteps;
                rBeats = rSteps;
            }
            const rOffMax = Math.floor(rSteps / 2);
            rO.min = -rOffMax;
            rO.max = rOffMax;
            if (rOff < -rOffMax || rOff > rOffMax) {
                rO.value = 0;
                rOff = 0;
            }
            rhythm = generateEuclideanRhythm(rSteps, rBeats, rOff, RHYTHM_BEAT, RHYTHM_REST, isRhythmDisabled);
            displayRhythm(rhythm, 'rhythmDisplay', isRhythmDisabled);
            document.getElementById('rhythmStepsValue').textContent = rSteps;
            document.getElementById('rhythmBeatsValue').textContent = rBeats;
            document.getElementById('rhythmOffsetValue').textContent = rOff;
            rhythmGateMultipliers = generateRhythmGateMultipliers(rhythm);
            if (!arpRunning) {
                resetRhythmIndex();
                resetPatternIndex();
            }
        }

        function updatePatternControlsState() {
            /* ... unchanged ... */
            const d = isPatternDisabled;
            document.getElementById('patternSteps').disabled = d;
            document.getElementById('patternBeats').disabled = d;
            document.getElementById('patternOffset').disabled = d;
        }

        function updateRhythmControlsState() {
            /* ... unchanged ... */
            const d = isRhythmDisabled;
            document.getElementById('rhythmSteps').disabled = d;
            document.getElementById('rhythmBeats').disabled = d;
            document.getElementById('rhythmOffset').disabled = d;
        }

        function displayRhythm(rhythmArray, displayElementId, isDisabled) {
            /* ... unchanged ... */
            const disp = document.getElementById(displayElementId);
            disp.innerHTML = '';
            if (!rhythmArray || rhythmArray.length === 0) return;
            rhythmArray.forEach((ev, idx) => {
                const el = document.createElement('div');
                el.classList.add('rhythm-step');
                el.innerText = ev;
                el.id = `${displayElementId}-step-${idx}`;
                if (ev === RHYTHM_BEAT) el.classList.add('beat');
                else if (ev === RHYTHM_REST) el.classList.add('rest');
                else if (ev === PATTERN_SKIP) el.classList.add('skip');
                else if (ev === PATTERN_NOTE) el.classList.add('note');
                if (isDisabled) el.classList.add('disabled-step');
                disp.appendChild(el);
            });
        }

        // --- Arpeggio Mode Note List Generators (Use NoteInputManager getters) ---
        function generateAlternatingVariant(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 2) return [...(notes || [])];
            return [...notes, ...[...notes].reverse().slice(1, -1)];
        }

        function generateInclusiveAlternatingVariant(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length === 0) return [];
            return [...notes, ...[...notes].reverse()];
        }

        function generateUpNoteList(notes) {
            /* ... unchanged ... */
            return [...(notes || [])].sort((a, b) => a - b);
        }

        function generateDownNoteList(notes) {
            /* ... unchanged ... */
            return [...(notes || [])].sort((a, b) => b - a);
        }

        function generateUpDownNoteList(notes) {
            return generateAlternatingVariant(generateUpNoteList(notes));
        }

        function generateUpDownInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateUpNoteList(notes));
        }

        function generateConvergeNoteList(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sortedNotes = [...notes].sort((a, b) => a - b);
            const convergeList = [];
            let start = 0;
            let end = sortedNotes.length - 1;
            while (start <= end) {
                convergeList.push(sortedNotes[start]);
                if (start !== end) {
                    convergeList.push(sortedNotes[end]);
                }
                start++;
                end--;
            }
            return convergeList;
        }

        function generateDivergeNoteList(notes) {
            /* ... unchanged ... */
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sortedNotes = [...notes].sort((a, b) => a - b);
            const divergeList = [];
            let start = Math.floor((sortedNotes.length - 1) / 2);
            let end = Math.ceil((sortedNotes.length - 1) / 2);
            while (start >= 0 || end < sortedNotes.length) {
                if (start >= 0) {
                    divergeList.push(sortedNotes[start]);
                }
                if (start !== end && end < sortedNotes.length) {
                    divergeList.push(sortedNotes[end]);
                }
                start--;
                end++;
            }
            return divergeList;
        }

        function generateConvergeDivergeNoteList(notes) {
            return generateAlternatingVariant(generateConvergeNoteList(notes));
        }

        function generateConvergeDivergeInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateConvergeNoteList(notes));
        }
        // *** Refactor: Use NoteInputManager getter ***
        function generatePlayedNoteList(notes) {
            return NoteInputManager.getPlayedNoteOrderFiltered();
        }

        function generateRandomNoteList(notes) {
            return [];
        }

        function generateShuffledNoteList(notes) {
            return [...(notes || [])].sort(() => Math.random() - 0.5);
        }

        function generateStableShuffledNoteList(notes) {
            return stableShuffledOrder;
        }

        function generateChordNoteList(notes) {
            return notes && notes.length > 0 ? [
                [...notes]
            ] : [];
        }

        function generateChordNNoteList(notes, n, orderingMode = 'up') {
            /* ... unchanged ... */
            if (!notes || notes.length === 0 || n <= 0) return [];
            const sortedNotes = [...notes].sort((a, b) => a - b);
            n = Math.min(n, sortedNotes.length);
            const combs = [];

            function cmb(curr, start) {
                if (curr.length === n) {
                    combs.push([...curr]);
                    return;
                }
                if (start >= sortedNotes.length) return;
                for (let i = start; i < sortedNotes.length; i++) {
                    if (curr.length + (sortedNotes.length - i) < n) break;
                    curr.push(sortedNotes[i]);
                    cmb(curr, i + 1);
                    curr.pop();
                }
            }
            cmb([], 0);
            if (combs.length === 0) return [];
            let ord = combs;
            switch (orderingMode) {
                case 'down':
                    ord = [...combs].reverse();
                    break;
                case 'upDown':
                    ord = generateAlternatingVariantCombinations(combs);
                    break;
                case 'upDownInclusive':
                    ord = generateInclusiveAlternatingVariantCombinations(combs);
                    break;
                case 'converge':
                    ord.sort((a, b) => a[0] - b[0]);
                    ord = generateConvergeCombinations(combs);
                    break;
                case 'diverge':
                    ord.sort((a, b) => a[0] - b[0]);
                    ord = generateDivergeCombinations(combs);
                    break;
            }
            return ord;
        }

        function generateAlternatingVariantCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 2) return [...(combinations || [])];
            return [...combinations, ...[...combinations].reverse().slice(1, -1)];
        }

        function generateInclusiveAlternatingVariantCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length === 0) return [];
            return [...combinations, ...[...combinations].reverse()];
        }

        function generateConvergeCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const list = [];
            let s = 0;
            let e = combinations.length - 1;
            while (s <= e) {
                list.push(combinations[s]);
                if (s !== e) list.push(combinations[e]);
                s++;
                e--;
            }
            return list;
        }

        function generateDivergeCombinations(combinations) {
            /* ... unchanged ... */
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const list = [];
            let s = Math.floor((combinations.length - 1) / 2);
            let e = Math.ceil((combinations.length - 1) / 2);
            while (s >= 0 || e < combinations.length) {
                if (s >= 0) list.push(combinations[s]);
                if (s !== e && e < combinations.length) list.push(combinations[e]);
                s--;
                e++;
            }
            return list;
        }

        /** Updates mode note list - Uses NoteInputManager */
        function updateModeNoteList() {
            // *** Refactor: Get notes from NoteInputManager ***
            let notesToArp = NoteInputManager.getHeldNotes(); // Get current octave-expanded notes
            let rawNotes = NoteInputManager.getRawHeldNotes(); // Needed for stable shuffle comparison

            // Check if raw held notes actually changed for stable shuffle regeneration
            if (!arraysAreEqual(rawNotes, lastNotesToArp)) { // Compare raw notes
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5); // Shuffle expanded notes
                // lastNotesToArp is updated in handleNotesChanged now
                if (arpMode === 'stableShuffled' && arpRunning) {
                    stableShuffleIndex = 0; // Reset index on note change if running
                }
            }

            // Generate list based on arpMode and notesToArp (expanded notes)
            switch (arpMode) {
                case 'up':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                case 'down':
                    currentModeNoteList = generateDownNoteList(notesToArp);
                    break;
                case 'upDown':
                    currentModeNoteList = generateUpDownNoteList(notesToArp);
                    break;
                case 'upDownInclusive':
                    currentModeNoteList = generateUpDownInclusiveNoteList(notesToArp);
                    break;
                case 'converge':
                    currentModeNoteList = generateConvergeNoteList(notesToArp);
                    break;
                case 'diverge':
                    currentModeNoteList = generateDivergeNoteList(notesToArp);
                    break;
                case 'convergeDiverge':
                    currentModeNoteList = generateConvergeDivergeNoteList(notesToArp);
                    break;
                case 'convergeDivergeInclusive':
                    currentModeNoteList = generateConvergeDivergeInclusiveNoteList(notesToArp);
                    break;
                case 'played':
                    currentModeNoteList = generatePlayedNoteList(notesToArp);
                    break;
                case 'random':
                    currentModeNoteList = [];
                    break; // Uses notesToArp directly in arpStep
                case 'shuffled':
                    // Regenerate shuffle only if notes changed OR if arp just started/restarted
                    // Note change check done via handleNotesChanged callback now
                    if (!arpRunning || !arraysAreEqual(rawNotes, lastNotesToArp)) {
                        shuffledNotesOrder = generateShuffledNoteList(notesToArp);
                    }
                    currentModeNoteList = shuffledNotesOrder;
                    break;
                case 'stableShuffled':
                    currentModeNoteList = stableShuffledOrder; // Uses order potentially updated above
                    break;
                case 'chord':
                    currentModeNoteList = generateChordNoteList(notesToArp);
                    break;
                case 'chordN':
                    const order = document.getElementById('chordNOrdering').value;
                    currentModeNoteList = generateChordNNoteList(notesToArp, chordNValue, order);
                    break;
                case 'walk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break; // Walk modes use sorted list
                case 'normalWalk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                default:
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
            }
            return currentModeNoteList;
        }


        /** Finds closest note index (unchanged logic, uses list passed to it) */
        function findClosestNoteIndex(noteToFind, oldNoteList, newNoteList, previousIndex) {
            /* ... unchanged ... */
            if (!newNoteList || newNoteList.length === 0) return 0;
            if (arpMode === 'chordN' || arpMode === 'chord') {
                const oldL = oldNoteList?.length || 1;
                const newL = newNoteList.length;
                return Math.floor((previousIndex / oldL) * newL) % newL || 0;
            }
            for (let i = 0; i < newNoteList.length; i++) {
                const curI = (previousIndex + i) % newNoteList.length;
                if (newNoteList[curI] === noteToFind) return curI;
            }
            const first = newNoteList.indexOf(noteToFind);
            if (first !== -1) return first;
            const oldLF = oldNoteList?.length || 1;
            const newLF = newNoteList.length;
            return Math.floor((previousIndex / oldLF) * newLF) % newLF || 0;
        }

        function advanceRhythmIndex(steps = 1) {
            /* ... unchanged ... */
            if (rhythm && rhythm.length > 0) {
                currentRhythmIndex = (currentRhythmIndex + steps) % rhythm.length;
            } else {
                currentRhythmIndex = 0;
            }
        }

        function resetRhythmIndex() {
            /* ... unchanged ... */
            currentRhythmIndex = 0;
        }

        function advancePatternIndex(steps = 1) {
            /* ... unchanged ... */
            if (patternRhythm && patternRhythm.length > 0) {
                currentPatternIndex = (currentPatternIndex + steps) % patternRhythm.length;
            } else {
                currentPatternIndex = 0;
            }
        }

        function resetPatternIndex() {
            /* ... unchanged ... */
            currentPatternIndex = 0;
        }

        function calculateClockDivisionCounterMax(division) {
            /* ... unchanged ... */
            switch (division) {
                case '1/1':
                    return 96;
                case '1/2':
                    return 48;
                case '1/4':
                    return 24;
                case '1/8':
                    return 12;
                case '1/16':
                    return 6;
                case '1/32':
                    return 3;
                case '1/2T':
                    return 32;
                case '1/4T':
                    return 16;
                case '1/8T':
                    return 8;
                case '1/16T':
                    return 4;
                case '1/32T':
                    return 2;
                default:
                    return 24;
            }
        }

        function calculateGateDuration(clockDivisionDurationMs, gateLengthPercent, gateMultiplier = 1) {
            /* ... unchanged ... */
            if (clockDivisionDurationMs <= 0 || gateLengthPercent <= 0) return 5;
            const base = (clockDivisionDurationMs * gateLengthPercent) / 100;
            return Math.max(5, base * gateMultiplier);
        }

        function setupInternalClock() {
            /* ... unchanged ... */
            clearInterval(internalClockInterval);
            if (bpm <= 0) bpm = 1;
            const ticksPerSec = (bpm / 60) * 24;
            const intMs = 1000 / ticksPerSec;
            internalClockInterval = setInterval(tick, intMs);
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            tickCounter = -1;
            clockDivisionDurationMs = intMs * clockDivisionCounterMax;
            updateTempoDisplay();
        }

        /** Starts Arpeggiator - Uses NoteInputManager */
        function startArpeggiator() {
            if (arpRunning) return;
            updateModeNoteList(); // Uses NIM getters
            if (arpMode === 'shuffled') {
                shuffledNotesOrder = generateShuffledNoteList(NoteInputManager.getHeldNotes());
                currentModeNoteList = shuffledNotesOrder;
            }
            arpRunning = true;
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.classList.add('playing');
            stopButton.classList.remove('playing');
            updateRhythmDisplays();
            resetRhythmIndex();
            resetPatternIndex();
            currentNoteIndex = 0;
            stableShuffleIndex = 0;
            if ((arpMode === 'walk' || arpMode === 'normalWalk') && currentModeNoteList && currentModeNoteList.length > 0) {
                currentNoteIndex = Math.floor(currentModeNoteList.length / 2);
            }
            playbackDisplayElem.innerHTML = '';
            ActiveNoteManager.allNotesOff();
            if (tempoSource === 'internal') setupInternalClock();
            else {
                /* ... external clock setup unchanged ... */
                clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
                tickCounter = -1;
                if (bpm > 0) {
                    const avg = 60000 / (bpm * 24);
                    clockDivisionDurationMs = avg * clockDivisionCounterMax;
                } else clockDivisionDurationMs = 0;
                updateTempoDisplay('External MIDI Clock');
            }
        }
        /** Stops Arpeggiator - Uses NoteInputManager */
        function stopArpeggiator() {
            if (!arpRunning) return;
            arpRunning = false;
            if (tempoSource === 'internal') {
                clearInterval(internalClockInterval);
                internalClockInterval = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            stopButton.classList.add('playing');
            startButton.classList.remove('playing');
            ActiveNoteManager.allNotesOff();
            unhighlightCurrentStep();
            unhighlightPlaybackPianoKeys();
        }

        function tick() {
            /* ... unchanged ... */
            if (!arpRunning && tempoSource === 'external') return;
            tickCounter++;
            if (tickCounter >= 0 && (tickCounter % clockDivisionCounterMax === 0)) {
                arpStep();
            }
        }

        function handleMIDITick() {
            /* ... unchanged ... */
            if (tempoSource === 'external') {
                const now = performance.now();
                for (let i = 0; i < tickHistorySize - 1; i++) tickHistory[i] = tickHistory[i + 1];
                tickHistory[tickHistorySize - 1] = now;
                tickIndex++;
                if (tickIndex >= tickHistorySize) {
                    const first = tickHistory[0];
                    const last = tickHistory[tickHistorySize - 1];
                    const dur = last - first;
                    const avg = dur / (tickHistorySize - 1);
                    if (avg > 0) {
                        bpm = Math.round(60000 / (avg * 24));
                        const latest = tickHistory[tickHistorySize - 1] - tickHistory[tickHistorySize - 2];
                        if (latest > 0) clockDivisionDurationMs = latest * clockDivisionCounterMax;
                        else clockDivisionDurationMs = avg * clockDivisionCounterMax;
                        updateTempoDisplay();
                    }
                } else if (tickIndex > 1) {
                    const latest = tickHistory[tickIndex - 1] - tickHistory[tickIndex - 2];
                    if (latest > 0) {
                        bpm = Math.round(60000 / (latest * 24));
                        clockDivisionDurationMs = latest * clockDivisionCounterMax;
                        updateTempoDisplay();
                    }
                }
                tick();
            }
        }


        /** Handles incoming MIDI messages - Calls NoteInputManager handlers */
        function onMIDIMessage(message) {
            const command = message.data[0];
            const commandHiBits = (command & 0xF0) >> 4;
            const commandLoBits = command & 0x0F;
            const byte1 = message.data.length > 1 ? message.data[1] : 0;
            const byte2 = message.data.length > 2 ? message.data[2] : 0;

            // Clock & Transport (unchanged)
            if (command === 0xF8) {
                handleMIDITick();
                return;
            }
            if (command === 0xFA) {
                if (arpSyncMode === 'transport') {
                    resetRhythmIndex();
                    resetPatternIndex();
                    currentNoteIndex = 0;
                    stableShuffleIndex = 0;
                    tickCounter = -1;
                    if (!arpRunning) startArpeggiator();
                }
                return;
            }
            if (command === 0xFC) {
                if (arpSyncMode === 'transport') {
                    if (arpRunning) stopArpeggiator();
                }
                return;
            }
            if (command === 0xFB) {
                if (arpSyncMode === 'transport') {
                    if (!arpRunning) startArpeggiator();
                }
                return;
            }

            // Channel Message Processing (Use MidiManager config check - unchanged)
            let processChannelMessage = false;
            let inputChannel = commandLoBits;
            const mpeInputConfig = MidiManager.getMPEInputConfig();
            const baseOutputChannel = MidiManager.getOutputChannel();
            if (mpeInputConfig.isEnabled) {
                /* ... MPE channel check unchanged ... */
                const glb = mpeInputConfig.globalChannel;
                const vc = mpeInputConfig.voiceChannelCount;
                if (glb === 'omni') processChannelMessage = true;
                else {
                    const gCh = parseInt(glb);
                    if (!isNaN(gCh)) {
                        const baseG = (gCh - 1);
                        if (inputChannel === baseG || (inputChannel > baseG && inputChannel <= baseG + vc)) processChannelMessage = true;
                    }
                }
            } else {
                if (inputChannel === baseOutputChannel) processChannelMessage = true;
            }

            if (processChannelMessage) {
                // *** Refactor: Call NoteInputManager handlers ***
                if (commandHiBits === 0x9) { // Note On
                    const note = byte1;
                    const velocity = byte2;
                    if (velocity > 0) NoteInputManager.handleNoteOn(note, 'midi', inputChannel);
                    else NoteInputManager.handleNoteOff(note, 'midi', inputChannel);
                } else if (commandHiBits === 0x8) { // Note Off
                    const note = byte1;
                    NoteInputManager.handleNoteOff(note, 'midi', inputChannel);
                } else if (commandHiBits === 0xA) { // Poly Aftertouch
                    const note = byte1;
                    const pressure = byte2;
                    // No need to find original note here, handlePressureUpdate expects raw note for poly
                    NoteInputManager.handlePressureUpdate(note, pressure, true);
                } else if (commandHiBits == 0xB) { // CC
                    const ccNumber = byte1;
                    const ccValue = byte2;
                    if (ccNumber === 64) { // Sustain
                        NoteInputManager.handleSustain(ccValue >= 64);
                    } else if (mpeInputConfig.isEnabled && ccNumber == 74) { // MPE Y-Axis/Timbre
                        // Find the raw note associated with this channel first
                        const channelNote = NoteInputManager.getMPEChannelNote(inputChannel);
                        if (channelNote !== null) {
                            NoteInputManager.handleMPEYAxisUpdate(channelNote, ccValue);
                        }
                    }
                } else if (commandHiBits === 0xD) { // Channel Pressure
                    const pressure = byte1;
                    if (mpeInputConfig.isEnabled) {
                        // Find the raw note associated with this channel first
                        const channelNote = NoteInputManager.getMPEChannelNote(inputChannel);
                        if (channelNote !== null) {
                            // Channel pressure applies to the specific note on the channel
                            NoteInputManager.handlePressureUpdate(channelNote, pressure, false); // false = channel pressure
                        }
                    } else {
                        // Non-MPE: Apply pressure to *all* held raw notes on base channel
                        if (inputChannel === baseOutputChannel) {
                            NoteInputManager.getRawHeldNotes().forEach(rawNote => {
                                // Check if it was a MIDI note (not UI) before applying channel pressure
                                // This check might be slightly redundant if rawHeldNotes only contains MIDI notes when non-MPE, but safer.
                                if (_heldNotesMIDI.has(rawNote)) { // Need direct access here, or add getter
                                    NoteInputManager.handlePressureUpdate(rawNote, pressure, false);
                                }
                            });
                        }
                    }
                }
            }
        }


        // FindOriginalNote function removed (now internal to NoteInputManager)

        /** Executes Arp Step - Uses NoteInputManager */
        function arpStep() {
            if (!arpRunning) return;
            unhighlightCurrentStep();

            // Update time held & check limit (uses ActiveNoteManager)
            let notesToStopTimeLimit = [];
            ActiveNoteManager.getActiveNotesMap().forEach((state, note) => {
                /* ... unchanged ... */
                if (state.isExtended && state.noteOffTimeoutId === null) {
                    const newT = state.timeHeldDivisions + 1;
                    ActiveNoteManager.updateNoteState(note, {
                        timeHeldDivisions: newT
                    });
                    if (newT >= maxTimeExtensionDivisions) notesToStopTimeLimit.push(note);
                } else if (!state.isExtended) {
                    if (state.timeHeldDivisions !== 0 || state.chordsHeldCount !== 0) {
                        ActiveNoteManager.updateNoteState(note, {
                            timeHeldDivisions: 0,
                            chordsHeldCount: 0
                        });
                    }
                }
            });
            notesToStopTimeLimit.forEach(note => {
                const state = ActiveNoteManager.getActiveNotesMap().get(note);
                if (state) {
                    ActiveNoteManager.updateNoteState(note, {
                        isExtended: false
                    });
                    ActiveNoteManager.stopNote(note, state.outputChannel);
                }
            });

            // *** Refactor: Get notes from NoteInputManager ***
            let notesToArpSource = NoteInputManager.getHeldNotes();

            // Free sync / Stop check
            if (arpSyncMode === 'free' && notesToArpSource.length === 0) {
                /* ... unchanged ... */
                advanceRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null);
                highlightCurrentStep('rest', null);
                return;
            }
            if (notesToArpSource.length === 0 && arpSyncMode !== 'free') {
                stopArpeggiator();
                return;
            }

            // Shuffle update (driven by handleNotesChanged callback now)

            // Rhythm/Pattern logic (unchanged)
            let noteForStep = '';
            let chordForStep = null;
            let stepType = null;
            let advanceNoteIndices = true;
            const currentRhythmEvent = (rhythm && rhythm.length > 0) ? rhythm[currentRhythmIndex % rhythm.length] : RHYTHM_BEAT;
            const patternEventActive = !isPatternDisabled;
            const rhythmEventActive = !isRhythmDisabled;
            let effectiveRhythmEvent = (rhythmEventActive) ? currentRhythmEvent : RHYTHM_BEAT;

            if (effectiveRhythmEvent === RHYTHM_BEAT) {
                /* ... beat logic unchanged ... */
                let processed = false;
                let iters = 0;
                const maxIters = (patternRhythm?.length || 1) * 2;
                while (!processed && iters < maxIters) {
                    const pEv = (patternRhythm && patternRhythm.length > 0) ? patternRhythm[currentPatternIndex % patternRhythm.length] : PATTERN_NOTE;
                    const effPEv = patternEventActive ? pEv : PATTERN_NOTE;
                    if (effPEv === PATTERN_NOTE) {
                        chordForStep = null;
                        noteForStep = '';
                        if (arpMode === 'chord' || arpMode === 'chordN') {
                            /*...*/
                            if (currentModeNoteList && currentModeNoteList.length > 0) {
                                const idx = currentNoteIndex % currentModeNoteList.length;
                                chordForStep = currentModeNoteList[idx];
                                if (chordForStep && chordForStep.length > 0) {
                                    playNotes(chordForStep, subArpMode);
                                    stepType = 'note';
                                    highlightCurrentStep('note', chordForStep, true);
                                } else {
                                    stepType = 'rest';
                                    highlightCurrentStep('rest', null);
                                    advanceNoteIndices = false;
                                }
                            } else {
                                stepType = 'rest';
                                highlightCurrentStep('rest', null);
                                advanceNoteIndices = false;
                            }
                        } else if (arpMode === 'random') {
                            if (notesToArpSource.length > 0) noteForStep = notesToArpSource[Math.floor(Math.random() * notesToArpSource.length)];
                            else advanceNoteIndices = false;
                        } else if (arpMode === 'walk' || arpMode === 'normalWalk') {
                            if (currentModeNoteList && currentModeNoteList.length > 0) noteForStep = currentModeNoteList[currentNoteIndex % currentModeNoteList.length];
                            else advanceNoteIndices = false;
                        } else {
                            if (currentModeNoteList && currentModeNoteList.length > 0) noteForStep = currentModeNoteList[currentNoteIndex % currentModeNoteList.length];
                            else advanceNoteIndices = false;
                        }
                        if (noteForStep !== '' && arpMode !== 'chord' && arpMode !== 'chordN') {
                            playNotes(noteForStep);
                            stepType = 'note';
                            highlightCurrentStep('note', noteForStep);
                        } else if (stepType !== 'note' && stepType !== 'rest') {
                            stepType = 'rest';
                            highlightCurrentStep('rest', null);
                            advanceNoteIndices = false;
                        }
                        processed = true;
                        advancePatternIndex();
                    } else if (effPEv === PATTERN_SKIP) {
                        /*...*/
                        advancePatternIndex();
                        if (arpMode !== 'random' && arpMode !== 'walk' && arpMode !== 'normalWalk') {
                            currentNoteIndex++;
                            if (arpMode === 'stableShuffled') stableShuffleIndex++;
                        }
                        stepType = 'skip';
                        iters++;
                    } else {
                        console.error("Unknown pattern:", pEv);
                        stepType = 'error';
                        processed = true;
                        advancePatternIndex();
                        advanceNoteIndices = false;
                    }
                    if (iters >= maxIters && !processed) {
                        console.warn("Pattern loop limit");
                        stepType = 'rest';
                        advanceNoteIndices = false;
                        processed = true;
                    }
                }
            } else if (effectiveRhythmEvent === RHYTHM_REST) {
                /* ... rest logic unchanged ... */
                stepType = 'rest';
                highlightCurrentStep('rest', null);
                advanceNoteIndices = false;
            } else {
                console.error("Unknown rhythm:", currentRhythmEvent);
                stepType = 'error_arp_rhythm';
                highlightCurrentStep('error', null);
                advanceNoteIndices = false;
            }

            // Update Playback Display (unchanged)
            if (stepType !== null) {
                let noteToDisp = null;
                let isChordDisp = (stepType === 'note' && !!chordForStep);
                if (stepType === 'note' && !isChordDisp) noteToDisp = noteForStep;
                updatePlaybackDisplay(stepType, noteToDisp, isChordDisp);
            }

            // Advance Indices (unchanged)
            advanceRhythmIndex();
            if (advanceNoteIndices) {
                if (arpMode === 'walk') advanceWalkIndex();
                else if (arpMode === 'normalWalk') advanceNormalWalkIndex();
                else if (arpMode === 'stableShuffled') {
                    stableShuffleIndex++;
                    if (stableShuffledOrder && stableShuffledOrder.length > 0) stableShuffleIndex %= stableShuffledOrder.length;
                    else stableShuffleIndex = 0;
                } else if (arpMode !== 'random') {
                    currentNoteIndex++;
                    if (currentModeNoteList && currentModeNoteList.length > 0) currentNoteIndex %= currentModeNoteList.length;
                    else currentNoteIndex = 0;
                }
            }
        }


        function calculateVelocity(pressure) {
            /* ... unchanged ... */
            pressure = Math.max(0, Math.min(127, pressure || 0));
            let vel = baseVelocityValue + (maxVelocityValue - baseVelocityValue) * (pressure / 127);
            return Math.max(1, Math.min(127, Math.round(vel)));
        }

        function findNextPlayedChordInfo(maxLookahead = LOOKAHEAD_MAX_STEPS) {
            /* ... unchanged ... */
            if (arpMode !== 'chordN' || !currentModeNoteList || currentModeNoteList.length === 0) return {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: 0
            };
            let simR = currentRhythmIndex;
            let simP = currentPatternIndex;
            let simC = currentNoteIndex;
            let steps = 0;
            for (let i = 0; i < maxLookahead; i++) {
                steps++;
                simR = (simR + 1) % (rhythm?.length || 1);
                const rE = (rhythm && rhythm.length > 0 && !isRhythmDisabled) ? rhythm[simR] : RHYTHM_BEAT;
                if (rE === RHYTHM_BEAT) {
                    simP = (simP + 1) % (patternRhythm?.length || 1);
                    const pE = (patternRhythm && patternRhythm.length > 0 && !isPatternDisabled) ? patternRhythm[simP] : PATTERN_NOTE;
                    if (pE === PATTERN_NOTE) {
                        simC = (simC + 1) % currentModeNoteList.length;
                        return {
                            nextChordIndex: simC,
                            nextChordNotes: currentModeNoteList[simC],
                            stepsToNextChord: steps
                        };
                    } else if (pE === PATTERN_SKIP) {
                        simC = (simC + 1) % currentModeNoteList.length;
                    }
                }
            }
            return {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: steps
            };
        }

        /** Plays notes - Uses NoteInputManager and ActiveNoteManager */
        function playNotes(notesOrChord, subArpModeOverride = subArpMode) {
            const outputChannel = MidiManager.getOutputChannel();
            const notesArray = Array.isArray(notesOrChord) ? notesOrChord : [notesOrChord];
            if (notesArray.length === 0) return;

            const isChordModeActive = arpMode === 'chord' || arpMode === 'chordN';
            const useSubArp = isChordModeActive && notesArray.length > 1 && subArpScalePercentage > 0;
            let nextPlayedInfo = {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: 0
            };
            if (arpMode === 'chordN') nextPlayedInfo = findNextPlayedChordInfo();
            const currentGateMultiplier = (isGateFlexEnabled && rhythmGateMultipliers && rhythm.length > 0) ? (rhythmGateMultipliers[currentRhythmIndex % rhythm.length] || 1) : 1;

            if (useSubArp) {
                /* ... sub arp logic unchanged, uses ActiveNoteManager ... */
                const subDur = (clockDivisionDurationMs * subArpScalePercentage) / 100;
                const spacing = notesArray.length > 1 ? subDur / notesArray.length : 0;
                let subNotes = [...notesArray];
                switch (subArpModeOverride) {
                    case 'up':
                        subNotes.sort((a, b) => a - b);
                        break;
                    case 'down':
                        subNotes.sort((a, b) => b - a);
                        break;
                    case 'random':
                        subNotes.sort(() => Math.random() - 0.5);
                        break;
                    case 'converge':
                        subNotes = generateConvergeNoteList(subNotes);
                        break;
                    case 'diverge':
                        subNotes = generateDivergeNoteList(subNotes);
                        break;
                    default:
                        subNotes.sort((a, b) => a - b);
                        break;
                }
                subNotes.forEach((expNote, index) => {
                    const origNote = NoteInputManager.findOriginalNote(expNote);
                    if (origNote === null) return;
                    const press = NoteInputManager.getNotePressure(origNote);
                    const vel = calculateVelocity(press);
                    const delay = spacing * index;
                    setTimeout(() => {
                        const isActive = ActiveNoteManager.hasNote(expNote);
                        const state = isActive ? ActiveNoteManager.getActiveNotesMap().get(expNote) : null;
                        const isExt = isActive && state && state.isExtended;
                        if (!isExt) {
                            ActiveNoteManager.startNote(expNote, vel, outputChannel);
                            const subGateDur = calculateGateDuration(spacing > 0 ? spacing : clockDivisionDurationMs, gateLengthPercentage, 1);
                            ActiveNoteManager.scheduleNoteOff(expNote, subGateDur, outputChannel);
                        }
                    }, delay);
                });
            } else {
                /* ... simultaneous play logic unchanged, uses ActiveNoteManager & NoteInputManager ... */
                notesArray.forEach(expNote => {
                    const origNote = NoteInputManager.findOriginalNote(expNote);
                    if (origNote === null) return;
                    const press = NoteInputManager.getNotePressure(origNote);
                    const vel = calculateVelocity(press);
                    const isActive = ActiveNoteManager.hasNote(expNote);
                    const state = isActive ? ActiveNoteManager.getActiveNotesMap().get(expNote) : null;
                    const isInNext = (arpMode === 'chordN' && nextPlayedInfo.nextChordNotes?.includes(expNote));
                    if (isActive && state) {
                        ActiveNoteManager.cancelNoteOff(expNote);
                        const canContCount = state.chordsHeldCount < (maxChordExtension - 1);
                        const estTime = state.timeHeldDivisions + nextPlayedInfo.stepsToNextChord;
                        const canContTime = estTime <= maxTimeExtensionDivisions;
                        const contExt = arpMode === 'chordN' && isInNext && canContCount && canContTime;
                        if (contExt) {
                            ActiveNoteManager.updateNoteState(expNote, {
                                isExtended: true,
                                chordsHeldCount: state.chordsHeldCount + 1,
                                noteOffTimeoutId: null
                            });
                        } else {
                            ActiveNoteManager.updateNoteState(expNote, {
                                isExtended: false,
                                chordsHeldCount: 0
                            });
                            const gateDur = calculateGateDuration(clockDivisionDurationMs, gateLengthPercentage, currentGateMultiplier);
                            ActiveNoteManager.scheduleNoteOff(expNote, gateDur, outputChannel);
                        }
                    } else {
                        const canStartExt = maxChordExtension > 1;
                        const canStartTime = nextPlayedInfo.stepsToNextChord <= maxTimeExtensionDivisions;
                        const startExt = arpMode === 'chordN' && isInNext && canStartExt && canStartTime;
                        ActiveNoteManager.startNote(expNote, vel, outputChannel);
                        const newState = ActiveNoteManager.getActiveNotesMap().get(expNote);
                        if (startExt && newState) {
                            ActiveNoteManager.updateNoteState(expNote, {
                                isExtended: true,
                                chordsHeldCount: 1,
                                timeHeldDivisions: 0,
                                noteOffTimeoutId: null
                            });
                        } else if (newState) {
                            const gateDur = calculateGateDuration(clockDivisionDurationMs, gateLengthPercentage, currentGateMultiplier);
                            ActiveNoteManager.scheduleNoteOff(expNote, gateDur, outputChannel);
                        }
                    }
                });
            }
        }


        function updatePlaybackDisplay(stepType, note, isChord = false) {
            /* ... unchanged ... */
            if (stepType === null) return;
            const el = document.createElement('div');
            el.classList.add('playback-step');
            el.classList.add(stepType);
            if (stepType === 'note') {
                if (isChord) {
                    if (arpMode === 'chordN' && currentModeNoteList && currentModeNoteList.length > 0) {
                        const dIdx = (currentNoteIndex % currentModeNoteList.length) + 1;
                        el.textContent = `Ch${dIdx}`;
                    } else {
                        el.textContent = 'Ch';
                    }
                } else if (note !== null) {
                    el.textContent = midiNoteToName(note);
                } else {
                    el.textContent = '?';
                }
            } else if (stepType === 'rest') {
                el.textContent = 'R';
            } else if (stepType === 'skip') {
                el.textContent = 'S';
            } else if (stepType === 'error') {
                el.textContent = '!';
            }
            playbackDisplayElem.appendChild(el);
            while (playbackDisplayElem.children.length > maxPlaybackSteps) {
                playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            }
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        function generatePianoKeyboardUI() {
            /* ... unchanged, calls NoteInputManager.handleNoteOn */
            const pk = document.getElementById('pianoKeyboard');
            pk.innerHTML = '';
            const sN = 48;
            const nK = 25;
            for (let i = 0; i < nK; i++) {
                const nV = sN + i;
                if (nV > 127) break;
                const nN = notes[nV % 12];
                const key = document.createElement('div');
                key.classList.add('key');
                key.dataset.note = nV;
                key.title = midiNoteToName(nV);
                key.id = `pianoKey-${nV}`;
                if (nN.includes('#')) key.classList.add('black-key');
                else key.classList.add('white-key');
                key.addEventListener('click', function() {
                    NoteInputManager.handleNoteOn(nV, 'ui');
                });
                pk.appendChild(key);
            }
        }

        /** Updates interactive piano key UI - Uses NoteInputManager getters */
        function updatePianoKeyboardUI(note, source) {
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (!keyElement) return;
            keyElement.classList.remove('key-held-ui', 'key-held-midi', 'key-current');

            // *** Refactor: Check state via NoteInputManager (though it tells us via callback too) ***
            // This function is now mainly for reacting to calls *from* NoteInputManager
            // or for highlighting the 'current' arp note.
            if (source === 'ui' && NoteInputManager.getRawHeldNotes().includes(note)) { // Check raw notes for UI holds
                keyElement.classList.add('key-held-ui');
            } else if (source === 'midi' && NoteInputManager.getRawHeldNotes().includes(note)) { // Check raw notes for MIDI holds
                keyElement.classList.add('key-held-midi');
            } else if (source === null && !NoteInputManager.getRawHeldNotes().includes(note)) {
                // Explicitly removing highlight if source is null (e.g., note off)
            }
        }

        function highlightPianoKeys(notesToHighlight) {
            /* ... unchanged ... */
            unhighlightPianoKeys();
            if (!notesToHighlight) return;
            const arr = Array.isArray(notesToHighlight) ? notesToHighlight : [notesToHighlight];
            if (arr.length > 0) {
                arr.forEach(n => {
                    const k = document.getElementById(`pianoKey-${n}`);
                    if (k) k.classList.add('key-current');
                });
                highlightedPianoKey = arr[0];
            }
        }

        function unhighlightPianoKeys() {
            /* ... unchanged ... */
            const cur = document.querySelectorAll('#pianoKeyboard .key.key-current');
            cur.forEach(k => k.classList.remove('key-current'));
            highlightedPianoKey = null;
        }

        function highlightRhythmStep(displayElementId, stepIndex, gateExtension = 0) {
            /* ... unchanged ... */
            unhighlightRhythmStep(displayElementId);
            const rLen = (displayElementId === 'patternDisplay' ? patternRhythm?.length : rhythm?.length) || 0;
            if (rLen === 0) return;
            const idx = stepIndex % rLen;
            const el = document.getElementById(`${displayElementId}-step-${idx}`);
            if (el) {
                el.classList.add('current-step');
                if (isGateFlexEnabled && displayElementId === 'rhythmDisplay' && gateExtension > 1) {
                    for (let i = 1; i < gateExtension; i++) {
                        const extIdx = (idx + i) % rLen;
                        const extEl = document.getElementById(`${displayElementId}-step-${extIdx}`);
                        if (extEl) extEl.classList.add('gate-extended-step');
                    }
                }
            }
        }

        function unhighlightRhythmStep(displayElementId) {
            /* ... unchanged ... */
            const cur = document.querySelector(`#${displayElementId} .current-step`);
            if (cur) cur.classList.remove('current-step');
            if (displayElementId === 'rhythmDisplay') {
                const ext = document.querySelectorAll('#rhythmDisplay .rhythm-step.gate-extended-step');
                ext.forEach(s => s.classList.remove('gate-extended-step'));
            }
        }

        function highlightCurrentPatternStep() {
            /* ... unchanged ... */
            if (!isPatternDisabled && patternRhythm && patternRhythm.length > 0) highlightRhythmStep('patternDisplay', currentPatternIndex % patternRhythm.length);
            else unhighlightRhythmStep('patternDisplay');
        }

        function highlightCurrentArpRhythmStep() {
            /* ... unchanged ... */
            if (!isRhythmDisabled && rhythm && rhythm.length > 0) {
                const idx = currentRhythmIndex % rhythm.length;
                const ext = (isGateFlexEnabled && rhythmGateMultipliers && rhythmGateMultipliers.length > idx) ? rhythmGateMultipliers[idx] : 0;
                highlightRhythmStep('rhythmDisplay', idx, ext);
            } else unhighlightRhythmStep('rhythmDisplay');
        }

        function unhighlightCurrentStep() {
            /* ... unchanged ... */
            unhighlightRhythmStep('patternDisplay');
            unhighlightRhythmStep('rhythmDisplay');
            unhighlightPianoKeys();
        }

        function highlightCurrentStep(stepType, noteOrChord, isChord = false) {
            /* ... unchanged ... */
            unhighlightPianoKeys();
            highlightCurrentArpRhythmStep();
            highlightCurrentPatternStep();
            if (stepType === 'note') {
                if (isChord && noteOrChord) highlightPianoKeys(noteOrChord);
                else if (!isChord && noteOrChord !== null) highlightPianoKeys(noteOrChord);
            }
        }

        function generatePlaybackPianoKeyboardUI() {
            /* ... unchanged ... */
            const pk = document.getElementById('playbackKeyboardDisplay');
            pk.innerHTML = '';
            const sN = 36;
            const nK = 61;
            for (let i = 0; i < nK; i++) {
                const nV = sN + i;
                if (nV > 127) break;
                const nN = notes[nV % 12];
                const key = document.createElement('div');
                key.classList.add('playback-key');
                key.dataset.note = nV;
                key.id = `playbackKey-${nV}`;
                if (nN && nN.includes('#')) key.classList.add('playback-black-key');
                else key.classList.add('playback-white-key');
                pk.appendChild(key);
            }
        }

        /** Updates playback keyboard UI - Uses NoteInputManager */
        function updatePlaybackKeyboardUI() {
            const playbackKeys = document.querySelectorAll('.playback-key');
            playbackKeys.forEach(key => {
                const note = parseInt(key.dataset.note);
                updatePlaybackKeyboardKey(note); // Update each key's state based on NIM/ANM
            });
        }

        /** Updates playback keyboard key - Uses NoteInputManager & ActiveNoteManager */
        function updatePlaybackKeyboardKey(note) {
            const keyElement = document.getElementById(`playbackKey-${note}`);
            if (!keyElement) return;

            // *** Refactor: Get held status from NoteInputManager ***
            const rawNotes = NoteInputManager.getRawHeldNotes();
            const heldNotesExpanded = NoteInputManager.getHeldNotes(); // Expanded list
            const isHeldUI = NoteInputManager.hasHeldUINote(note); // Need direct access or getter if moving sets
            const isHeldMIDI = NoteInputManager.hasHeldMIDINote(note); // Need direct access or getter if moving sets
            const isHeldOctave = heldNotesExpanded.includes(note) && !rawNotes.includes(note);

            // Get playing status from ActiveNoteManager
            const isActiveArp = ActiveNoteManager.hasNote(note);
            const arpNoteState = isActiveArp ? ActiveNoteManager.getActiveNotesMap().get(note) : null;
            const isGateExtended = isActiveArp && arpNoteState && arpNoteState.isExtended;

            keyElement.classList.remove('key-held-ui', 'key-held-midi', 'key-held-octave-expanded', 'key-current', 'key-gate-extended');
            if (isGateExtended) keyElement.classList.add('key-gate-extended');
            else if (isActiveArp) keyElement.classList.add('key-current');
            else if (isHeldUI) keyElement.classList.add('key-held-ui'); // Check raw note for UI
            else if (isHeldMIDI) keyElement.classList.add('key-held-midi'); // Check raw note for MIDI
            else if (isHeldOctave) keyElement.classList.add('key-held-octave-expanded');
        }

        function unhighlightPlaybackPianoKeys() {
            /* ... unchanged ... */
            const cur = document.querySelectorAll('#playbackKeyboardDisplay .playback-key.key-current, #playbackKeyboardDisplay .playback-key.key-gate-extended');
            cur.forEach(k => {
                k.classList.remove('key-current', 'key-gate-extended');
                updatePlaybackKeyboardKey(parseInt(k.dataset.note));
            });
        }

        function unhighlightPlaybackPianoKeysAll() {
            updatePlaybackKeyboardUI();
        }

        // --- WALK MODE FUNCTIONS (unchanged) ---
        function advanceWalkIndex() {
            /* ... unchanged ... */
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const p = calculateWalkProbabilities(walkSkew);
                const r = Math.random();
                if (r < p.prev) currentNoteIndex = (currentNoteIndex - 1 + currentModeNoteList.length) % currentModeNoteList.length;
                else if (r >= p.prev + p.current) currentNoteIndex = (currentNoteIndex + 1) % currentModeNoteList.length;
            }
        }

        function calculateWalkProbabilities(skew) {
            /* ... unchanged ... */
            skew = Math.max(-1, Math.min(1, skew));
            let pn, pc, pv;
            pv = Math.max(0, (1 / 3) * (1 - skew));
            pn = Math.max(0, (1 / 3) * (1 + skew));
            pc = Math.max(0, 1 - pv - pn);
            const t = pv + pc + pn;
            if (t > 0) {
                pv /= t;
                pc /= t;
                pn /= t;
            } else {
                pv = 1 / 3;
                pc = 1 / 3;
                pn = 1 / 3;
            }
            return {
                next: pn,
                current: pc,
                prev: pv
            };
        }

        function advanceNormalWalkIndex() {
            /* ... unchanged ... */
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const sig = 0.3 + walkDistance * 2;
                const mu = walkSkew * (currentModeNoteList.length / 4);
                const step = sampleNormalDistribution(mu, sig);
                const maxS = Math.ceil(currentModeNoteList.length / 2);
                const clampS = Math.max(-maxS, Math.min(maxS, Math.round(step)));
                currentNoteIndex = (currentNoteIndex + clampS + currentModeNoteList.length) % currentModeNoteList.length;
            }
        }

        function sampleNormalDistribution(mu, sigma) {
            /* ... unchanged ... */
            let u1 = 0,
                u2 = 0;
            while (u1 === 0) u1 = Math.random();
            while (u2 === 0) u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * sigma + mu;
        }

        // --- Initialization ---
        generatePianoKeyboardUI(); // Uses NoteInputManager.handleNoteOn internally now
        generatePlaybackPianoKeyboardUI();
        updateRhythmDisplays();
        // updateModeNoteList(); // Called within handleNotesChanged initial call
        // Update initial UI display values (unchanged)
        document.getElementById('chordNValueDisplay').textContent = chordNValue;
        document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        updateTempoDisplay();
        updatePatternControlsState();
        updateRhythmControlsState();

        // Initialize Managers
        ActiveNoteManager.initialize({
            updatePlaybackKeyCallback: updatePlaybackKeyboardKey,
            getMPEOutputMode: MidiManager.isMPEOutput
        });
        NoteInputManager.initialize({
            onNotesChanged: handleNotesChanged,
            getMPEInputConfig: MidiManager.getMPEInputConfig,
            updatePianoKeyCallback: updatePianoKeyboardUI, // Pass UI update fn
            updatePlaybackKeyboardCallback: updatePlaybackKeyboardUI // Pass playback update fn
        });
        MidiManager.initialize(midiManagerCallbacks); // Start MIDI

        // Trigger initial update based on default state
        handleNotesChanged(NoteInputManager.getHeldNotes(), NoteInputManager.getRawHeldNotes(), NoteInputManager.getPlayedNoteOrderFiltered());
        lastNotesToArp = NoteInputManager.getRawHeldNotes(); // Initialize lastNotesToArp
    </script>
</body>
</html>
