<html>
<head>
    <title>MPE Euclidean Arpeggiator</title>
    <style>
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step {
            width: 25px; /* Slightly wider steps for better visual clarity */
            height: 25px; /* Slightly taller steps for better visual clarity */
            border: 1px solid #ccc; /* Reduced border weight */
            text-align: center;
            line-height: 25px; /* Match line-height to height */
            font-size: 12px;
            margin-right: 2px; /* Add spacing between steps */
            border-radius: 3px; /* Slightly rounded corners for a softer look */
            background-color: #f0f0f0; /* Default step background color */
            color: #333; /* Darker text for better contrast */
        }
        .rhythm-step.beat { background-color: #b2f0b2; border-color: #8fcc8f; color: #005000; /* Muted green for beats */ }
        .rhythm-step.rest { background-color: #f0b2b2; border-color: #cc8f8f; color: #500000; /* Muted red for rests */ }
        .rhythm-step.skip { background-color: #b2b2f0; border-color: #8f8fcc; color: #000050; /* Muted blue for skips */ }
        .rhythm-step.note { background-color: #f0f0b2; border-color: #ccf08f; color: #505000; /* Muted yellow for notes */ }
        .rhythm-step.current-step { border: 2px solid blue; /* Stronger current step highlight */ }
        .rhythm-step.disabled-step {
            background-color: #e0e0e0; /* Greyed out background */
            border-color: #bbb;       /* Lighter border */
            color: #999;              /* Lighter text color */
        }
        .rhythm-step.gate-extended-step {
            background-color: #cceeff; /* Light blue for gate extension */
            border-color: #aaccdd;
        }


        .parameter-group { margin-bottom: 10px; border: 1px solid #ccc; padding: 10px; border-radius: 5px; /* Added border and padding to parameter groups */ background-color: #fafafa; /* Lighter background for parameter groups */ }
        .parameter-group h3 { margin-top: 0; color: #555; /* Slightly darker heading text */ }
        .note-selector { margin-bottom: 10px; }
        .piano-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; /* Added border to keyboard */ }
        .key {
            height: 80px;
            border-left: 1px solid #ddd; /* Lighter key borders */
            border-bottom: 1px solid #bbb; /* Slightly darker bottom border for depth */
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            user-select: none; /* Prevent text selection on click */
            transition: background-color 0.1s ease; /* Smooth background color transition */
        }
        .white-key {
            width: 30px;
            background-color: white;
            color: black;
        }
        .black-key {
            width: 20px;
            background-color: black;
            color: white;
            height: 55px;
            margin-left: -10px;
            margin-right: -10px;
            z-index: 1; /* Ensure black keys are on top */
            border-bottom: 1px solid #333; /* Darker bottom border for black keys */
        }
        .key.key-held-ui {
            background-color: #aaddff; /* Distinct light blue for UI held keys */
            color: black; /* Ensure text is readable on highlight */
            border-bottom: unset;
        }
        .key.key-held-midi {
            background-color: #aaffaa; /* Distinct light green for MIDI held keys */
            color: black; /* Ensure text is readable on highlight */
            border-bottom: unset;
        }
        .key.key-current {
            border: 2px solid #ccc; /* Example highlight style */
            background-color: #ffddaa; /* Softer yellow for current note highlight */
            border-bottom: unset;
        }

        .playback-keyboard-container { display: flex; justify-content: center; margin-bottom: 10px; } /* Center the playback keyboard */
        .playback-keyboard { display: flex; border: 1px solid #aaa; border-radius: 5px; overflow: hidden; width: 600px; height: 40px; /* Fixed width and height for mini keyboard */ }
        .playback-key {
            height: 100%; /* Keys fill the height of the playback keyboard */
            border-left: 1px solid #ddd;
            border-bottom: 1px solid #bbb;
            box-sizing: border-box;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 2px; /* Reduced padding */
            font-size: 8px; /* Smaller font size */
            user-select: none;
            transition: background-color 0.1s ease;
            cursor: default; /* Non-interactive cursor */
        }
        .playback-white-key {
            width: calc(600px / 25 * 3/5); /* Adjust width based on total width and number of keys */
            background-color: white;
            color: black;
        }
        .playback-black-key {
            width: calc(600px / 25 * 2/5); /* Adjust width based on total width and number of keys */
            background-color: black;
            color: white;
            height: 70%; /* Black keys are shorter */
            margin-left: calc(-600px / 25 * 1/5);
            margin-right: calc(-600px / 25 * 1/5);
            z-index: 1;
            border-bottom: 1px solid #333;
        }
        .playback-key.key-held-ui { /* Style for UI held notes on playback keyboard */
            background-color: #99ccee; /* Lighter shade of blue */
            border-bottom: unset;
        }
        .playback-key.key-held-midi { /* Style for MIDI held notes on playback keyboard */
            background-color: #ccffcc; /* Lighter shade of green */
            border-bottom: unset;
        }
        .playback-key.key-held-octave-expanded { /* New style for octave-expanded notes */
            background-color: #cceeff; /* A very light blue/grey, less prominent than UI/MIDI held */
            color: black; /* Ensure text is readable if you decide to add text to these keys */
            border-bottom: unset;
        }
        .playback-key.key-current { /* Style for currently playing notes on playback keyboard */
            background-color: #ffddaa; /* Very light yellow */
            border: 1px solid #ccc; /* Add border to current key on playback keyboard */
            border-bottom: unset;
        }
        /* Style for ChordN gate extended notes on playback keyboard */
        .playback-key.key-gate-extended {
            background-color: #ffddee; /* Light pink/purple to indicate held */
            border-bottom: unset;
        }

        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; background-color: #eee; border-radius: 3px; /* Added background and border-radius to playback display */ padding-left: 5px; }
        .playback-step {
            width: 20px;
            height: 20px;
            border: 1px solid #ddd; /* Lighter border for playback steps */
            margin-right: 2px;
            text-align: center;
            line-height: 20px;
            font-size: 10px;
            border-radius: 2px; /* Slightly rounded corners for playback steps */
            background-color: #fff; /* Default playback step background */
        }
        .playback-step.note { background-color: #ffffdd; /* Light yellow for note playback */ }
        .playback-step.rest { background-color: #ffdddd; /* Light red for rest playback */ }
        .playback-step.skip { background-color: #ddddff; /* Light blue for skip playback */ }
        .device-selector { margin-bottom: 10px; }
        .slider-container {
            display: flex;
            align-items: center; /* Vertically align label and slider */
            margin-bottom: 5px; /* Add spacing between slider containers */
        }
        .slider-container label {
            margin-right: 10px; /* Space between label and slider */
            width: 120px; /* Wider fixed width for labels to align them */
            text-align: right; /* Right-align label text */
            font-size: 0.9em; /* Slightly smaller label font size */
            color: #666; /* Muted label color */
        }
        .slider-container input[type="range"] {
            width: 300px; /* Adjust slider width as needed */
        }
        .number-display {
            width: 30px; /* Fixed width for number display */
            text-align: center;
            margin-left: 5px;
            font-size: 0.9em; /* Slightly smaller number display font size */
            color: #777; /* Muted number display color */
        }

        #tempoBPM { /* Tempo BPM input now serves as display as well */
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            font-size: 1.2em; /* Larger tempo display */
            color: #333; /* Darker tempo text */
            border: none; /* Remove border */
            background-color: transparent; /* Make background transparent */
            width: auto; /* Adjust width to content */
            padding: 0; /* Remove padding */
            text-align: left; /* Align text left */
        }
        #tempoBPM:read-only { /* Style for read-only state */
            cursor: default; /* Default cursor for read-only */
            color: #777; /* Muted color when read-only */
            font-weight: normal; /* Normal font weight when read-only */
        }

        #midiStatus {
            margin-bottom: 10px;
            font-size: 0.9em;
            color: #777;
        }
        h1 {
            color: #333;
            border-bottom: 2px solid #ddd;
            padding-bottom: 5px;
        }
        h3 {
            margin-top: 0;
            color: #555;
        }
        label {
            font-size: 0.95em;
            color: #444;
            margin-right: 5px;
        }
        select, input[type="number"], input[type="range"], button, input[type="checkbox"] {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        button {
            background-color: #eee;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        button:hover {
            background-color: #ddd;
        }
        button:disabled {
            background-color: #f0f0f0;
            color: #999;
            cursor: default;
        }
        #startButton.playing {
            background-color: lightgreen;
        }
        #stopButton.playing {
            background-color: lightcoral;
        }

        /* --- TAB STYLES --- */
        .tab-container {
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow: hidden;
            background-color: #fafafa;
            margin-bottom: 10px;
        }

        .tab-buttons {
            display: flex;
            background-color: #eee;
            border-bottom: 1px solid #ccc;
        }

        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            border-right: 1px solid #ccc;
            font-size: 0.9em;
            color: #555;
        }

        .tab-button:last-child {
            border-right: none;
        }

        .tab-button.active {
            background-color: #fafafa;
            color: #333;
            font-weight: bold;
        }

        .tab-content {
            padding: 10px;
        }

        .tab-pane {
            display: none; /* Initially hide all tab panes */
        }

        .tab-pane.active {
            display: block; /* Show active tab pane */
        }
    </style>
</head>
<body>
    <h1>MPE Euclidean Arpeggiator</h1>

    <div class="note-selector" title="Use this keyboard to select notes with the mouse.">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
        </div>
    </div>

    <div class="tab-container">
        <div class="tab-buttons">
            <button class="tab-button active" data-tab="midi-mpe-tab">MIDI & MPE</button>
            <button class="tab-button" data-tab="pattern-tab">Pattern</button>
            <button class="tab-button" data-tab="rhythm-tab">Rhythm</button>
            <button class="tab-button" data-tab="arp-tab">Arp</button>
        </div>

        <div id="midi-mpe-tab" class="tab-content tab-pane active">
            <fieldset class="parameter-group">
                <legend><h3>MIDI & MPE Settings</h3></legend>

			    <div id="midiStatus">MIDI Status: Not connected</div>

			    <div class="device-selector" title="Select your MIDI input device.">
			        <label for="midiInputSelect">MIDI Input:</label>
			        <select id="midiInputSelect" title="Choose the MIDI input device to receive notes and clock from.">
			            <option value="">No input device selected</option>
			        </select>
			    </div>

			    <div class="device-selector" title="Select your MIDI output device.">
			        <label for="midiOutputSelect">MIDI Output:</label>
			        <select id="midiOutputSelect" title="Choose the MIDI output device to send arpeggiated notes to.">
			            <option value="">No output device selected</option>
			        </select>
			    </div>

                <div class="slider-container" title="Source of tempo: internal BPM or external MIDI clock.">
                    <label for="tempoSource">Tempo Source:</label>
                    <select id="tempoSource" title="Choose whether the tempo is controlled internally or by external MIDI clock.">
                        <option value="internal">Internal</option>
                        <option value="external">External MIDI Clock</option>
                    </select>
                </div>

                <div class="slider-container" title="Tempo in Beats Per Minute (BPM). Only active when Tempo Source is Internal.">
                    <label for="tempoBPM">Tempo:</label>
                    <input type="number" id="tempoBPM" value="120" min="10" max="300" title="Set the tempo in BPM for internal clock.">
                </div>

                <div class="slider-container" title="Enable or disable MPE input processing.">
                    <input type="checkbox" id="enableMPE" title="Enable MPE (MIDI Polyphonic Expression) input for per-note control.">
                    <label for="enableMPE" style="text-align: left; width: auto;">Enable MPE Input</label>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global messages or Omni for all channels.">
                    <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
                    <select id="mpeGlobalInputChannel" title="Set the MIDI channel for MPE global control messages, or Omni to listen to all channels.">
                        <option value="omni">Omni</option>
                        <option value="1">Channel 1</option>
                        <option value="2">Channel 2</option>
                        <option value="3">Channel 3</option>
                        <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option>
                        <option value="6">Channel 6</option>
                        <option value="7">Channel 7</option>
                        <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option>
                        <option value="10">Channel 10</option>
                        <option value="11">Channel 11</option>
                        <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option>
                        <option value="14">Channel 14</option>
                        <option value="15">Channel 15</option>
                        <option value="16">Channel 16</option>
                    </select>
                </div>

                <div class="slider-container" title="Number of MIDI channels used for MPE voice messages.">
                    <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
                    <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15" title="Specify the number of MIDI channels to use for MPE voice messages.">
                </div>

                <div class="slider-container" title="Output mode: Non-MPE (single channel) or MPE.">
                    <label for="mpeOutputMode">MPE Output Mode:</label>
                    <select id="mpeOutputMode" title="Choose the MIDI output mode: Non-MPE (single channel) or MPE.">
                        <option value="non-mpe">Non-MPE (Single Channel)</option>
                        <option value="mpe">MPE</option>
                    </select>
                </div>

                <div class="slider-container" title="MIDI channel for MPE global output or base channel for non-MPE.">
                    <label for="mpeGlobalOutputChannel">MPE Global Output / Base Channel:</label>
                    <select id="mpeGlobalOutputChannel" title="Set the MIDI channel for MPE global output or the base channel for non-MPE output.">
                        <option value="1">Channel 1</option>
                        <option value="2">Channel 2</option>
                        <option value="3">Channel 3</option>
                        <option value="4">Channel 4</option>
                        <option value="5">Channel 5</option>
                        <option value="6">Channel 6</option>
                        <option value="7">Channel 7</option>
                        <option value="8">Channel 8</option>
                        <option value="9">Channel 9</option>
                        <option value="10">Channel 10</option>
                        <option value="11">Channel 11</option>
                        <option value="12">Channel 12</option>
                        <option value="13">Channel 13</option>
                        <option value="14">Channel 14</option>
                        <option value="15">Channel 15</option>
                        <option value="16">Channel 16</option>
                    </select>
                </div>
            </fieldset>
        </div>

        <div id="pattern-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Pattern Settings</h3></legend>
                <div class="slider-container" title="Enable or disable the pattern rhythm.">
                    <input type="checkbox" id="enablePattern" checked title="Enable pattern rhythm to introduce skips.">
                    <label for="enablePattern" style="text-align: left; width: auto;">Enable Pattern</label>
                </div>
                <div class="slider-container" title="Number of steps in the pattern rhythm.">
                    <label for="patternSteps">Steps:</label>
                    <input type="range" id="patternSteps" value="5" min="1" max="32" step="1" title="Adjust the number of steps in the pattern.">
                    <span id="patternStepsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Number of beats within the pattern steps.">
                    <label for="patternBeats">Beats:</label>
                    <input type="range" id="patternBeats" value="3" min="1" max="5" step="1" title="Adjust the number of beats in the pattern rhythm.">
                    <span id="patternBeatsValue" class="number-display">3</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the pattern rhythm.">
                    <label for="patternOffset">Offset:</label>
                    <input type="range" id="patternOffset" value="0" min="-2" max="2" step="1" title="Shift the pattern rhythm forwards or backwards.">
                    <span id="patternOffsetValue" class="number-display">0</span>
                </div>
                <div id="patternDisplay" class="rhythm-display" title="Visual representation of the pattern rhythm (Note/Skip)."></div>
            </fieldset>
        </div>

        <div id="rhythm-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Rhythm Settings</h3></legend>
                 <div class="slider-container" title="Enable or disable the arpeggio rhythm.">
                    <input type="checkbox" id="enableRhythm" checked title="Enable arpeggio rhythm to introduce rests.">
                    <label for="enableRhythm" style="text-align: left; width: auto;">Enable Rhythm</label>
                </div>
                <div class="slider-container" title="Number of steps in the arpeggio rhythm.">
                    <label for="rhythmSteps">Steps:</label>
                    <input type="range" id="rhythmSteps" value="7" min="1" max="32" step="1" title="Adjust the number of steps in the arpeggio rhythm.">
                    <span id="rhythmStepsValue" class="number-display">7</span>
                </div>
                <div class="slider-container" title="Number of beats within the arpeggio rhythm steps.">
                    <label for="rhythmBeats">Beats:</label>
                    <input type="range" id="rhythmBeats" value="5" min="1" max="7" step="1" title="Adjust the number of beats in the arpeggio rhythm.">
                    <span id="rhythmBeatsValue" class="number-display">5</span>
                </div>
                <div class="slider-container" title="Offset (rotation) of the arpeggio rhythm.">
                    <label for="rhythmOffset">Offset:</label>
                    <input type="range" id="rhythmOffset" value="0" min="-4" max="4" step="1" title="Shift the arpeggio rhythm forwards or backwards.">
                    <span id="rhythmOffsetValue" class="number-display">0</span>
                </div>
                <div id="rhythmDisplay" class="rhythm-display" title="Visual representation of the arpeggio rhythm (Beat/Rest)."></div>
            </fieldset>
        </div>

        <div id="arp-tab" class="tab-content tab-pane">
            <fieldset class="parameter-group">
                <legend><h3>Arp Settings</h3></legend>

                <div class="slider-container" title="Clock division for arpeggiator step timing.">
                    <label for="clockDivision">Clock Division:</label>
                    <select id="clockDivision" title="Set the clock division to control the speed of the arpeggio steps.">
                        <option value="1/1">1/1</option>
                        <option value="1/2">1/2</option>
                        <option value="1/4" selected="selected">1/4</option>
                        <option value="1/8">1/8</option>
                        <option value="1/16">1/16</option>
                        <option value="1/32">1/32</option>
                        <option value="1/2T">1/2T</option>
                        <option value="1/4T">1/4T</option>
                        <option value="1/8T">1/8T</option>
                        <option value="1/16T">1/16T</option>
                        <option value="1/32T">1/32T</option>
                    </select>
                </div>

                <div class="slider-container" title="Arpeggio mode determines the order notes are played.">
                    <label for="arpMode">Arp Mode:</label>
                    <select id="arpMode" title="Select the arpeggio playback mode.">
                        <option value="up" selected="selected">Up</option>
                        <option value="down">Down</option>
                        <option value="upDown">Up/Down</option>
                        <option value="upDownInclusive">Up/Down (Incl.)</option>
                        <option value="random">Random</option>
                        <option value="converge">Converge</option>
                        <option value="diverge">Diverge</option>
                        <option value="played">Played</option>
                        <option value="shuffled">Shuffled</option>
                        <option value="stableShuffled">Stable Shuffled</option>
                        <option value="chord">Chord</option>
                        <option value="chordN">ChordN</option>
                        <option value="convergeDiverge">Converge/Diverge</option>
                        <option value="convergeDivergeInclusive">Converge/Diverge (Incl.)</option>
                        <option value="walk">Walk</option>
                        <option value="normalWalk">Normal Walk</option>
                    </select>
                </div>

                <div id="chordNControls" style="display: none;">
                    <div class="slider-container" title="Number of notes in each chord for ChordN mode.">
                        <label for="chordNValue">N:</label>
                        <input type="range" id="chordNValue" value="2" min="1" max="16" step="1" title="Set the number of notes per chord in ChordN arpeggio mode.">
                        <span id="chordNValueDisplay" class="number-display">2</span>
                    </div>
                    <div class="slider-container" title="Ordering mode for ChordN chords.">
                        <label for="chordNOrdering">ChordN Ordering:</label>
                        <select id="chordNOrdering" title="Select the ordering mode for ChordN chords.">
                            <option value="up">Up</option>
                            <option value="down">Down</option>
                            <option value="upDown">Up/Down</option>
                            <option value="upDownInclusive">Up/Down (Incl.)</option>
                            <option value="converge">Converge</option>
                            <option value="diverge">Diverge</option>
                        </select>
                    </div>
                    <div class="slider-container" title="Maximum number of consecutive chords a note can be held across in ChordN mode. 1 means no extension.">
                        <label for="maxChordExtension">Max Chord Extend:</label>
                        <input type="range" id="maxChordExtension" value="2" min="1" max="16" step="1" title="Maximum number of consecutive chords a note can be held across in ChordN mode.">
                        <span id="maxChordExtensionValue" class="number-display">2</span>
                    </div>
                    <div class="slider-container" title="Maximum number of clock divisions a note's gate can be extended in ChordN mode.">
                        <label for="maxTimeExtension">Max Time Extend (Divs):</label>
                        <input type="range" id="maxTimeExtension" value="16" min="1" max="64" step="1" title="Maximum number of clock divisions a note's gate can be extended in ChordN mode.">
                        <span id="maxTimeExtensionValue" class="number-display">16</span>
                    </div>
                </div>

                <div id="walkParams" style="display: none;">
                    <div class="slider-container" title="Skew parameter for Walk arpeggio mode.">
                        <label for="walkSkew">Walk Skew:</label>
                        <input type="range" id="walkSkew" value="0" min="-1" max="1" step="0.01" title="Adjust the skew for Walk arpeggio mode, affecting probability of steps.">
                        <span id="walkSkewValue" class="number-display">0</span>
                    </div>
                    <div class="slider-container" id="walkDistanceContainer" style="display: none;">
                        <label for="walkDistance">Walk Distance:</label>
                        <input type="range" id="walkDistance" value="0" min="0" max="1" step="0.01" title="Adjust the distance for Normal Walk arpeggio mode, affecting step size.">
                        <span id="walkDistanceValue" class="number-display">0</span>
                    </div>
                </div>

                <div class="slider-container" title="Percentage of clock division used for sub-arpeggiation of chords.">
                    <label for="subArpScale">Sub Arp Scale (%):</label>
                    <input type="range" id="subArpScale" value="0" min="0" max="100" step="1" title="Control the timing spread of notes within chords. 0% for no sub-arp, 100% to fill clock division.">
                    <span id="subArpScaleValue" class="number-display">0</span>
                </div>
                <div class="slider-container" title="Arpeggio mode for sub-arpeggiation of chords.">
                    <label for="subArpMode">Sub Arp Mode:</label>
                    <select id="subArpMode" title="Select the arpeggio mode for sub-arpeggiation within chords.">
                        <option value="up">Up</option>
                        <option value="down">Down</option>
                        <option value="random">Random</option>
                        <option value="converge">Converge</option>
                        <option value="diverge">Diverge</option>
                    </select>
                </div>

                <div class="slider-container" title="Synchronization mode for the arpeggiator.">
                    <label for="arpSyncMode">Arp Sync Mode:</label>
                    <select id="arpSyncMode" title="Choose the synchronization mode for starting and stopping the arpeggiator.">
                        <option value="free">Free Sync</option>
                        <option value="key" selected="selected">Key Sync</option>
                        <option value="transport">Transport Sync (Placeholder)</option>
                    </select>
                </div>

                <div class="slider-container" title="Number of octaves to expand held notes across.">
                    <label for="octaves">Octaves:</label>
                    <input type="range" id="octaves" value="1" min="1" max="4" step="1" title="Expand the range of arpeggiated notes by adding octaves above the held notes.">
                    <span id="octavesValue" class="number-display">1</span>
                </div>
                <div class="slider-container" title="Base velocity for arpeggiated notes.">
                    <label for="baseVelocity">Base Velocity:</label>
                    <input type="range" id="baseVelocity" value="96" min="1" max="127" step="1" title="Set the base velocity for arpeggiated notes. Velocity can be further modified by MPE or aftertouch.">
                    <span id="baseVelocityValue" class="number-display">96</span>
                </div>
                <div class="slider-container" title="Maximum velocity for arpeggiated notes.">
                    <label for="maxVelocity">Max Velocity:</label>
                    <input type="range" id="maxVelocity" value="127" min="1" max="127" step="1" title="Set the maximum velocity for arpeggiated notes. Used in conjunction with base velocity and pressure.">
                    <span id="maxVelocityValue" class="number-display">127</span>
                </div>
                <div class="slider-container" title="Gate length as a percentage of the clock division.">
                    <label for="gateLength">Gate Length (%):</label>
                    <input type="range" id="gateLength" value="50" min="1" max="150" step="1" title="Adjust the gate length of arpeggiated notes as a percentage of the clock division duration.">
                    <span id="gateLengthValue" class="number-display">50</span>
                </div>
                <div class="slider-container" title="Enable gate flex to extend note gates based on rhythm density.">
                    <input type="checkbox" id="enableGateFlex" title="Enable Gate Flex to make gates longer before rests.">
                    <label for="enableGateFlex" style="text-align: left; width: auto;">Enable Gate Flex</label>
                </div>
            </fieldset>
        </div>
    </div>

    <div class="playback-keyboard-container" title="Visual display of held and playing notes. Not interactive.">
        <div class="playback-keyboard" id="playbackKeyboardDisplay">
            <!-- Playback piano keys will be generated here by JavaScript -->
        </div>
    </div>

    <div class="playback-display" id="playbackDisplay" title="Displays the sequence of played notes and rhythms."></div>

    <button id="startButton" title="Start the arpeggiator." class="control-button">Start Arpeggiator</button>
    <button id="stopButton" disabled title="Stop the arpeggiator." class="control-button">Stop Arpeggiator</button>

    <script>
        /**
         * @fileoverview Euclidean MPE Arpeggiator Prototype
         * Implements a dual-layer Euclidean rhythm arpeggiator with MPE and MIDI support.
         * Features include customizable patterns and arp rhythms, various arpeggio modes,
         * tempo sync options, and octave expansion. MPE and aftertouch/velocity mapping added.
         * Gate Flex feature added. ChordN Gate Extension feature added.
         */

        // --- Utility Functions ---
        /**
         * Helper function to compare if two arrays are equal.
         * @param {array} arr1
         * @param {array} arr2
         * @returns {boolean}
         */
        function arraysAreEqual(arr1, arr2) {
            if (!arr1 || !arr2 || arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        // --- MIDI Variables ---
        let midiAccess = null;
        let midiOutput = null;
        let midiInput = null;
        let isSustainPedalPressed = false;
        let sustainedNotesMIDI = new Set();

        // --- Rhythm Event Constants ---
        const RHYTHM_BEAT = 'B';
        const RHYTHM_REST = 'R';
        const PATTERN_NOTE = 'N';
        const PATTERN_SKIP = 'S';

        // --- Note Arrays and Sets ---
        let rawHeldNotes = []; // Stores original held notes, before octave expansion
        let heldNotes = []; // Stores MIDI notes currently held, expanded by octave if needed, and unique
        let heldNotesUI = new Set(); // Stores notes held by UI interaction
        let heldNotesMIDI = new Set(); // Stores notes held by MIDI input
        let notePressures = new Map(); // Stores pressure values for each held MIDI note (for aftertouch/velocity)
        let noteMPEYAxis = new Map(); // Stores MPE Y Axis values
        let octaveExpandedNoteMap = new Map();
        let playedNoteOrder = []; // Stores notes in the order they were played
        /**
         * @typedef {object} ActiveNoteState
         * @property {number | null} noteOffTimeoutId - Timeout ID for the scheduled note off, or null if extended.
         * @property {boolean} isExtended - True if the note's gate is currently being extended by ChordN logic.
         * @property {number} chordsHeldCount - How many consecutive chords this note instance has been held for.
         * @property {number} timeHeldDivisions - How many clock divisions this note instance has been held for.
         * @property {number} outputChannel - The MIDI channel this note is playing on.
         */
        /** @type {Map<number, ActiveNoteState>} */
        let activeArpNotes = new Map(); // Tracks currently sounding notes from the arp and their state

        // --- Rhythm Pattern Variables ---
        let patternRhythm = []; // Euclidean rhythm for note pattern (Note/Skip)
        let rhythm = []; // Euclidean rhythm for arpeggio rhythm (Beat/Rest)
        let rhythmGateMultipliers = []; // Array to store gate multipliers for rhythm
        let isPatternDisabled = false;
        let isRhythmDisabled = false;

        // --- Arpeggiator State Variables ---
        let arpRunning = false; // Arpeggiator play/stop state
        let arpInterval = null; // Interval for internal clock
        let currentNoteIndex = 0; // Index for current note in arpeggio
        let currentRhythmIndex = 0; // Index for current step in arp rhythm
        let currentPatternIndex = 0; // Index for current step in pattern
        let arpMode = 'up'; // Arpeggio mode (up, down, etc.)
        let arpSyncMode = 'key'; // Arpeggio sync mode (free, key, transport)
        let currentModeNoteList = []; // Array holding notes for the current arp mode
        let chordNValue = 2; // Default N value for ChordN mode

        // --- ChordN Gate Extension ---
        let maxChordExtension = 2; // Max consecutive chords to extend gate
        let maxTimeExtensionDivisions = 16; // Max clock divisions to extend gate

        // --- Walk Mode Parameters ---
        let walkSkew = 0; // Skew parameter for walk modes, default 0
        let walkDistance = 0; // Distance parameter for normal walk mode, default 0

        // --- Sub Arp ---
        let subArpScalePercentage = 0; // Default sub arp scale
        let subArpMode = 'up'; // Default sub arp mode

        // --- Gate Flex ---
        let isGateFlexEnabled = false; // Enable/disable gate flex

        // --- MPE and MIDI Channel Settings ---
        let isMPEEnabled = false;
        let mpeGlobalInputChannel = 'omni';
        let mpeInputVoiceChannels = 8;
        let mpeOutputMode = 'non-mpe';
        let mpeGlobalOutputChannel = '1';
        let mpeChannelNotes = new Array(16).fill(null); // Track notes per MPE channel

        // --- Tempo and Clock Variables ---
        let tempoSource = 'internal';
        let bpm = 120;
        let clockDivision = '1/4';
        let tickCounter = -1;
        let clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision); // Ticks per step based on clock division
        let internalClockInterval = null;
        let clockDivisionDurationMs = 0; // Duration of one clock division in milliseconds
        const tempoBPMInput = document.getElementById('tempoBPM'); // Tempo BPM input element (now also display)

        // --- MIDI Clock Tick History ---
        const tickHistorySize = 24; // Store up to 24 ticks (one quarter note)
        let tickHistory = new Array(tickHistorySize).fill(performance.now());
        let tickIndex = tickHistorySize;

        // --- Arpeggio Mode Specific State ---
        let shuffledNotesOrder = [];
        let stableShuffledOrder = [];
        let stableShuffleIndex = 0;
        let lastNotesToArp = [];

        // --- UI Elements and Display ---
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 20;
        let highlightedPianoKey = null;
        let highlightedPlaybackPianoKey = null; // For playback keyboard highlighting

        // --- Octave Expansion ---
        let octaveCount = 1;
        let baseVelocityValue = 96; // Default base velocity
        let maxVelocityValue = 127; // Default max velocity

        // --- Gate Length ---
        let gateLengthPercentage = 50; // Default gate length percentage
        let gateLengthValueDisplay = document.getElementById('gateLengthValue'); // Get display element

        // -- Miscellaneous constants --
        const defaultNotePressure = 0; // Pressure that new notes get initialized to
        const defaultMpeYAxis = 0; // MPE Y value that new notes get initialized to
        const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const LOOKAHEAD_MAX_STEPS = 64; // Max steps for ChordN lookahead

        /**
         * Event listeners for UI controls.
         */
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');

        startButton.addEventListener('click', startArpeggiator);
        stopButton.addEventListener('click', stopArpeggiator);

        // --- Arp Mode and related controls event listeners ---
        document.getElementById('arpMode').addEventListener('change', function() {
            arpMode = this.value;
            const chordNControls = document.getElementById('chordNControls');
            const walkParamsControls = document.getElementById('walkParams');
            const walkDistanceContainer = document.getElementById('walkDistanceContainer');

            if (arpMode === 'chordN') {
                chordNControls.style.display = 'block';
                walkParamsControls.style.display = 'none';
            } else if (arpMode === 'normalWalk') {
                chordNControls.style.display = 'none';
                walkParamsControls.style.display = 'block';
                walkDistanceContainer.style.display = 'block';
            } else if (arpMode === 'walk') {
                chordNControls.style.display = 'none';
                walkParamsControls.style.display = 'block';
                walkDistanceContainer.style.display = 'none';
            } else {
                chordNControls.style.display = 'none';
                walkParamsControls.style.display = 'none';
            }
            updateArpeggiatorNoteListAndIndex();
        });
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });

        // --- MPE Settings event listeners ---
        document.getElementById('enableMPE').addEventListener('change', function() {
            isMPEEnabled = this.checked;
        });
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            mpeGlobalInputChannel = this.value;
        });
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            mpeInputVoiceChannels = parseInt(this.value);
        });
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            mpeOutputMode = this.value;
        });
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            mpeGlobalOutputChannel = this.value;
        });

        // --- Octave, Tempo and Clock Settings event listeners ---
        document.getElementById('octaves').addEventListener('input', function() {
            octaveCount = parseInt(this.value);
            document.getElementById('octavesValue').textContent = octaveCount;
            updateHeldNotesArrays();
        });
        document.getElementById('tempoSource').addEventListener('change', function() {
            tempoSource = this.value;
            if (tempoSource === 'internal') {
                setupInternalClock();
                updateTempoDisplay();
            } else {
                clearInterval(internalClockInterval);
                updateTempoDisplay('External MIDI Clock');
            }
        });
        tempoBPMInput.addEventListener('change', function() {
            bpm = parseInt(this.value);
            if (tempoSource === 'internal') {
                setupInternalClock();
                updateTempoDisplay();
            }
        });
        document.getElementById('clockDivision').addEventListener('change', function() {
            clockDivision = this.value;
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            if (tempoSource === 'internal') {
                setupInternalClock();
            }
        });

        // --- ChordN and Walk Mode Parameters event listeners ---
        document.getElementById('chordNValue').addEventListener('input', function() {
            chordNValue = parseInt(this.value);
            document.getElementById('chordNValueDisplay').textContent = chordNValue;
            updateModeNoteList();
        });
        document.getElementById('chordNOrdering').addEventListener('change', function() {
            updateModeNoteList();
        });
        document.getElementById('maxChordExtension').addEventListener('input', function() {
            maxChordExtension = parseInt(this.value);
            document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        });
        document.getElementById('maxTimeExtension').addEventListener('input', function() {
            maxTimeExtensionDivisions = parseInt(this.value);
            document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        });
        document.getElementById('walkSkew').addEventListener('input', function() {
            walkSkew = parseFloat(this.value);
            document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        });
        document.getElementById('walkDistance').addEventListener('input', function() {
            walkDistance = parseFloat(this.value);
            document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        });

        // --- Velocity, Gate and Sub Arp event listeners ---
        document.getElementById('baseVelocity').addEventListener('input', function() {
            baseVelocityValue = parseInt(this.value);
            document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        });
        document.getElementById('maxVelocity').addEventListener('input', function() {
            maxVelocityValue = parseInt(this.value);
            document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        });
        document.getElementById('gateLength').addEventListener('input', function() {
            gateLengthPercentage = parseInt(this.value);
            document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        });
        document.getElementById('subArpScale').addEventListener('input', function() {
            subArpScalePercentage = parseInt(this.value);
            document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        });
        document.getElementById('subArpMode').addEventListener('change', function() {
            subArpMode = this.value;
        });

        // --- Rhythm and Pattern Settings event listeners ---
        document.getElementById('patternSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('rhythmOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('enablePattern').addEventListener('change', function() {
            isPatternDisabled = !this.checked;
            updateRhythmDisplays();
            updatePatternControlsState();
        });
        document.getElementById('enableRhythm').addEventListener('change', function() {
            isRhythmDisabled = !this.checked;
            updateRhythmDisplays();
            updateRhythmControlsState();
        });
        document.getElementById('enableGateFlex').addEventListener('change', function() {
            isGateFlexEnabled = this.checked;
        });

        // --- TAB SWITCHING ---
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(tabId).classList.add('active');
            });
        });

        /**
         * Updates the tempo display in the UI.
         * @param {string} [source] - Tempo source ('Internal' or 'External MIDI Clock').
         *                           Defaults to 'Internal' if tempoSource is 'internal', otherwise 'External MIDI Clock'.
         */
        function updateTempoDisplay(source) {
            if (!source) {
                source = tempoSource === 'internal' ? 'Internal' : 'External MIDI Clock';
            }
            tempoBPMInput.value = bpm;
            tempoBPMInput.title = `Tempo (BPM): ${source === 'Internal' ? 'Editable' : 'Controlled by external MIDI clock'}`;
            tempoBPMInput.readOnly = source !== 'Internal';
        }

        /**
         * Initializes WebMIDI and sets up MIDI input and output device selectors.
         */
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);

        /**
         * Handles successful MIDI access.
         * Populates MIDI input and output selectors and sets up default devices.
         * @param {MIDIAccess} midi - MIDI access object.
         */
        function onMIDISuccess(midi) {
            midiAccess = midi;
            document.getElementById('midiStatus').innerText = "MIDI Status: Connected";

            const inputSelect = document.getElementById('midiInputSelect');
            const outputSelect = document.getElementById('midiOutputSelect');

            // Populate MIDI input select
            midiAccess.inputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id;
                option.text = input.name || 'MIDI Input ' + (inputSelect.options.length);
                inputSelect.appendChild(option);
            });

            // Populate MIDI output select
            midiAccess.outputs.forEach(output => {
                const option = document.createElement('option');
                option.value = output.id;
                option.text = output.name || 'MIDI Output ' + (outputSelect.options.length);
                outputSelect.appendChild(option);
            });

            // Select first input and output if available (skip "No input device selected" option)
            if (inputSelect.options.length > 1) {
                inputSelect.selectedIndex = 1;
                selectMidiInput(inputSelect.options[1].value);
            }

            if (outputSelect.options.length > 1) {
                outputSelect.selectedIndex = 1;
                selectMidiOutput(outputSelect.options[1].value);
            } else {
                document.getElementById('midiStatus').innerText += " No MIDI output device found.";
            }

            // Input device change listener
            inputSelect.addEventListener('change', function() {
                selectMidiInput(this.value);
            });

            // Output device change listener
            outputSelect.addEventListener('change', function() {
                selectMidiOutput(this.value);
            });
        }

        /**
         * Handles MIDI access failure.
         */
        function onMIDIFailure() {
            document.getElementById('midiStatus').innerText = "MIDI Status: MIDI access failed.";
        }

        /**
         * Selects a MIDI input device and attaches the MIDI message handler.
         * @param {string} inputId - ID of the MIDI input device.
         */
        function selectMidiInput(inputId) {
            if (midiInput) {
                midiInput.onmidimessage = null;
            }
            if (inputId) {
                midiInput = midiAccess.inputs.get(inputId);
                if (midiInput) { // Ensure device still exists
                    midiInput.onmidimessage = onMIDIMessage;
                } else {
                    console.warn(`MIDI Input device with ID ${inputId} not found.`);
                    midiInput = null;
                }
            } else {
                midiInput = null;
            }
        }

        /**
         * Selects a MIDI output device.
         * @param {string} outputId - ID of the MIDI output device.
         */
        function selectMidiOutput(outputId) {
            if (outputId) {
                midiOutput = midiAccess.outputs.get(outputId);
                if (!midiOutput) {
                    console.warn(`MIDI Output device with ID ${outputId} not found.`);
                }
            } else {
                midiOutput = null;
            }
        }

        /**
         * Generates octave-expanded notes from raw held notes.
         * Ensures no note appears more than once in the expanded sequence.
         * @param {number[]} inputNotes - Array of raw MIDI notes.
         * @param {number} octaves - Number of octaves to expand.
         * @returns {number[]} - Array of unique, octave-expanded MIDI notes.
         */
        function generateOctaveExpandedNotes(inputNotes, octaves) {
            const expandedNotes = [];
            const seenNotes = new Set();
            octaveExpandedNoteMap.clear();
            for (let i = 0; i < octaves; i++) {
                for (const originalNote of inputNotes) {
                    const expandedNote = originalNote + (12 * i);
                    if (!seenNotes.has(expandedNote) && expandedNote <= 127) { // Added check for MIDI range
                        expandedNotes.push(expandedNote);
                        seenNotes.add(expandedNote);
                        octaveExpandedNoteMap.set(expandedNote, originalNote);
                    }
                }
            }
            return expandedNotes;
        }

        /**
         * Updates the arpeggiator's note list and index based on the current arp mode and held notes.
         * Called whenever held notes or arp mode changes to maintain continuity.
         */
        function updateArpeggiatorNoteListAndIndex() {
            const previousModeNoteList = [...currentModeNoteList];
            const previousNoteIndexVal = currentNoteIndex;

            const newModeNoteList = updateModeNoteList();

            if (previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge', 'convergeDiverge', 'convergeDivergeInclusive', 'walk', 'normalWalk', 'played'].includes(arpMode)) {
                    // For non-chord modes, find the closest match
                    const previousNote = (arpMode !== 'chordN' && previousModeNoteList.length > 0) ? previousModeNoteList[previousNoteIndexVal % previousModeNoteList.length] : null;
                    if (previousNote !== null) {
                        currentNoteIndex = findClosestNoteIndex(previousNote, previousModeNoteList, newModeNoteList, previousNoteIndexVal);
                    } else {
                        // Fallback if previous note couldn't be determined (e.g., switching from ChordN)
                        currentNoteIndex = (previousNoteIndexVal % previousModeNoteList.length) % newModeNoteList.length;
                        if (!currentNoteIndex) currentNoteIndex = 0;
                    }
                } else if (arpMode === 'chordN') {
                    // For ChordN, try to maintain the position proportionally
                    currentNoteIndex = Math.floor((previousNoteIndexVal / previousModeNoteList.length) * newModeNoteList.length) % newModeNoteList.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                } else {
                    // Default fallback for other modes (like chord, random, shuffle)
                    currentNoteIndex = (previousNoteIndexVal % previousModeNoteList.length) % newModeNoteList.length;
                    if (!currentNoteIndex) currentNoteIndex = 0;
                }
            } else {
                // If arp wasn't running or either list was empty, reset index
                currentNoteIndex = 0;
            }
        }

        /**
         * Handles note on events from both UI and MIDI sources.
         * Updates held notes, UI, and starts arpeggiator in Key Sync mode.
         * @param {number} note - MIDI note number.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         * @param {number} [channel] - MIDI channel of the note on message (only for MIDI source).
         */
        function noteOn(note, source = 'ui', channel = null) {
            addHeldNote(note, source, channel);
        }

        /**
         * Handles note off events from MIDI sources.
         * Updates held notes, UI, and stops arpeggiator in Key Sync mode if no notes are held.
         * @param {number} note - MIDI note number.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         * @param {number} [channel] - MIDI channel of the note off message (only for MIDI source).
         */
        function noteOff(note, source = 'midi', channel = null) {
            removeHeldNote(note, source, channel);
        }

        /**
         * Adds a note to held notes, handling octave expansion and UI update.
         * @param {number} note - MIDI note number to add.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         * @param {number} [channel] - MIDI channel (for MIDI source).
         */
        function addHeldNote(note, source = 'ui', channel = null) {
            const isUI = source === 'ui';
            const heldSet = isUI ? heldNotesUI : heldNotesMIDI;
            let noteAdded = false;

            if (isUI) {
                if (!heldSet.has(note)) {
                    heldSet.add(note);
                    rawHeldNotes.push(note);
                    playedNoteOrder.push(note);
                    noteAdded = true;
                } else { // UI click again toggles off
                    heldSet.delete(note);
                    const indexToRemove = rawHeldNotes.indexOf(note);
                    if (indexToRemove > -1) {
                        rawHeldNotes.splice(indexToRemove, 1);
                        const playedIndexToRemove = playedNoteOrder.indexOf(note);
                        if (playedIndexToRemove > -1) {
                            playedNoteOrder.splice(playedIndexToRemove, 1);
                        }
                    }
                }
                updateHeldNotesArrays();
                updatePianoUIForNote(note, source); // Update this specific key
            } else { // source === 'midi'
                if (!heldNotesMIDI.has(note)) {
                    heldNotesMIDI.add(note);
                    rawHeldNotes.push(note);
                    playedNoteOrder.push(note);
                    noteAdded = true;
                }
                updateHeldNotesArrays();
                updatePianoUIForNote(note, 'midi'); // Update this specific key
                if (isMPEEnabled && channel !== null && channel >= 0 && channel < 16) {
                    mpeChannelNotes[channel] = note;
                }
            }

            if (noteAdded) {
                notePressures.set(note, defaultNotePressure);
                noteMPEYAxis.set(note, defaultMpeYAxis);
            }
            updatePlaybackKeyboardUI(); // Update the whole playback keyboard display

            if (noteAdded && arpSyncMode === 'key' && !arpRunning) {
                startArpeggiator();
            }
            if (noteAdded) {
                updateArpeggiatorNoteListAndIndex(); // Update arp list if a note was actually added

                // Update shuffle modes if running and a note was added
                if (arpRunning) {
                    if (arpMode === 'shuffled' && shuffledNotesOrder.length > 0) {
                        const insertionIndex = Math.floor(Math.random() * (shuffledNotesOrder.length + 1)); // Allow insertion at end
                        shuffledNotesOrder.splice(insertionIndex, 0, note);
                        if (insertionIndex <= currentNoteIndex) {
                            currentNoteIndex++;
                        }
                    } else if (arpMode === 'stableShuffled' && stableShuffledOrder.length > 0) {
                        const insertionIndex = Math.floor(Math.random() * (stableShuffledOrder.length + 1));
                        stableShuffledOrder.splice(insertionIndex, 0, note);
                        if (insertionIndex <= stableShuffleIndex) {
                            stableShuffleIndex++;
                        }
                    } else if (arpMode === 'shuffled' && shuffledNotesOrder.length === 0) { // First note added to empty shuffle
                        shuffledNotesOrder.push(note);
                    } else if (arpMode === 'stableShuffled' && stableShuffledOrder.length === 0) { // First note added to empty stable shuffle
                        stableShuffledOrder.push(note);
                    }
                }
            } else if (!isUI) { // If UI note removed, update list
                updateArpeggiatorNoteListAndIndex();
            }
        }


        /**
         * Removes a note from held notes, considering sustain pedal and UI update.
         * @param {number} note - MIDI note number to remove.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         * @param {number} [channel] - MIDI channel (for MIDI source).
         */
        function removeHeldNote(note, source = 'midi', channel = null) {
            let noteRemoved = false;
            if (source === 'midi') {
                if (isSustainPedalPressed) {
                    sustainedNotesMIDI.add(note); // Sustain it instead of removing immediately
                    return; // Don't process removal yet
                }
                if (heldNotesMIDI.has(note)) {
                    heldNotesMIDI.delete(note);
                    const indexToRemove = rawHeldNotes.indexOf(note);
                    if (indexToRemove > -1) {
                        rawHeldNotes.splice(indexToRemove, 1);
                        const playedIndexToRemove = playedNoteOrder.indexOf(note);
                        if (playedIndexToRemove > -1) {
                            playedNoteOrder.splice(playedIndexToRemove, 1);
                        }
                        noteRemoved = true;
                    }
                    updatePianoUIForNote(note, 'midi'); // Update specific key
                    if (isMPEEnabled && channel !== null && channel >= 0 && channel < 16 && mpeChannelNotes[channel] === note) {
                        mpeChannelNotes[channel] = null;
                    }
                }
            } else { // source === 'ui' - Note: UI removal already handled in addHeldNote toggle
                // This function is typically called for MIDI Note Off, so UI path might not be hit here often
                if (heldNotesUI.has(note)) {
                    heldNotesUI.delete(note);
                    const indexToRemove = rawHeldNotes.indexOf(note);
                    if (indexToRemove > -1) {
                        rawHeldNotes.splice(indexToRemove, 1);
                        const playedIndexToRemove = playedNoteOrder.indexOf(note);
                        if (playedIndexToRemove > -1) {
                            playedNoteOrder.splice(playedIndexToRemove, 1);
                        }
                        noteRemoved = true;
                    }
                    updatePianoUIForNote(note, 'ui'); // Update specific key
                }
            }

            if (noteRemoved) {
                notePressures.delete(note);
                noteMPEYAxis.delete(note);
                updateHeldNotesArrays();
                updatePlaybackKeyboardUI(); // Update whole playback display

                if (arpSyncMode === 'key' && rawHeldNotes.length === 0 && arpRunning) {
                    stopArpeggiator();
                } else {
                    // Only update list if arp still running or could restart
                    updateArpeggiatorNoteListAndIndex();
                }

                // Update shuffle modes if running and a note was removed
                if (arpRunning) {
                    if (arpMode === 'shuffled') {
                        const noteIndex = shuffledNotesOrder.indexOf(note);
                        if (noteIndex !== -1) {
                            shuffledNotesOrder.splice(noteIndex, 1);
                            if (noteIndex < currentNoteIndex && currentNoteIndex > 0) {
                                currentNoteIndex--;
                            }
                            // Ensure index stays within bounds if last note removed
                            if (currentNoteIndex >= shuffledNotesOrder.length && shuffledNotesOrder.length > 0) {
                                currentNoteIndex = shuffledNotesOrder.length - 1;
                            } else if (shuffledNotesOrder.length === 0) {
                                currentNoteIndex = 0;
                            }
                        }
                    } else if (arpMode === 'stableShuffled') {
                        const noteIndex = stableShuffledOrder.indexOf(note);
                        if (noteIndex !== -1) {
                            stableShuffledOrder.splice(noteIndex, 1);
                            if (noteIndex < stableShuffleIndex && stableShuffleIndex > 0) {
                                stableShuffleIndex--;
                            }
                            // Ensure index stays within bounds if last note removed
                            if (stableShuffleIndex >= stableShuffledOrder.length && stableShuffledOrder.length > 0) {
                                stableShuffleIndex = stableShuffledOrder.length - 1;
                            } else if (stableShuffledOrder.length === 0) {
                                stableShuffleIndex = 0;
                            }
                        }
                    }
                }
            }
        }

        /**
         * Updates the 'heldNotes' array from 'rawHeldNotes' based on octave count.
         * Also updates playback keyboard UI and mode note list.
         */
        function updateHeldNotesArrays() {
            // Sort raw notes before expansion for consistent octave mapping if order matters later
            rawHeldNotes.sort((a, b) => a - b);
            heldNotes = generateOctaveExpandedNotes(rawHeldNotes, octaveCount);
            // No need to update playback keyboard here, done in add/remove
            updateModeNoteList(); // Regenerate the mode list based on new heldNotes
        }

        /**
         * Updates the piano keyboard UI for a single note.
         * @param {number} note - MIDI note number.
         * @param {string|null} source - Source of the hold ('ui', 'midi', or null to reset).
         */
        function updatePianoUIForNote(note, source) {
            updatePianoKeyboardUI(note, source);
        }

        /**
         * Converts a MIDI note number to a note name (e.g., "C4").
         * @param {number} note - MIDI note number.
         * @returns {string} - Note name with octave.
         */
        function midiNoteToName(note) {
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const octave = Math.floor(note / 12) - 1;
            const noteName = notes[note % 12];
            return noteName + octave;
        }

        /**
         * Generates a Euclidean rhythm pattern.
         * @param {number} steps - Number of steps in the rhythm.
         * @param {number} beats - Number of beats in the rhythm.
         * @param {number} offset - Offset/rotation of the rhythm.
         * @param {string} beatEvent - Event character for beats.
         * @param {string} restEvent - Event character for rests.
         * @param {boolean} [isDisabled=false] - If true, rhythm is disabled and all steps are beatEvent.
         * @returns {string[]} - Array representing the Euclidean rhythm pattern.
         */
        function generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent, isDisabled = false) {
            if (isDisabled || steps <= 0) { // Added steps check
                return new Array(steps > 0 ? steps : 0).fill(beatEvent);
            }
            // Ensure beats is not greater than steps
            beats = Math.min(beats, steps);

            const rhythm = new Array(steps).fill(restEvent);
            let count = 0;
            let beatIndex = 0;
            for (let i = 0; i < steps; i++) {
                // Bjorklund's algorithm simplified check
                if (Math.floor((beatIndex * steps) / beats) === i) {
                    rhythm[i] = beatEvent;
                    beatIndex++;
                }
            }

            // Apply offset safely
            const actualOffset = offset % steps;
            const positiveOffset = actualOffset >= 0 ? actualOffset : steps + actualOffset;
            if (positiveOffset > 0) {
                return [...rhythm.slice(steps - positiveOffset), ...rhythm.slice(0, steps - positiveOffset)];
            }
            return rhythm;
        }

        /**
         * Generates an array of gate multipliers based on the rhythm array.
         * @param {string[]} rhythmArray - Array of rhythm events ('B' for beat, 'R' for rest).
         * @returns {number[]} - Array of gate multipliers, 0 for rests, steps to next beat for beats.
         */
        function generateRhythmGateMultipliers(rhythmArray) {
            const len = rhythmArray.length;
            if (len === 0) return [];
            const multipliers = new Array(len).fill(0);
            for (let i = 0; i < len; i++) {
                if (rhythmArray[i] === RHYTHM_BEAT) {
                    let stepsToNextBeat = 1;
                    let nextIndex = (i + 1) % len;
                    while (nextIndex !== i && rhythmArray[nextIndex] !== RHYTHM_BEAT) {
                        stepsToNextBeat++;
                        nextIndex = (nextIndex + 1) % len;
                    }
                    // If only one beat exists, the multiplier is the full length
                    if (nextIndex === i && stepsToNextBeat === len && rhythmArray.filter(s => s === RHYTHM_BEAT).length === 1) {
                        multipliers[i] = len;
                    } else if (nextIndex !== i) { // Found another beat
                        multipliers[i] = stepsToNextBeat;
                    } else { // Only one beat, but loop completed unexpectedly? Default to 1
                        multipliers[i] = 1;
                    }
                }
            }
            return multipliers;
        }

        /**
         * Updates both pattern and arpeggio rhythm displays based on slider values and enabled states.
         */
        function updateRhythmDisplays() {
            const patternStepsSlider = document.getElementById('patternSteps');
            const patternBeatsSlider = document.getElementById('patternBeats');
            const patternOffsetSlider = document.getElementById('patternOffset');
            const rhythmStepsSlider = document.getElementById('rhythmSteps');
            const rhythmBeatsSlider = document.getElementById('rhythmBeats');
            const rhythmOffsetSlider = document.getElementById('rhythmOffset');

            const patternSteps = parseInt(patternStepsSlider.value);
            const patternBeats = parseInt(patternBeatsSlider.value);
            const patternOffset = parseInt(patternOffsetSlider.value);

            // Update max beats based on steps dynamically
            patternBeatsSlider.max = patternSteps;
            if (patternBeats > patternSteps) patternBeatsSlider.value = patternSteps; // Adjust if needed
            const patternOffsetMax = Math.floor(patternSteps / 2);
            patternOffsetSlider.min = -patternOffsetMax;
            patternOffsetSlider.max = patternOffsetMax;
            if (patternOffset < -patternOffsetMax || patternOffset > patternOffsetMax) patternOffsetSlider.value = 0; // Reset if out of bounds

            patternRhythm = generateEuclideanRhythm(patternSteps, parseInt(patternBeatsSlider.value), parseInt(patternOffsetSlider.value), PATTERN_NOTE, PATTERN_SKIP, isPatternDisabled);
            displayRhythm(patternRhythm, 'patternDisplay', isPatternDisabled);
            document.getElementById('patternStepsValue').textContent = patternSteps;
            document.getElementById('patternBeatsValue').textContent = patternBeatsSlider.value;
            document.getElementById('patternOffsetValue').textContent = patternOffsetSlider.value;

            const rhythmSteps = parseInt(rhythmStepsSlider.value);
            const rhythmBeats = parseInt(rhythmBeatsSlider.value);
            const rhythmOffset = parseInt(rhythmOffsetSlider.value);

            // Update max beats based on steps dynamically
            rhythmBeatsSlider.max = rhythmSteps;
            if (rhythmBeats > rhythmSteps) rhythmBeatsSlider.value = rhythmSteps; // Adjust if needed
            const rhythmOffsetMax = Math.floor(rhythmSteps / 2);
            rhythmOffsetSlider.min = -rhythmOffsetMax;
            rhythmOffsetSlider.max = rhythmOffsetMax;
            if (rhythmOffset < -rhythmOffsetMax || rhythmOffset > rhythmOffsetMax) rhythmOffsetSlider.value = 0; // Reset if out of bounds

            rhythm = generateEuclideanRhythm(rhythmSteps, parseInt(rhythmBeatsSlider.value), parseInt(rhythmOffsetSlider.value), RHYTHM_BEAT, RHYTHM_REST, isRhythmDisabled);
            displayRhythm(rhythm, 'rhythmDisplay', isRhythmDisabled);
            document.getElementById('rhythmStepsValue').textContent = rhythmSteps;
            document.getElementById('rhythmBeatsValue').textContent = rhythmBeatsSlider.value;
            document.getElementById('rhythmOffsetValue').textContent = rhythmOffsetSlider.value;

            rhythmGateMultipliers = generateRhythmGateMultipliers(rhythm);

            // Reset indices if arp is not running, otherwise let it continue
            if (!arpRunning) {
                resetRhythmIndex();
                resetPatternIndex();
            }
        }

        /**
         * Updates the enabled/disabled state of pattern rhythm controls based on `isPatternDisabled`.
         */
        function updatePatternControlsState() {
            const patternStepsSlider = document.getElementById('patternSteps');
            const patternBeatsSlider = document.getElementById('patternBeats');
            const patternOffsetSlider = document.getElementById('patternOffset');

            patternStepsSlider.disabled = isPatternDisabled;
            patternBeatsSlider.disabled = isPatternDisabled;
            patternOffsetSlider.disabled = isPatternDisabled;
        }

        /**
         * Updates the enabled/disabled state of arpeggio rhythm controls based on `isRhythmDisabled`.
         */
        function updateRhythmControlsState() {
            const rhythmStepsSlider = document.getElementById('rhythmSteps');
            const rhythmBeatsSlider = document.getElementById('rhythmBeats');
            const rhythmOffsetSlider = document.getElementById('rhythmOffset');

            rhythmStepsSlider.disabled = isRhythmDisabled;
            rhythmBeatsSlider.disabled = isRhythmDisabled;
            rhythmOffsetSlider.disabled = isRhythmDisabled;
        }

        /**
         * Displays a rhythm pattern in the UI.
         * @param {string[]} rhythmArray - Array of rhythm events.
         * @param {string} displayElementId - ID of the HTML element to display the rhythm in.
         * @param {boolean} isDisabled - If true, apply disabled styling.
         */
        function displayRhythm(rhythmArray, displayElementId, isDisabled) {
            const displayElement = document.getElementById(displayElementId);
            displayElement.innerHTML = '';
            if (!rhythmArray || rhythmArray.length === 0) return; // Handle empty array
            rhythmArray.forEach((event, index) => {
                const stepElement = document.createElement('div');
                stepElement.classList.add('rhythm-step');
                stepElement.innerText = event;
                stepElement.id = `${displayElementId}-step-${index}`;
                if (event === RHYTHM_BEAT) stepElement.classList.add('beat');
                else if (event === RHYTHM_REST) stepElement.classList.add('rest');
                else if (event === PATTERN_SKIP) stepElement.classList.add('skip');
                else if (event === PATTERN_NOTE) stepElement.classList.add('note');
                if (isDisabled) stepElement.classList.add('disabled-step');
                displayElement.appendChild(stepElement);
            });
        }

        /**
         * --- Arpeggio Mode Note List Generators ---
         * These functions generate the ordered list of notes based on the selected arpeggio mode.
         */

        /**
         * Generates an alternating variant of a note list (e.g., for up/down modes).
         * @param {number[]} notes - Base note list.
         * @returns {number[]} - Notes transformed to an alternating sequence.
         */
        function generateAlternatingVariant(notes) {
            if (!notes || notes.length <= 2) return [...(notes || [])]; // Handle empty/short arrays
            return [...notes, ...[...notes].reverse().slice(1, -1)];
        }

        /**
         * Generates an inclusive alternating variant of a note list (e.g., for up/down inclusive modes).
         * @param {number[]} notes - Base note list.
         * @returns {number[]} - Notes transformed to an inclusive alternating sequence.
         */
        function generateInclusiveAlternatingVariant(notes) {
            if (!notes || notes.length === 0) return []; // Handle empty array
            return [...notes, ...[...notes].reverse()];
        }

        /**
         * Generates a note list in ascending order.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in ascending order.
         */
        function generateUpNoteList(notes) {
            return [...(notes || [])].sort((a, b) => a - b);
        }

        /**
         * Generates a note list in descending order.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in descending order.
         */
        function generateDownNoteList(notes) {
            return [...(notes || [])].sort((a, b) => b - a);
        }

        /**
         * Generates an up-down note list, excluding end notes in descent.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in up-down sequence, excluding end notes in descent.
         */
        function generateUpDownNoteList(notes) {
            return generateAlternatingVariant(generateUpNoteList(notes));
        }

        /**
         * Generates an up-down inclusive note list, including end notes in descent.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in up-down sequence, including end notes in descent.
         */
        function generateUpDownInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateUpNoteList(notes));
        }

        /**
         * Generates a note list converging from outer to inner notes.
         * @param {number[]} notes - Input notes (assumed sorted ascending).
         * @returns {number[]} - Notes converging from outer to inner.
         */
        function generateConvergeNoteList(notes) {
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sortedNotes = [...notes].sort((a, b) => a - b); // Ensure sorted
            const convergeList = [];
            let start = 0;
            let end = sortedNotes.length - 1;
            while (start <= end) {
                convergeList.push(sortedNotes[start]);
                if (start !== end) {
                    convergeList.push(sortedNotes[end]);
                }
                start++;
                end--;
            }
            return convergeList;
        }

        /**
         * Generates a note list diverging from inner to outer notes.
         * @param {number[]} notes - Input notes (assumed sorted ascending).
         * @returns {number[]} - Notes diverging from inner to outer.
         */
        function generateDivergeNoteList(notes) {
            if (!notes || notes.length <= 1) return [...(notes || [])];
            const sortedNotes = [...notes].sort((a, b) => a - b); // Ensure sorted
            const divergeList = [];
            let start = Math.floor((sortedNotes.length - 1) / 2);
            let end = Math.ceil((sortedNotes.length - 1) / 2);
            while (start >= 0 || end < sortedNotes.length) { // Adjust condition
                if (start >= 0) {
                    divergeList.push(sortedNotes[start]);
                }
                if (start !== end && end < sortedNotes.length) { // Check end bound
                    divergeList.push(sortedNotes[end]);
                }
                start--;
                end++;
            }
            return divergeList;
        }

        /**
         * Generates a converge-diverge note list, excluding repeated end notes.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in converge-diverge sequence, excluding repeated end notes.
         */
        function generateConvergeDivergeNoteList(notes) {
            return generateAlternatingVariant(generateConvergeNoteList(notes));
        }

        /**
         * Generates a converge-diverge inclusive note list, including repeated end notes.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes in converge-diverge sequence, including repeated end notes.
         */
        function generateConvergeDivergeInclusiveNoteList(notes) {
            return generateInclusiveAlternatingVariant(generateConvergeNoteList(notes));
        }

        /**
         * Generates a note list in the order notes were played/held.
         * @param {number[]} notes - Input notes (uses playedNoteOrder based on heldNotes).
         * @returns {number[]} - Notes in the order they were played/held.
         */
        function generatePlayedNoteList(notes) {
            // Filter playedNoteOrder to only include currently held notes
            return playedNoteOrder.filter(note => notes.includes(note));
        }

        /**
         * Generates an empty note list for random mode (note selection happens in arpStep).
         * @param {number[]} notes - Input notes (not used in random mode list generation).
         * @returns {number[]} - Empty array.
         */
        function generateRandomNoteList(notes) {
            return [];
        } // Random selects directly from heldNotes

        /**
         * Generates a shuffled note list, shuffling notes randomly each time.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Notes shuffled randomly.
         */
        function generateShuffledNoteList(notes) {
            return [...(notes || [])].sort(() => Math.random() - 0.5);
        }

        /**
         * Returns the stable shuffled note list. It's generated/updated elsewhere.
         * @param {number[]} notes - Input notes.
         * @returns {number[]} - Returns the stable shuffled note order.
         */
        function generateStableShuffledNoteList(notes) {
            return stableShuffledOrder;
        } // Uses existing stable order

        /**
         * Generates a chord note list, including all held notes as a chord.
         * @param {number[]} notes - Input notes.
         * @returns {number[][]} - Returns array containing one chord (array of notes).
         */
        function generateChordNoteList(notes) {
            return notes && notes.length > 0 ? [
                [...notes]
            ] : []; // Wrap in array for consistency
        }

        /**
         * Generates a list of chord combinations from held notes for ChordN mode.
         * @param {number[]} notes - Held MIDI notes.
         * @param {number} n - Number of notes per chord in ChordN.
         * @param {string} [orderingMode='up'] - Optional arpeggio mode to order the chord combinations (e.g., 'up', 'down', 'converge'). Defaults to 'up'.
         * @returns {number[][]} - List of chord combinations, potentially ordered.
         */
        function generateChordNNoteList(notes, n, orderingMode = 'up') {
            if (!notes || notes.length === 0 || n <= 0) return [];
            const sortedNotes = [...notes].sort((a, b) => a - b); // Work with sorted notes for combinations
            n = Math.min(n, sortedNotes.length);

            const combinations = [];

            function combine(currentCombination, startIndex) {
                if (currentCombination.length === n) {
                    combinations.push([...currentCombination]);
                    return;
                }
                // Ensure we don't go out of bounds
                if (startIndex >= sortedNotes.length) {
                    return;
                }
                for (let i = startIndex; i < sortedNotes.length; i++) {
                    // Optimization: If remaining elements are not enough to form a combination of size n
                    if (currentCombination.length + (sortedNotes.length - i) < n) {
                        break;
                    }
                    currentCombination.push(sortedNotes[i]);
                    combine(currentCombination, i + 1); // Next element must be after current one
                    currentCombination.pop();
                }
            }
            combine([], 0);

            if (combinations.length === 0) return [];

            let orderedCombinations = combinations;
            // Apply ordering to the list of combinations
            switch (orderingMode) {
                case 'up':
                    // Already generated in ascending order of first element (due to sorted input + combination logic)
                    break;
                case 'down':
                    orderedCombinations = [...combinations].reverse();
                    break;
                case 'upDown':
                    orderedCombinations = generateAlternatingVariantCombinations(combinations);
                    break;
                case 'upDownInclusive':
                    orderedCombinations = generateInclusiveAlternatingVariantCombinations(combinations);
                    break;
                case 'converge':
                    // Converge needs comparison logic for chords (e.g., based on average pitch, lowest pitch?)
                    // Let's use a simple approach: sort by lowest note, then apply converge logic to the list.
                    orderedCombinations.sort((a, b) => a[0] - b[0]); // Ensure sorted by first note
                    orderedCombinations = generateConvergeCombinations(combinations);
                    break;
                case 'diverge':
                    // Similar to converge, sort first then apply diverge logic.
                    orderedCombinations.sort((a, b) => a[0] - b[0]);
                    orderedCombinations = generateDivergeCombinations(combinations);
                    break;
                default:
                    break;
            }

            return orderedCombinations;
        }

        /**
         * Generates an alternating variant of chord combinations (e.g., for up/down ChordN ordering).
         * @param {number[][]} combinations - Base chord combinations list.
         * @returns {number[][]} - Chord combinations transformed to an alternating sequence.
         */
        function generateAlternatingVariantCombinations(combinations) {
            if (!combinations || combinations.length <= 2) return [...(combinations || [])];
            return [...combinations, ...[...combinations].reverse().slice(1, -1)];
        }

        /**
         * Generates an inclusive alternating variant of chord combinations (e.g., for up/down inclusive ChordN ordering).
         * @param {number[][]} combinations - Base chord combinations list.
         * @returns {number[][]} - Chord combinations transformed to an inclusive alternating sequence.
         */
        function generateInclusiveAlternatingVariantCombinations(combinations) {
            if (!combinations || combinations.length === 0) return [];
            return [...combinations, ...[...combinations].reverse()];
        }

        /**
         * Generates chord combinations converging from outer to inner.
         * @param {number[][]} combinations - Base chord combinations list.
         * @returns {number[][]} - Chord combinations converging from outer to inner.
         */
        function generateConvergeCombinations(combinations) {
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const convergeList = [];
            let start = 0;
            let end = combinations.length - 1;
            while (start <= end) {
                convergeList.push(combinations[start]);
                if (start !== end) {
                    convergeList.push(combinations[end]);
                }
                start++;
                end--;
            }
            return convergeList;
        }

        /**
         * Generates chord combinations diverging from inner to outer.
         * @param {number[][]} combinations - Base chord combinations list.
         * @returns {number[][]} - Chord combinations diverging from inner to outer.
         */
        function generateDivergeCombinations(combinations) {
            if (!combinations || combinations.length <= 1) return [...(combinations || [])];
            const divergeList = [];
            let start = Math.floor((combinations.length - 1) / 2);
            let end = Math.ceil((combinations.length - 1) / 2);
            while (start >= 0 || end < combinations.length) { // Adjust condition
                if (start >= 0) {
                    divergeList.push(combinations[start]);
                }
                if (start !== end && end < combinations.length) {
                    divergeList.push(combinations[end]);
                }
                start--;
                end++;
            }
            return divergeList;
        }

        /**
         * Updates the currentModeNoteList based on the selected arpeggio mode and held notes.
         * Handles regeneration of shuffle orders if needed.
         * @returns {number[] | number[][]} - The newly generated mode note list.
         */
        function updateModeNoteList() {
            let notesToArp = heldNotes.length > 0 ? [...heldNotes] : []; // Use a copy

            // Check if held notes actually changed for stable shuffle regeneration
            if (!arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                lastNotesToArp = [...notesToArp]; // Update last known notes
                if (arpMode === 'stableShuffled' && arpRunning) {
                    stableShuffleIndex = 0; // Reset index on note change if running
                }
            }

            switch (arpMode) {
                case 'up':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                case 'down':
                    currentModeNoteList = generateDownNoteList(notesToArp);
                    break;
                case 'upDown':
                    currentModeNoteList = generateUpDownNoteList(notesToArp);
                    break;
                case 'upDownInclusive':
                    currentModeNoteList = generateUpDownInclusiveNoteList(notesToArp);
                    break;
                case 'converge':
                    currentModeNoteList = generateConvergeNoteList(notesToArp);
                    break;
                case 'diverge':
                    currentModeNoteList = generateDivergeNoteList(notesToArp);
                    break;
                case 'convergeDiverge':
                    currentModeNoteList = generateConvergeDivergeNoteList(notesToArp);
                    break;
                case 'convergeDivergeInclusive':
                    currentModeNoteList = generateConvergeDivergeInclusiveNoteList(notesToArp);
                    break;
                case 'played':
                    currentModeNoteList = generatePlayedNoteList(notesToArp);
                    break;
                case 'random':
                    currentModeNoteList = [];
                    break; // Random uses heldNotes directly
                case 'shuffled':
                    // Regenerate shuffle only if notes changed OR if arp just started/restarted
                    if (!arraysAreEqual(notesToArp, lastNotesToArp) || !arpRunning) {
                        shuffledNotesOrder = generateShuffledNoteList(notesToArp);
                    }
                    currentModeNoteList = shuffledNotesOrder;
                    break;
                case 'stableShuffled':
                    // Stable shuffle order is updated above if notes changed
                    currentModeNoteList = stableShuffledOrder;
                    break;
                case 'chord':
                    currentModeNoteList = generateChordNoteList(notesToArp);
                    break;
                case 'chordN':
                    const chordNOrderingMode = document.getElementById('chordNOrdering').value;
                    currentModeNoteList = generateChordNNoteList(notesToArp, chordNValue, chordNOrderingMode);
                    break;
                case 'walk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break; // Walk modes use sorted list
                case 'normalWalk':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                default:
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
            }
            return currentModeNoteList;
        }


        /**
         * Finds the closest index in the new note list for a given note from the old list.
         * Prioritizes matches after the previous index.
         * @param {number} noteToFind - The note value to search for.
         * @param {number[]} oldNoteList - The previous mode note list (used for context, not searched).
         * @param {number[] | number[][]} newNoteList - The newly generated mode note list.
         * @param {number} previousIndex - The previous arpeggio note index in the old list.
         * @returns {number} - The best matching index in the new note list, or 0 if not found/empty.
         */
        function findClosestNoteIndex(noteToFind, oldNoteList, newNoteList, previousIndex) {
            if (!newNoteList || newNoteList.length === 0) return 0;

            // Handle ChordN structure (list of lists) - can't easily find single note
            if (arpMode === 'chordN' || arpMode === 'chord') {
                // Simple proportional mapping for chord modes
                const oldLength = oldNoteList?.length || 1;
                const newLength = newNoteList.length;
                return Math.floor((previousIndex / oldLength) * newLength) % newLength || 0;
            }

            let bestIndex = -1;
            let minDistance = Infinity;

            // Search forward from the previous index (modulo length)
            for (let i = 0; i < newNoteList.length; i++) {
                const currentIndex = (previousIndex + i) % newNoteList.length;
                if (newNoteList[currentIndex] === noteToFind) {
                    // Prioritize first match found after previousIndex
                    return currentIndex;
                }
            }

            // If not found searching forward (shouldn't happen if note exists), fallback
            const firstOccurrence = newNoteList.indexOf(noteToFind);
            if (firstOccurrence !== -1) {
                return firstOccurrence;
            }

            // If the exact note is truly gone, fallback to proportional index
            const oldLengthFallback = oldNoteList?.length || 1;
            const newLengthFallback = newNoteList.length;
            return Math.floor((previousIndex / oldLengthFallback) * newLengthFallback) % newLengthFallback || 0;
        }

        /**
         * Advances the arpeggio rhythm index by a specified number of steps (default 1).
         * Handles wrap-around.
         * @param {number} [steps=1] - Number of steps to advance.
         */
        function advanceRhythmIndex(steps = 1) {
            if (rhythm && rhythm.length > 0) {
                currentRhythmIndex = (currentRhythmIndex + steps) % rhythm.length;
            } else {
                currentRhythmIndex = 0;
            }
        }

        /**
         * Resets the arpeggio rhythm index to 0.
         */
        function resetRhythmIndex() {
            currentRhythmIndex = 0;
        }

        /**
         * Advances the pattern index by a specified number of steps (default 1).
         * Handles wrap-around.
         * @param {number} [steps=1] - Number of steps to advance.
         */
        function advancePatternIndex(steps = 1) {
            if (patternRhythm && patternRhythm.length > 0) {
                currentPatternIndex = (currentPatternIndex + steps) % patternRhythm.length;
            } else {
                currentPatternIndex = 0;
            }
        }

        /**
         * Resets the pattern index to 0.
         */
        function resetPatternIndex() {
            currentPatternIndex = 0;
        }

        /**
         * Calculates the number of MIDI ticks per arpeggiator step based on the clock division.
         * Assumes 24 ticks per quarter note (PPQN).
         * @param {string} division - Clock division value (e.g., '1/4', '1/8T').
         * @returns {number} - Number of ticks per step.
         */
        function calculateClockDivisionCounterMax(division) {
            switch (division) {
                case '1/1':
                    return 96; // 4 * 24
                case '1/2':
                    return 48; // 2 * 24
                case '1/4':
                    return 24; // 1 * 24
                case '1/8':
                    return 12; // 0.5 * 24
                case '1/16':
                    return 6; // 0.25 * 24
                case '1/32':
                    return 3; // 0.125 * 24
                case '1/2T':
                    return 32; // (2/3) * 48
                case '1/4T':
                    return 16; // (2/3) * 24
                case '1/8T':
                    return 8; // (2/3) * 12
                case '1/16T':
                    return 4; // (2/3) * 6
                case '1/32T':
                    return 2; // (2/3) * 3 -> rounded to 2
                default:
                    return 24; // Default to 1/4
            }
        }

        /**
         * Calculates the gate duration in milliseconds based on clock division, gate length percentage, and optional gate multiplier.
         * @param {number} clockDivisionDurationMs - Duration of one clock division in milliseconds.
         * @param {number} gateLengthPercent - Gate length as a percentage of clock division (1-150).
         * @param {number} [gateMultiplier=1] - Optional multiplier for gate length (e.g., for gate flex).
         * @returns {number} - Gate duration in milliseconds.
         */
        function calculateGateDuration(clockDivisionDurationMs, gateLengthPercent, gateMultiplier = 1) {
            if (clockDivisionDurationMs <= 0 || gateLengthPercent <= 0) return 5; // Minimum gate duration
            const baseDuration = (clockDivisionDurationMs * gateLengthPercent) / 100;
            return Math.max(5, baseDuration * gateMultiplier); // Ensure minimum gate time
        }

        /**
         * Sets up the internal clock for tempo and arpeggiation timing.
         * Clears any existing interval, calculates interval in milliseconds, and starts a new interval.
         */
        function setupInternalClock() {
            clearInterval(internalClockInterval);
            if (bpm <= 0) bpm = 1; // Prevent division by zero
            const ticksPerSecond = (bpm / 60) * 24;
            const intervalMs = 1000 / ticksPerSecond;
            internalClockInterval = setInterval(tick, intervalMs);
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            tickCounter = -1; // Reset tick counter
            clockDivisionDurationMs = intervalMs * clockDivisionCounterMax;
            updateTempoDisplay();
            // console.log(`Internal clock setup: BPM=${bpm}, Division=${clockDivision}, Interval=${intervalMs.toFixed(2)}ms, Ticks per step=${clockDivisionCounterMax}, Clock Division Duration=${clockDivisionDurationMs.toFixed(2)}ms`);
        }

        /**
         * Starts the arpeggiator. Initializes rhythms, note lists, and clock based on tempo source.
         * If already running, this function does nothing.
         */
        function startArpeggiator() {
            if (arpRunning) return;

            // Force update of mode list and potentially shuffle orders on start
            updateModeNoteList(); // This now handles stable shuffle reset internally

            // Regenerate shuffled list specifically on start if mode is shuffled
            if (arpMode === 'shuffled') {
                shuffledNotesOrder = generateShuffledNoteList(heldNotes);
                currentModeNoteList = shuffledNotesOrder; // Ensure it uses the freshly shuffled list
            }

            arpRunning = true;
            startButton.disabled = true;
            stopButton.disabled = false;
            startButton.classList.add('playing');
            stopButton.classList.remove('playing');
            updateRhythmDisplays(); // Generate current rhythms
            resetRhythmIndex();
            resetPatternIndex();
            currentNoteIndex = 0; // Start from beginning of note list
            stableShuffleIndex = 0; // Reset stable shuffle position

            // Initial index for walk modes
            if ((arpMode === 'walk' || arpMode === 'normalWalk') && currentModeNoteList && currentModeNoteList.length > 0) {
                currentNoteIndex = Math.floor(currentModeNoteList.length / 2);
            }

            playbackDisplayElem.innerHTML = ''; // Clear playback history
            activeArpNotes.clear(); // Clear any previously active notes

            if (tempoSource === 'internal') {
                setupInternalClock();
            } else {
                // External clock setup
                clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
                tickCounter = -1; // Reset tick counter for external sync
                // Calculate initial duration estimate based on last known BPM if available
                if (bpm > 0) {
                    const avgInterval = 60000 / (bpm * 24);
                    clockDivisionDurationMs = avgInterval * clockDivisionCounterMax;
                } else {
                    clockDivisionDurationMs = 0; // Unknown duration initially
                }
                updateTempoDisplay('External MIDI Clock');
                // console.log(`External clock mode active, division=${clockDivision}, ticksPerStep=${clockDivisionCounterMax}`);
            }
        }

        /**
         * Stops the arpeggiator. Clears intervals, active notes, and UI states.
         * If not running, this function does nothing.
         */
        function stopArpeggiator() {
            if (!arpRunning) return;
            arpRunning = false;
            if (tempoSource === 'internal') {
                clearInterval(internalClockInterval);
                internalClockInterval = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            stopButton.classList.add('playing');
            startButton.classList.remove('playing');
            allNotesOff(); // Stop all sounding notes managed by the arp
            unhighlightCurrentStep();
            unhighlightPlaybackPianoKeys(); // Clear current note highlight
            // Optionally clear playback display: playbackDisplayElem.innerHTML = '';
        }

        /**
         * Called on each clock tick (internal or external).
         * Increments tick counter and calls arpStep when enough ticks have accumulated for the current clock division.
         */
        function tick() {
            if (!arpRunning && tempoSource === 'external') return; // Don't process ticks if stopped in external mode

            tickCounter++;
            // >= allows catching up if ticks were missed/delayed
            if (tickCounter >= 0 && (tickCounter % clockDivisionCounterMax === 0)) {
                arpStep();
                // Optional: Reset counter relative to max to handle potential drift
                // tickCounter = tickCounter % clockDivisionCounterMax;
            }
        }


        /**
         * Handles MIDI clock tick messages (0xF8). Estimates BPM and clock division duration.
         */
        function handleMIDITick() {
            if (tempoSource === 'external') {
                const now = performance.now();
                // Shift history
                for (let i = 0; i < tickHistorySize - 1; i++) {
                    tickHistory[i] = tickHistory[i + 1];
                }
                tickHistory[tickHistorySize - 1] = now;
                tickIndex++; // Increment total ticks received

                if (tickIndex >= tickHistorySize) { // Enough history to calculate average
                    const firstTickTime = tickHistory[0];
                    const lastTickTime = tickHistory[tickHistorySize - 1];
                    const totalDuration = lastTickTime - firstTickTime;
                    const averageInterval = totalDuration / (tickHistorySize - 1);

                    if (averageInterval > 0) {
                        // Update BPM based on average tick interval
                        const calculatedBPM = 60000 / (averageInterval * 24);
                        // Apply smoothing or rounding if desired
                        bpm = Math.round(calculatedBPM);
                        // Update clock division duration based on the *latest* interval for responsiveness
                        const latestInterval = tickHistory[tickHistorySize - 1] - tickHistory[tickHistorySize - 2];
                        if (latestInterval > 0) {
                            clockDivisionDurationMs = latestInterval * clockDivisionCounterMax;
                        } else { // Fallback to average if latest is weird
                            clockDivisionDurationMs = averageInterval * clockDivisionCounterMax;
                        }
                        updateTempoDisplay(); // Update UI display
                    }
                } else if (tickIndex > 1) { // Initial ticks, use direct interval
                    const latestInterval = tickHistory[tickIndex - 1] - tickHistory[tickIndex - 2];
                    if (latestInterval > 0) {
                        bpm = Math.round(60000 / (latestInterval * 24));
                        clockDivisionDurationMs = latestInterval * clockDivisionCounterMax;
                        updateTempoDisplay();
                    }
                }
                // Process the actual arpeggiator step based on the tick
                tick();
            }
        }


        // --- MIDI Sending Helper Functions ---

        /**
         * Sends a raw MIDI note on message.
         * @param {number} note - MIDI note number.
         * @param {number} velocity - MIDI velocity (0-127).
         * @param {number} outputChannel - MIDI output channel (0-15).
         */
        function sendNoteOnHelper(note, velocity, outputChannel) {
            if (midiOutput && note >= 0 && note <= 127 && velocity > 0 && velocity <= 127 && outputChannel >= 0 && outputChannel <= 15) {
                // console.log(`Sending Note ON: Note=${note}, Vel=${velocity}, Chan=${outputChannel + 1}`);
                if (mpeOutputMode === 'mpe') {
                    // Basic MPE Note On - assumes pitch bend is centered (0x4000)
                    // A real MPE implementation would manage pitch bend per note.
                    // Sending Pitch Bend Range RPNs might be needed for the receiving synth.
                    // midiOutput.send([0xE0 + outputChannel, 0x00, 0x40]); // Pitch bend LSB=0, MSB=64 (center)
                    midiOutput.send([0x90 + outputChannel, note, velocity]);
                } else {
                    midiOutput.send([0x90 + outputChannel, note, velocity]);
                }
            }
        }

        /**
         * Sends a raw MIDI note off message.
         * @param {number} note - MIDI note number.
         * @param {number} outputChannel - MIDI output channel (0-15).
         * @param {number} [velocity=0] - Release velocity (often 0 or 64).
         */
        function sendNoteOffHelper(note, outputChannel, velocity = 0) {
            if (midiOutput && note >= 0 && note <= 127 && outputChannel >= 0 && outputChannel <= 15) {
                // console.log(`Sending Note OFF: Note=${note}, Vel=${velocity}, Chan=${outputChannel + 1}`);
                if (mpeOutputMode === 'mpe') {
                    // MPE Note Off uses velocity 0 on Note On or Note Off command
                    midiOutput.send([0x80 + outputChannel, note, velocity]);
                    // midiOutput.send([0x90 + outputChannel, note, 0]); // Alternative MPE Note Off
                } else {
                    midiOutput.send([0x80 + outputChannel, note, velocity]); // Non-MPE note off
                }
            }
        }

        /**
         * Schedules a Note Off message for a given note after a delay.
         * Stores the timeout ID in activeArpNotes.
         * @param {number} note - MIDI note number.
         * @param {number} delayMs - Delay in milliseconds.
         * @param {number} outputChannel - MIDI output channel (0-15).
         */
        function scheduleNoteOff(note, delayMs, outputChannel) {
            cancelNoteOff(note); // Clear any existing timeout for this note

            const timeoutId = setTimeout(() => {
                stopNote(note, outputChannel); // Use stopNote to ensure cleanup
            }, Math.max(0, delayMs)); // Ensure delay isn't negative

            const currentState = activeArpNotes.get(note);
            if (currentState) {
                activeArpNotes.set(note, {
                    ...currentState,
                    noteOffTimeoutId: timeoutId,
                    isExtended: false
                }); // Mark as not extended now
                updatePlaybackKeyboardKey(note); // Update key visuals
            }
            // If note wasn't active, it shouldn't reach here normally, but handle defensively
            // else { console.warn(`Scheduled Note Off for inactive note ${note}`); }
        }

        /**
         * Cancels a scheduled Note Off for a given note.
         * @param {number} note - MIDI note number.
         */
        function cancelNoteOff(note) {
            const noteState = activeArpNotes.get(note);
            if (noteState && noteState.noteOffTimeoutId !== null) {
                clearTimeout(noteState.noteOffTimeoutId);
                activeArpNotes.set(note, {
                    ...noteState,
                    noteOffTimeoutId: null
                });
                updatePlaybackKeyboardKey(note); // Update key visuals
            }
        }

        /**
         * Starts a note: sends Note On and adds it to activeArpNotes.
         * @param {number} note - MIDI note number.
         * @param {number} velocity - MIDI velocity.
         * @param {number} outputChannel - MIDI output channel.
         */
        function startNote(note, velocity, outputChannel) {
            // console.log(`Starting Note: ${note}`);
            // Prevent re-starting an already active note without stopping it first
            // Although cancelNoteOff might handle the timeout, the note might still be considered 'on'
            if (activeArpNotes.has(note)) {
                // console.warn(`Attempted to start already active note ${note}. Stopping first.`);
                // stopNote(note, activeArpNotes.get(note).outputChannel); // Stop cleanly before restarting
                cancelNoteOff(note); // Ensure any pending OFF is cancelled before ON
            }

            sendNoteOnHelper(note, velocity, outputChannel);
            activeArpNotes.set(note, {
                noteOffTimeoutId: null,
                isExtended: false,
                chordsHeldCount: 0,
                timeHeldDivisions: 0,
                outputChannel: outputChannel
            });
            updatePlaybackKeyboardKey(note); // Update visuals
        }

        /**
         * Stops a note: sends Note Off and removes it from activeArpNotes.
         * Also ensures any scheduled Note Off is cancelled.
         * @param {number} note - MIDI note number.
         * @param {number} outputChannel - MIDI output channel.
         */
        function stopNote(note, outputChannel) {
            // console.log(`Stopping Note: ${note}`);
            cancelNoteOff(note); // Ensure timeout is cleared if stopNote is called early
            if (activeArpNotes.has(note)) { // Check if it was actually active
                sendNoteOffHelper(note, outputChannel);
                activeArpNotes.delete(note);
                updatePlaybackKeyboardKey(note); // Update visuals
            }
            // else { console.warn(`Attempted to stop inactive note ${note}`); }
        }

        // --- End MIDI Sending Helper Functions ---


        /**
         * Handles incoming MIDI messages. Processes note on/off, MIDI clock messages, and aftertouch/pressure.
         * @param {MIDIMessageEvent} message - MIDI message event.
         */
        function onMIDIMessage(message) {
            const command = message.data[0];
            const commandHiBits = (command & 0xF0) >> 4;
            const commandLoBits = command & 0x0F;
            const byte1 = message.data.length > 1 ? message.data[1] : 0;
            const byte2 = message.data.length > 2 ? message.data[2] : 0;

            // --- MIDI Clock Handling ---
            if (command === 0xF8) { // MIDI Clock Tick
                handleMIDITick();
                return;
            }
            // --- MIDI Transport Handling (Placeholder) ---
            if (command === 0xFA) { // MIDI Start
                console.log("MIDI Start received");
                if (arpSyncMode === 'transport') {
                    // Reset counters/indices and start
                    resetRhythmIndex();
                    resetPatternIndex();
                    currentNoteIndex = 0;
                    stableShuffleIndex = 0;
                    tickCounter = -1; // Align with start
                    if (!arpRunning) startArpeggiator(); // Start if not already running
                }
                return;
            }
            if (command === 0xFC) { // MIDI Stop
                console.log("MIDI Stop received");
                if (arpSyncMode === 'transport') {
                    if (arpRunning) stopArpeggiator();
                }
                return;
            }
            if (command === 0xFB) { // MIDI Continue
                console.log("MIDI Continue received");
                if (arpSyncMode === 'transport') {
                    // Should ideally resume from where it stopped, but simple start for now
                    if (!arpRunning) startArpeggiator();
                }
                return;
            }


            // --- Channel Message Processing ---
            let processChannelMessage = false;
            let inputChannel = commandLoBits; // Channel is 0-15

            if (isMPEEnabled) {
                const globalChannel = parseInt(mpeGlobalInputChannel); // 1-16 or NaN
                const voiceChannelCount = mpeInputVoiceChannels; // 1-15

                if (mpeGlobalInputChannel === 'omni') {
                    // Allow Note On/Off on any channel (handle MPE mapping later if needed)
                    // Allow CC/Pressure on any channel (apply based on tracked note)
                    processChannelMessage = true;
                } else if (!isNaN(globalChannel)) {
                    // Check if it's the global channel OR a voice channel
                    const baseGlobalChannel = globalChannel - 1; // Convert to 0-15
                    if (inputChannel === baseGlobalChannel ||
                        (inputChannel > baseGlobalChannel && inputChannel <= baseGlobalChannel + voiceChannelCount)) {
                        processChannelMessage = true;
                    }
                }
            } else {
                // Non-MPE: Process messages on the selected global output channel (acting as input base)
                // Or Omni-like behavior if desired? Let's stick to base channel for now.
                const baseChannel = parseInt(mpeGlobalOutputChannel) - 1; // Use output setting as input base
                if (inputChannel === baseChannel) {
                    processChannelMessage = true;
                }
                // Could add an 'Omni' option for non-MPE input too
            }


            if (processChannelMessage) {
                if (commandHiBits === 0x9) { // Note On
                    const note = byte1;
                    const velocity = byte2;
                    if (velocity > 0) {
                        noteOn(note, 'midi', inputChannel); // Pass channel
                    } else {
                        // Note On with velocity 0 is equivalent to Note Off
                        noteOff(note, 'midi', inputChannel); // Pass channel
                    }
                } else if (commandHiBits === 0x8) { // Note Off
                    const note = byte1;
                    noteOff(note, 'midi', inputChannel); // Pass channel
                } else if (commandHiBits === 0xA) { // Polyphonic Aftertouch
                    const note = byte1;
                    const pressure = byte2;
                    // Find the original note if octave expanded
                    const originalNote = findOriginalNote(note);
                    if (originalNote !== null && notePressures.has(originalNote)) {
                        notePressures.set(originalNote, pressure);
                    }
                } else if (commandHiBits == 0xB) { // MIDI CC
                    const ccNumber = byte1;
                    const ccValue = byte2;

                    if (ccNumber === 64) { // Sustain Pedal (handle globally)
                        if (ccValue >= 64) { // Pedal Down
                            if (!isSustainPedalPressed) {
                                isSustainPedalPressed = true;
                                // console.log("Sustain ON");
                            }
                        } else { // Pedal Up
                            if (isSustainPedalPressed) {
                                isSustainPedalPressed = false;
                                // console.log("Sustain OFF");
                                let notesToRelease = [...sustainedNotesMIDI];
                                sustainedNotesMIDI.clear();
                                // Process release for notes that were sustained
                                notesToRelease.forEach(sustainedNote => {
                                    // Find the channel this note might have been on if MPE
                                    let noteChannel = -1;
                                    if (isMPEEnabled) {
                                        for (let ch = 0; ch < 16; ++ch) {
                                            if (mpeChannelNotes[ch] === sustainedNote) {
                                                noteChannel = ch;
                                                break;
                                            }
                                        }
                                    }
                                    removeHeldNote(sustainedNote, 'midi', noteChannel !== -1 ? noteChannel : null);
                                });
                            }
                        }
                        return; // Sustain handled, exit
                    }

                    // Handle MPE CC 74 (Y-axis/Timbre)
                    if (isMPEEnabled && ccNumber == 74) {
                        const channelNote = mpeChannelNotes[inputChannel];
                        if (channelNote !== null) {
                            const originalNote = findOriginalNote(channelNote);
                            if (originalNote !== null) {
                                noteMPEYAxis.set(originalNote, ccValue);
                            }
                        }
                    }
                    // --- Add other CC handling here if needed ---

                } else if (commandHiBits === 0xD) { // Channel Pressure (Aftertouch)
                    const pressure = byte1;
                    if (isMPEEnabled) {
                        // Apply pressure to the note associated with this specific MPE channel
                        const channelNote = mpeChannelNotes[inputChannel];
                        if (channelNote !== null) {
                            const originalNote = findOriginalNote(channelNote);
                            if (originalNote !== null && notePressures.has(originalNote)) {
                                notePressures.set(originalNote, pressure);
                            }
                        }
                    } else {
                        // Non-MPE: Apply channel pressure to *all* currently held raw MIDI notes
                        // Check if the message is on the expected base channel
                        const baseChannel = parseInt(mpeGlobalOutputChannel) - 1;
                        if (inputChannel === baseChannel) {
                            rawHeldNotes.forEach(rawNote => {
                                if (heldNotesMIDI.has(rawNote) && notePressures.has(rawNote)) { // Ensure it's a MIDI note
                                    notePressures.set(rawNote, pressure);
                                }
                            });
                        }
                    }
                }
                // --- Add Pitch Bend handling here if needed ---
                // else if (commandHiBits === 0xE) { // Pitch Bend
                //    const lsb = byte1;
                //    const msb = byte2;
                //    const bendValue = ((msb << 7) | lsb) - 8192; // Range -8192 to +8191
                //    if (isMPEEnabled) {
                //        const channelNote = mpeChannelNotes[inputChannel];
                //        // Apply bend to channelNote
                //    } else {
                //        // Apply bend globally or to notes on base channel
                //    }
                // }
            }
        }


        /**
         * Finds the original raw note corresponding to an octave-expanded note.
         * @param {number} expandedNote - The potentially octave-expanded note.
         * @returns {number | null} - The original raw note, or null if not found.
         */
        function findOriginalNote(expandedNote) {
            if (rawHeldNotes.includes(expandedNote)) {
                return expandedNote; // It wasn't expanded or was the base note
            }
            return octaveExpandedNoteMap.get(expandedNote) || null;
        }


        /**
         * Executes a single arpeggiator step. Determines note(s) to play based on rhythms, patterns and arpeggio mode.
         * Called by the clock tick. Handles note starting, stopping, and gate extension logic.
         */
        function arpStep() {
            if (!arpRunning) {
                return;
            }

            unhighlightCurrentStep();

            // --- Update time held for extended notes AND Check Max Time Limit ---
            const notesToStopTimeLimit = [];
            activeArpNotes.forEach((state, note) => {
                // Only increment time if it's actually being extended (prevents drift if logic elsewhere fails)
                if (state.isExtended && state.noteOffTimeoutId === null) {
                    state.timeHeldDivisions++;
                    // Check if THIS increment pushed it over the limit
                    if (state.timeHeldDivisions >= maxTimeExtensionDivisions) { // Use >= to stop ON the limit step
                        // console.log(`Note ${note} reached max time extension (${state.timeHeldDivisions}/${maxTimeExtensionDivisions}).`);
                        notesToStopTimeLimit.push(note);
                    }
                }
                // Reset time if note is active but NOT extended (e.g. finished extending last step)
                else if (!state.isExtended) {
                    state.timeHeldDivisions = 0;
                    state.chordsHeldCount = 0; // Also reset chord count if not extended
                }
            });
            // Stop notes exceeding time limit *before* processing current step's notes
            notesToStopTimeLimit.forEach(note => {
                if (activeArpNotes.has(note)) {
                    const state = activeArpNotes.get(note);
                    // Force stop even if it was extended
                    state.isExtended = false; // Mark as not extended anymore
                    stopNote(note, state.outputChannel); // Send note off and remove
                }
            });


            // --- Determine notes to potentially play ---
            let notesToArpSource = heldNotes.length > 0 ? heldNotes : [];
            if (arpSyncMode === 'free' && notesToArpSource.length === 0) {
                // ... (rest of free sync logic remains the same) ...
                advanceRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null);
                highlightCurrentStep('rest', null);
                return;
            }

            if (notesToArpSource.length === 0 && arpSyncMode !== 'free') {
                stopArpeggiator();
                return;
            }

            // --- Handle Shuffle Mode Updates ---
            // ... (shuffle logic remains the same) ...
            if (arpMode === 'shuffled') {
                if (currentNoteIndex === 0 && !arraysAreEqual(notesToArpSource, lastNotesToArp)) {
                    shuffledNotesOrder = generateShuffledNoteList(notesToArpSource);
                    currentModeNoteList = shuffledNotesOrder;
                    lastNotesToArp = [...notesToArpSource];
                } else if (currentNoteIndex % (shuffledNotesOrder.length || 1) === 0 && currentNoteIndex > 0) {
                    shuffledNotesOrder = generateShuffledNoteList(notesToArpSource);
                    currentModeNoteList = shuffledNotesOrder;
                    lastNotesToArp = [...notesToArpSource];
                }
            } else if (arpMode === 'stableShuffled') {
                if (stableShuffleIndex % (stableShuffledOrder.length || 1) === 0 && stableShuffleIndex > 0) {
                    stableShuffleIndex = 0;
                }
            }

            // --- Rhythm and Pattern Logic ---
            let noteForStep = '';
            let chordForStep = null;
            let stepType = null;
            let advanceNoteIndices = true;

            const currentRhythmEvent = (rhythm && rhythm.length > 0) ? rhythm[currentRhythmIndex % rhythm.length] : RHYTHM_BEAT;
            const patternEventActive = !isPatternDisabled;
            const rhythmEventActive = !isRhythmDisabled;

            let effectiveRhythmEvent = (rhythmEventActive) ? currentRhythmEvent : RHYTHM_BEAT;

            if (effectiveRhythmEvent === RHYTHM_BEAT) {
                let patternProcessed = false;
                let patternIterations = 0;
                const maxPatternIterations = (patternRhythm?.length || 1) * 2; // Safety limit based on pattern length

                while (!patternProcessed && patternIterations < maxPatternIterations) {
                    const currentPatternEvent = (patternRhythm && patternRhythm.length > 0) ? patternRhythm[currentPatternIndex % patternRhythm.length] : PATTERN_NOTE;
                    const effectivePatternEvent = patternEventActive ? currentPatternEvent : PATTERN_NOTE;

                    if (effectivePatternEvent === PATTERN_NOTE) {
                        // --- Determine Note/Chord to Play ---
                        chordForStep = null; // Reset for this step
                        noteForStep = ''; // Reset for this step

                        if (arpMode === 'chord' || arpMode === 'chordN') {
                            if (currentModeNoteList && currentModeNoteList.length > 0) {
                                const listIndex = currentNoteIndex % currentModeNoteList.length;
                                chordForStep = currentModeNoteList[listIndex];
                                if (chordForStep && chordForStep.length > 0) {
                                    playNotes(chordForStep, subArpMode); // Play the chord (handles extension internally)
                                    stepType = 'note';
                                    highlightCurrentStep('note', chordForStep, true);
                                } else {
                                    stepType = 'rest';
                                    highlightCurrentStep('rest', null);
                                    advanceNoteIndices = false;
                                }
                            } else {
                                stepType = 'rest';
                                highlightCurrentStep('rest', null);
                                advanceNoteIndices = false;
                            }
                        } else if (arpMode === 'random') {
                            // ... (random logic unchanged) ...
                            if (notesToArpSource.length > 0) {
                                noteForStep = notesToArpSource[Math.floor(Math.random() * notesToArpSource.length)];
                            } else {
                                advanceNoteIndices = false;
                            }
                        } else if (arpMode === 'walk' || arpMode === 'normalWalk') {
                            // ... (walk logic unchanged, index moved later) ...
                            if (currentModeNoteList && currentModeNoteList.length > 0) {
                                noteForStep = currentModeNoteList[currentNoteIndex % currentModeNoteList.length];
                            } else {
                                advanceNoteIndices = false;
                            }
                        } else { // Standard modes
                            // ... (standard logic unchanged) ...
                            if (currentModeNoteList && currentModeNoteList.length > 0) {
                                const listIndex = currentNoteIndex % currentModeNoteList.length;
                                noteForStep = currentModeNoteList[listIndex];
                            } else {
                                advanceNoteIndices = false;
                            }
                        }

                        // --- Play Single Note (if determined and not chord mode) ---
                        if (noteForStep !== '' && arpMode !== 'chord' && arpMode !== 'chordN') {
                            playNotes(noteForStep); // Play single note (extension N/A here)
                            stepType = 'note';
                            highlightCurrentStep('note', noteForStep);
                        } else if (stepType !== 'note' && stepType !== 'rest') { // If not already determined as note/rest by chord logic
                            stepType = 'rest'; // No single note determined or chord mode handled it
                            highlightCurrentStep('rest', null);
                            advanceNoteIndices = false;
                        }

                        patternProcessed = true;
                        advancePatternIndex();

                    } else if (effectivePatternEvent === PATTERN_SKIP) {
                        // ... (skip logic unchanged) ...
                        advancePatternIndex();
                        if (arpMode !== 'random' && arpMode !== 'walk' && arpMode !== 'normalWalk') {
                            currentNoteIndex++;
                            if (arpMode === 'stableShuffled') stableShuffleIndex++;
                        }
                        stepType = 'skip'; // Mark step as skip for display
                        patternIterations++;
                        // Do not set patternProcessed = true, continue loop
                    } else {
                        // ... (error handling unchanged) ...
                        console.error("Unknown pattern event:", currentPatternEvent);
                        stepType = 'error';
                        patternProcessed = true;
                        advancePatternIndex();
                        advanceNoteIndices = false;
                    }
                    // End of while loop checks
                    if (patternIterations >= maxPatternIterations && !patternProcessed) {
                        console.warn("Pattern loop hit iteration limit (all skips?). Treating as rest.");
                        stepType = 'rest';
                        advanceNoteIndices = false;
                        patternProcessed = true; // Break loop
                    }
                } // End while pattern not processed


            } else if (effectiveRhythmEvent === RHYTHM_REST) {
                stepType = 'rest';
                highlightCurrentStep('rest', null);
                advanceNoteIndices = false;
                // Do not advance pattern index on rest
            } else {
                // ... (rhythm error handling unchanged) ...
                console.error("Unknown rhythm event:", currentRhythmEvent);
                stepType = 'error_arp_rhythm';
                highlightCurrentStep('error', null);
                advanceNoteIndices = false;
            }

            // --- Update Playback Display ---
            if (stepType !== null) {
                let noteToDisplay = null;
                let isChordDisplay = (stepType === 'note' && !!chordForStep);
                if (stepType === 'note' && !isChordDisplay) {
                    noteToDisplay = noteForStep;
                }
                updatePlaybackDisplay(stepType, noteToDisplay, isChordDisplay);
            }

            // --- Advance Indices ---
            advanceRhythmIndex(); // Always advance rhythm index

            if (advanceNoteIndices) {
                if (arpMode === 'walk') {
                    advanceWalkIndex();
                } else if (arpMode === 'normalWalk') {
                    advanceNormalWalkIndex();
                } else if (arpMode === 'stableShuffled') {
                    stableShuffleIndex++;
                    if (stableShuffledOrder && stableShuffledOrder.length > 0) { // Wrap check
                        stableShuffleIndex %= stableShuffledOrder.length;
                    } else {
                        stableShuffleIndex = 0;
                    }
                } else if (arpMode !== 'random') {
                    currentNoteIndex++;
                    if (currentModeNoteList && currentModeNoteList.length > 0) { // Wrap check
                        currentNoteIndex %= currentModeNoteList.length;
                    } else {
                        currentNoteIndex = 0;
                    }
                }
            }
        }


        /**
         * Calculates velocity based on pressure, base velocity, and max velocity.
         * @param {number} pressure - MIDI pressure value (0-127).
         * @returns {number} - Calculated velocity (1-127).
         */
        function calculateVelocity(pressure) {
            // Ensure pressure is within valid range
            pressure = Math.max(0, Math.min(127, pressure || 0));
            let velocity = baseVelocityValue + (maxVelocityValue - baseVelocityValue) * (pressure / 127);
            // Ensure velocity is within MIDI range 1-127 (0 means note off)
            return Math.max(1, Math.min(127, Math.round(velocity)));
        }

        /**
         * Finds the next actual played chord info in ChordN mode, skipping rests/skips.
         * @param {number} maxLookahead - Maximum number of steps to look ahead.
         * @returns {{ nextChordIndex: number | null, nextChordNotes: number[] | null, stepsToNextChord: number }}
         */
        function findNextPlayedChordInfo(maxLookahead = LOOKAHEAD_MAX_STEPS) {
            if (arpMode !== 'chordN' || !currentModeNoteList || currentModeNoteList.length === 0) {
                return {
                    nextChordIndex: null,
                    nextChordNotes: null,
                    stepsToNextChord: 0
                };
            }

            let simRhythmIndex = currentRhythmIndex;
            let simPatternIndex = currentPatternIndex;
            let simChordIndex = currentNoteIndex;
            let steps = 0;

            for (let i = 0; i < maxLookahead; i++) {
                steps++;
                simRhythmIndex = (simRhythmIndex + 1) % (rhythm?.length || 1);
                const rEvent = (rhythm && rhythm.length > 0 && !isRhythmDisabled) ? rhythm[simRhythmIndex] : RHYTHM_BEAT;

                if (rEvent === RHYTHM_BEAT) {
                    simPatternIndex = (simPatternIndex + 1) % (patternRhythm?.length || 1);
                    const pEvent = (patternRhythm && patternRhythm.length > 0 && !isPatternDisabled) ? patternRhythm[simPatternIndex] : PATTERN_NOTE;

                    if (pEvent === PATTERN_NOTE) {
                        // Found the next played chord step
                        simChordIndex = (simChordIndex + 1) % currentModeNoteList.length;
                        return {
                            nextChordIndex: simChordIndex,
                            nextChordNotes: currentModeNoteList[simChordIndex],
                            stepsToNextChord: steps
                        };
                    } else if (pEvent === PATTERN_SKIP) {
                        // Skip advances the chord index without playing
                        simChordIndex = (simChordIndex + 1) % currentModeNoteList.length;
                    }
                }
                // If RHYTHM_REST, just continue looping without advancing pattern/chord indices
            }

            // Lookahead limit reached without finding a note
            // console.warn("ChordN lookahead reached limit without finding next note.");
            return {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: steps
            };
        }


        /**
         * Plays a single note or an array of notes using the helper functions.
         * Handles sub-arpeggiation and ChordN Gate Extension logic.
         * @param {number|number[]} notesOrChord - MIDI note number or array of MIDI note numbers to play.
         * @param {string} [subArpModeOverride] - Optional sub-arpeggiation mode override.
         */
        function playNotes(notesOrChord, subArpModeOverride = subArpMode) {
            if (!midiOutput) return;

            const outputChannel = parseInt(mpeGlobalOutputChannel) - 1; // Base channel 0-15
            const notesArray = Array.isArray(notesOrChord) ? notesOrChord : [notesOrChord];
            if (notesArray.length === 0) return;

            const isChordModeActive = arpMode === 'chord' || arpMode === 'chordN';
            const useSubArp = isChordModeActive && notesArray.length > 1 && subArpScalePercentage > 0;

            // --- ChordN Gate Extension Lookahead (Only for ChordN mode) ---
            let nextPlayedInfo = {
                nextChordIndex: null,
                nextChordNotes: null,
                stepsToNextChord: 0
            };
            if (arpMode === 'chordN') {
                nextPlayedInfo = findNextPlayedChordInfo();
            }

            // --- Determine Gate Multiplier (Gate Flex) ---
            const currentGateMultiplier = (isGateFlexEnabled && rhythmGateMultipliers && rhythm.length > 0) ?
                (rhythmGateMultipliers[currentRhythmIndex % rhythm.length] || 1) :
                1;

            // --- Process Each Note ---
            if (useSubArp) {
                // Sub-Arpeggiation Logic for Chords (No gate extension applied here)
                const subArpDuration = (clockDivisionDurationMs * subArpScalePercentage) / 100;
                const noteSpacing = notesArray.length > 1 ? subArpDuration / notesArray.length : 0;

                let subArpedChordNotes = [...notesArray];
                // Apply sub-arp ordering
                switch (subArpModeOverride) {
                    case 'up':
                        subArpedChordNotes.sort((a, b) => a - b);
                        break;
                    case 'down':
                        subArpedChordNotes.sort((a, b) => b - a);
                        break;
                    case 'random':
                        subArpedChordNotes.sort(() => Math.random() - 0.5);
                        break;
                    case 'converge':
                        subArpedChordNotes = generateConvergeNoteList(subArpedChordNotes);
                        break;
                    case 'diverge':
                        subArpedChordNotes = generateDivergeNoteList(subArpedChordNotes);
                        break;
                    default:
                        subArpedChordNotes.sort((a, b) => a - b);
                        break;
                }

                subArpedChordNotes.forEach((expandedNote, index) => {
                    const originalNote = findOriginalNote(expandedNote);
                    if (originalNote === null) return;

                    const pressure = notePressures.get(originalNote) || defaultNotePressure;
                    const velocity = calculateVelocity(pressure);
                    const delay = noteSpacing * index;

                    setTimeout(() => {
                        // Check if note is ALREADY active and extended from the main chord before starting sub-arp instance
                        // This avoids restarting an already held note just for sub-arp
                        if (!activeArpNotes.has(expandedNote) || !activeArpNotes.get(expandedNote).isExtended) {
                            startNote(expandedNote, velocity, outputChannel);
                            const subArpGateDurationMs = calculateGateDuration(noteSpacing > 0 ? noteSpacing : clockDivisionDurationMs, gateLengthPercentage, 1);
                            scheduleNoteOff(expandedNote, subArpGateDurationMs, outputChannel);
                        } else {
                            // Note was already held (extended), sub-arp doesn't retrigger it, just skips scheduling off
                            // console.log(`Sub-arp skipping already extended note: ${expandedNote}`);
                        }
                    }, delay);
                });

            } else {
                // Play notes simultaneously (or single note)
                notesArray.forEach(expandedNote => {
                    const originalNote = findOriginalNote(expandedNote);
                    if (originalNote === null) return;

                    const pressure = notePressures.get(originalNote) || defaultNotePressure;
                    const velocity = calculateVelocity(pressure);
                    const noteIsActive = activeArpNotes.has(expandedNote);
                    const currentState = noteIsActive ? activeArpNotes.get(expandedNote) : null;

                    // --- Gate Extension Logic ---
                    let shouldExtend = false;
                    const isInNextChord = (arpMode === 'chordN' && nextPlayedInfo.nextChordNotes?.includes(expandedNote));

                    if (noteIsActive && currentState) {
                        // --- Logic for ALREADY ACTIVE note ---
                        cancelNoteOff(expandedNote); // Essential: Cancel pending off from previous step/decision
                        currentState.timeHeldDivisions++; // Increment time regardless

                        // Check if we CAN continue extending
                        const canContinueExtendingCount = currentState.chordsHeldCount < (maxChordExtension - 1); // e.g., if max=2, count must be 0. If max=3, count must be 0 or 1.
                        const canContinueExtendingTime = (currentState.timeHeldDivisions + nextPlayedInfo.stepsToNextChord) <= maxTimeExtensionDivisions;
                        const continueExtending = arpMode === 'chordN' && isInNextChord && canContinueExtendingCount && canContinueExtendingTime;

                        if (continueExtending) {
                            // Continue extending
                            currentState.isExtended = true;
                            currentState.chordsHeldCount++;
                            currentState.noteOffTimeoutId = null; // Ensure no timeout
                            // console.log(`Extended note ${expandedNote} (Chords: ${currentState.chordsHeldCount}, Time: ${currentState.timeHeldDivisions})`);
                        } else {
                            // Stop extending (or was never extended), schedule normal note off
                            currentState.isExtended = false;
                            currentState.chordsHeldCount = 0; // Reset count
                            const gateDurationMs = calculateGateDuration(clockDivisionDurationMs, gateLengthPercentage, currentGateMultiplier);
                            scheduleNoteOff(expandedNote, gateDurationMs, outputChannel);
                            // console.log(`Stopped/Not extending ${expandedNote}, scheduling off in ${gateDurationMs.toFixed(0)}ms`);
                        }
                        updatePlaybackKeyboardKey(expandedNote); // Update visuals based on new state

                    } else {
                        // --- Logic for NEWLY STARTED note ---
                        // Check if we SHOULD start extending this new note
                        const canStartExtending = maxChordExtension > 1; // Need at least 2 to allow any extension
                        const canStartTime = (nextPlayedInfo.stepsToNextChord) <= maxTimeExtensionDivisions; // Time check uses 0 for current timeHeld
                        const startExtending = arpMode === 'chordN' && isInNextChord && canStartExtending && canStartTime;

                        // Start the note regardless
                        startNote(expandedNote, velocity, outputChannel);
                        const newState = activeArpNotes.get(expandedNote); // Get the newly created state

                        if (startExtending && newState) {
                            // Start extending immediately
                            newState.isExtended = true;
                            newState.chordsHeldCount = 1; // It's being held for the *first* time *into* the next chord
                            newState.timeHeldDivisions = 0; // Starts at 0 for this hold period
                            newState.noteOffTimeoutId = null; // No timeout scheduled
                            // console.log(`Started extended note ${expandedNote}`);
                        } else if (newState) {
                            // Start with normal gate if not extending
                            newState.isExtended = false; // Ensure state is correct
                            newState.chordsHeldCount = 0;
                            newState.timeHeldDivisions = 0;
                            const gateDurationMs = calculateGateDuration(clockDivisionDurationMs, gateLengthPercentage, currentGateMultiplier);
                            scheduleNoteOff(expandedNote, gateDurationMs, outputChannel);
                            // console.log(`Started normal note ${expandedNote}, scheduling off in ${gateDurationMs.toFixed(0)}ms`);
                        }
                        updatePlaybackKeyboardKey(expandedNote); // Update visuals
                    }
                }); // End notesArray.forEach
            } // End else (play simultaneously)
        }


        /**
         * Sends MIDI note off messages for all notes currently managed by the arpeggiator.
         * Clears the activeArpNotes map.
         */
        function allNotesOff() {
            if (activeArpNotes.size > 0) {
                // console.log("Sending All Notes Off for Arp Notes:", Array.from(activeArpNotes.keys()));
                activeArpNotes.forEach((state, note) => {
                    stopNote(note, state.outputChannel); // Use stopNote for proper cleanup
                });
                activeArpNotes.clear(); // Ensure map is cleared
            }
            // We don't control notes held directly via MIDI/UI here, only arp-generated ones.
        }

        /**
         * Updates the playback display with the latest arpeggiator step.
         * @param {string} stepType - Type of step ('note', 'rest', 'skip', 'error').
         * @param {number|null} note - MIDI note number for 'note' steps, null otherwise.
         * @param {boolean} [isChord=false] - True if a chord was played in this step, false otherwise.
         */
        function updatePlaybackDisplay(stepType, note, isChord = false) {
            if (stepType === null) return;

            const stepElem = document.createElement('div');
            stepElem.classList.add('playback-step');
            stepElem.classList.add(stepType); // Applies 'note', 'rest', 'skip' class

            if (stepType === 'note') {
                if (isChord) {
                    if (arpMode === 'chordN' && currentModeNoteList && currentModeNoteList.length > 0) {
                        // Display chord number (1-based index)
                        const displayIndex = (currentNoteIndex % currentModeNoteList.length) + 1;
                        stepElem.textContent = `Ch${displayIndex}`;
                    } else {
                        stepElem.textContent = 'Ch'; // Generic chord
                    }
                } else if (note !== null) {
                    stepElem.textContent = midiNoteToName(note);
                } else {
                    stepElem.textContent = '?'; // Note expected but null
                }
            } else if (stepType === 'rest') {
                stepElem.textContent = 'R';
            } else if (stepType === 'skip') {
                stepElem.textContent = 'S';
            } else if (stepType === 'error') {
                stepElem.textContent = '!';
            }

            playbackDisplayElem.appendChild(stepElem);

            // Scroll display
            while (playbackDisplayElem.children.length > maxPlaybackSteps) {
                playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            }
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        /**
         * Generates the piano keyboard UI.
         */
        function generatePianoKeyboardUI() {
            const pianoKeyboard = document.getElementById('pianoKeyboard');
            pianoKeyboard.innerHTML = ''; // Clear existing
            const startNote = 48; // Low C (C3)
            const numberOfKeys = 25; // C3 to C5

            for (let i = 0; i < numberOfKeys; i++) {
                const noteValue = startNote + i;
                if (noteValue > 127) break; // Stay within MIDI range
                const noteName = notes[noteValue % 12];
                const key = document.createElement('div');
                key.classList.add('key');
                key.dataset.note = noteValue;
                // key.textContent = noteName; // Display name on key
                key.title = midiNoteToName(noteValue); // Tooltip with full name
                key.id = `pianoKey-${noteValue}`;

                if (noteName.includes('#')) {
                    key.classList.add('black-key');
                } else {
                    key.classList.add('white-key');
                }

                // Use mousedown/mouseup for better click-and-hold feel if desired
                // key.addEventListener('mousedown', function() { noteOn(noteValue, 'ui'); });
                // key.addEventListener('mouseup', function() { noteOff(noteValue, 'ui'); }); // Requires separate noteOff UI logic
                // Simple click toggle for now:
                key.addEventListener('click', function() {
                    noteOn(noteValue, 'ui'); // noteOn handles toggle for UI source
                });


                pianoKeyboard.appendChild(key);
            }
        }

        /**
         * Updates the visual state of a piano key in the UI.
         * @param {number} note - MIDI note number of the key.
         * @param {string|null} source - Source of the hold ('ui', 'midi', or null to reset).
         */
        function updatePianoKeyboardUI(note, source) {
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (!keyElement) return;

            // Remove all state classes first
            keyElement.classList.remove('key-held-ui', 'key-held-midi', 'key-current');

            // Re-apply based on current state
            if (heldNotesUI.has(note)) {
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesMIDI.has(note)) {
                keyElement.classList.add('key-held-midi');
            }
            // 'key-current' is handled by highlightPianoKeys
        }

        /**
         * Highlights piano keys in the UI to indicate current arpeggio notes.
         * Unhighlights any previously highlighted keys.
         * @param {number|number[]} notesToHighlight - MIDI note number or array of MIDI note numbers of the keys to highlight.
         */
        function highlightPianoKeys(notesToHighlight) {
            unhighlightPianoKeys(); // Clear previous highlight
            if (!notesToHighlight) return;

            const notesArray = Array.isArray(notesToHighlight) ? notesToHighlight : [notesToHighlight];
            if (notesArray.length > 0) {
                notesArray.forEach(note => {
                    const keyElement = document.getElementById(`pianoKey-${note}`);
                    if (keyElement) {
                        keyElement.classList.add('key-current');
                    }
                });
                // Store the primary (first) note for potential reference, though less critical now
                highlightedPianoKey = notesArray[0];
            }
        }

        /**
         * Unhighlights all highlighted piano keys in the interactive keyboard.
         */
        function unhighlightPianoKeys() {
            const currentHighlightedKeys = document.querySelectorAll('#pianoKeyboard .key.key-current');
            currentHighlightedKeys.forEach(key => {
                key.classList.remove('key-current');
            });
            highlightedPianoKey = null;
        }

        /**
         * Highlights a rhythm step in the UI to indicate it's the current step.
         * Unhighlights any previously highlighted step in the same rhythm display.
         * @param {string} displayElementId - ID of the rhythm display ('patternDisplay' or 'rhythmDisplay').
         * @param {number} stepIndex - Index of the step to highlight.
         * @param {number} [gateExtension=0] - Number of steps to extend the gate highlight over (for gate flex).
         */
        function highlightRhythmStep(displayElementId, stepIndex, gateExtension = 0) {
            unhighlightRhythmStep(displayElementId); // Clear previous highlights for this display
            const rhythmLength = (displayElementId === 'patternDisplay' ? patternRhythm?.length : rhythm?.length) || 0;
            if (rhythmLength === 0) return; // No steps to highlight

            const actualIndex = stepIndex % rhythmLength; // Ensure index is valid
            const stepElement = document.getElementById(`${displayElementId}-step-${actualIndex}`);

            if (stepElement) {
                stepElement.classList.add('current-step');

                // Apply gate extension highlight only to Rhythm display if enabled
                if (isGateFlexEnabled && displayElementId === 'rhythmDisplay' && gateExtension > 1) {
                    for (let i = 1; i < gateExtension; i++) {
                        const extendedStepIndex = (actualIndex + i) % rhythmLength;
                        const extendedStepElement = document.getElementById(`${displayElementId}-step-${extendedStepIndex}`);
                        if (extendedStepElement) {
                            extendedStepElement.classList.add('gate-extended-step');
                        }
                    }
                }
            }
        }

        /**
         * Unhighlights the currently highlighted rhythm step for a given rhythm display.
         * @param {string} displayElementId - ID of the rhythm display ('patternDisplay' or 'rhythmDisplay').
         */
        function unhighlightRhythmStep(displayElementId) {
            const currentHighlighted = document.querySelector(`#${displayElementId} .current-step`);
            if (currentHighlighted) {
                currentHighlighted.classList.remove('current-step');
            }
            // Clear gate extension highlights specifically for rhythm display
            if (displayElementId === 'rhythmDisplay') {
                const gateExtendedSteps = document.querySelectorAll('#rhythmDisplay .rhythm-step.gate-extended-step');
                gateExtendedSteps.forEach(step => step.classList.remove('gate-extended-step'));
            }
        }

        /**
         * Highlights the current step in the pattern rhythm display, only if pattern is active.
         */
        function highlightCurrentPatternStep() {
            // Check if patternRhythm is valid and pattern is enabled
            if (!isPatternDisabled && patternRhythm && patternRhythm.length > 0) {
                // Highlight the step *about to be* processed or just processed
                highlightRhythmStep('patternDisplay', currentPatternIndex % patternRhythm.length);
            } else {
                unhighlightRhythmStep('patternDisplay'); // Clear if disabled
            }
        }

        /**
         * Highlights the current step in the arpeggio rhythm display, only if rhythm is active.
         * Calculates gate extension based on the current rhythm step.
         */
        function highlightCurrentArpRhythmStep() {
            // Check if rhythm is valid and enabled
            if (!isRhythmDisabled && rhythm && rhythm.length > 0) {
                const currentIndex = currentRhythmIndex % rhythm.length;
                // Calculate gate extension multiplier for the *current* step
                const gateExt = (isGateFlexEnabled && rhythmGateMultipliers && rhythmGateMultipliers.length > currentIndex) ?
                    rhythmGateMultipliers[currentIndex] :
                    0;
                highlightRhythmStep('rhythmDisplay', currentIndex, gateExt);
            } else {
                unhighlightRhythmStep('rhythmDisplay'); // Clear if disabled
            }
        }


        /**
         * Unhighlights all current step highlights (rhythm steps and interactive piano key).
         */
        function unhighlightCurrentStep() {
            unhighlightRhythmStep('patternDisplay');
            unhighlightRhythmStep('rhythmDisplay');
            unhighlightPianoKeys();
            // Playback piano highlight is handled per-note by activeArpNotes updates
        }

        /**
         * Highlights the current arpeggiator step in the UI (rhythm steps and interactive piano key).
         * @param {string} stepType - Type of step ('note', 'rest', 'skip').
         * @param {number|number[]|null} noteOrChord - MIDI note number, chord array, or null.
         * @param {boolean} [isChord=false] - True if a chord was played.
         */
        function highlightCurrentStep(stepType, noteOrChord, isChord = false) {
            // Clear previous highlights first
            unhighlightPianoKeys();
            // unhighlightPlaybackPianoKeys(); // Don't clear playback keys here

            highlightCurrentArpRhythmStep();
            highlightCurrentPatternStep();

            if (stepType === 'note') {
                if (isChord && noteOrChord) {
                    highlightPianoKeys(noteOrChord); // Highlight chord on interactive keyboard
                } else if (!isChord && noteOrChord !== null) {
                    highlightPianoKeys(noteOrChord); // Highlight single note
                }
            }
            // Playback keyboard highlighting is now driven by the activeArpNotes map updates
        }

        /**
         * Generates the non-interactive playback piano keyboard UI.
         */
        function generatePlaybackPianoKeyboardUI() {
            const playbackKeyboard = document.getElementById('playbackKeyboardDisplay');
            playbackKeyboard.innerHTML = ''; // Clear existing
            const startNote = 36; // C2
            const numberOfKeys = 61; // 5 octaves (C2 to C7)

            for (let i = 0; i < numberOfKeys; i++) {
                const noteValue = startNote + i;
                if (noteValue > 127) break;
                const noteName = notes[noteValue % 12];
                const key = document.createElement('div');
                key.classList.add('playback-key');
                key.dataset.note = noteValue;
                key.id = `playbackKey-${noteValue}`;

                if (noteName && noteName.includes('#')) {
                    key.classList.add('playback-black-key');
                } else {
                    key.classList.add('playback-white-key');
                }
                playbackKeyboard.appendChild(key);
            }
        }

        /**
         * Updates the visual state of the playback piano keyboard UI based on held and playing notes.
         * Called less frequently now, individual keys updated by updatePlaybackKeyboardKey.
         */
        function updatePlaybackKeyboardUI() {
            const playbackKeys = document.querySelectorAll('.playback-key');
            playbackKeys.forEach(key => {
                const note = parseInt(key.dataset.note);
                updatePlaybackKeyboardKey(note); // Update each key's state
            });
        }

        /**
         * Updates the visual state of a single key on the playback piano keyboard.
         * Reflects held status (UI, MIDI, Octave), current playing status, and gate extension.
         * @param {number} note - The MIDI note number of the key to update.
         */
        function updatePlaybackKeyboardKey(note) {
            const keyElement = document.getElementById(`playbackKey-${note}`);
            if (!keyElement) return;

            const isHeldUI = heldNotesUI.has(note);
            const isHeldMIDI = heldNotesMIDI.has(note);
            // Check if it's an octave-expanded note (in heldNotes but not in rawHeldNotes)
            const isHeldOctave = heldNotes.includes(note) && !rawHeldNotes.includes(note);
            const isActiveArp = activeArpNotes.has(note);
            const isGateExtended = isActiveArp && activeArpNotes.get(note).isExtended;

            // Remove potentially conflicting classes first
            keyElement.classList.remove('key-held-ui', 'key-held-midi', 'key-held-octave-expanded', 'key-current', 'key-gate-extended');

            // Apply classes based on state (priority might matter visually)
            if (isGateExtended) {
                keyElement.classList.add('key-gate-extended');
            } else if (isActiveArp) { // Currently playing via arp (not extended)
                keyElement.classList.add('key-current');
            } else if (isHeldUI) {
                keyElement.classList.add('key-held-ui');
            } else if (isHeldMIDI) {
                keyElement.classList.add('key-held-midi');
            } else if (isHeldOctave) {
                keyElement.classList.add('key-held-octave-expanded');
            }
            // If none of the above, the key will have its default playback style
        }


        /**
         * Highlights piano keys on the playback keyboard (OBSOLETE - Use updatePlaybackKeyboardKey).
         * Kept for reference, should not be called directly.
         * @param {number|number[]} notes - MIDI note number or array of MIDI note numbers to highlight.
         */
        // function highlightPlaybackPianoKeys(notes) {
        //  // This logic is now handled by updates based on activeArpNotes
        // }

        /**
         * Unhighlights the currently highlighted piano key on the playback keyboard (OBSOLETE).
         */
        function unhighlightPlaybackPianoKeys() {
            // This is implicitly handled by updatePlaybackKeyboardKey removing 'key-current'
            // No need to manually track highlightedPlaybackPianoKey anymore
            const currentHighlightedKeys = document.querySelectorAll('#playbackKeyboardDisplay .playback-key.key-current');
            currentHighlightedKeys.forEach(key => {
                key.classList.remove('key-current');
                // Re-evaluate state after removing 'current'
                updatePlaybackKeyboardKey(parseInt(key.dataset.note));
            });
            const currentExtendedKeys = document.querySelectorAll('#playbackKeyboardDisplay .playback-key.key-gate-extended');
            currentExtendedKeys.forEach(key => {
                key.classList.remove('key-gate-extended');
                // Re-evaluate state after removing 'extended'
                updatePlaybackKeyboardKey(parseInt(key.dataset.note));
            });
        }

        /**
         * Clears all highlights from the playback piano keyboard (held and current notes) (OBSOLETE).
         */
        function unhighlightPlaybackPianoKeysAll() {
            // Just call updatePlaybackKeyboardUI to refresh all keys based on current state
            updatePlaybackKeyboardUI();
        }

        // --- WALK MODE FUNCTIONS ---

        /**
         * Advances the arpeggio note index for 'walk' mode based on probabilities.
         * Also advances the rhythm index.
         */
        function advanceWalkIndex() {
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const probabilities = calculateWalkProbabilities(walkSkew);
                const rand = Math.random();
                if (rand < probabilities.prev) {
                    currentNoteIndex = (currentNoteIndex - 1 + currentModeNoteList.length) % currentModeNoteList.length;
                } else if (rand < probabilities.prev + probabilities.current) {
                    // Stay at current index - Note index doesn't change
                } else { // Next
                    currentNoteIndex = (currentNoteIndex + 1) % currentModeNoteList.length;
                }
            }
            // advanceRhythmIndex(); // Rhythm index is advanced in main arpStep loop now
        }

        /**
         * Calculates probabilities for walk mode based on walkSkew parameter.
         * @param {number} skew - Walk skew value (-1 to 1).
         * @returns {{next: number, current: number, prev: number}} - Probabilities for next, current, and previous steps.
         */
        function calculateWalkProbabilities(skew) {
            // Ensure skew is within range
            skew = Math.max(-1, Math.min(1, skew));
            let prob_next, prob_current, prob_prev;
            // Simplified linear mapping for probabilities based on skew
            prob_prev = Math.max(0, (1 / 3) * (1 - skew)); // Higher prob when skew is negative
            prob_next = Math.max(0, (1 / 3) * (1 + skew)); // Higher prob when skew is positive
            prob_current = Math.max(0, 1 - prob_prev - prob_next); // Remaining probability

            // Normalize probabilities (due to Math.max(0, ...))
            const total = prob_prev + prob_current + prob_next;
            if (total > 0) {
                prob_prev /= total;
                prob_current /= total;
                prob_next /= total;
            } else { // Should not happen with valid skew, but fallback
                prob_prev = 1 / 3;
                prob_current = 1 / 3;
                prob_next = 1 / 3;
            }

            return {
                next: prob_next,
                current: prob_current,
                prev: prob_prev
            };
        }


        /**
         * Advances the arpeggio note index for 'normalWalk' mode using normal distribution.
         * Also advances the rhythm index.
         */
        function advanceNormalWalkIndex() {
            if (currentModeNoteList && currentModeNoteList.length > 0) {
                const sigma = 0.3 + walkDistance * 2; // Scale distance effect
                const mu = walkSkew * (currentModeNoteList.length / 4); // Skew influences mean step size relative to list length

                const stepChange = sampleNormalDistribution(mu, sigma);
                // Limit the jump size to prevent excessive leaps, e.g., +/- half the list length
                const maxStepChange = Math.ceil(currentModeNoteList.length / 2);
                const clampedStepChange = Math.max(-maxStepChange, Math.min(maxStepChange, Math.round(stepChange))); // Round to integer step

                currentNoteIndex = (currentNoteIndex + clampedStepChange + currentModeNoteList.length) % currentModeNoteList.length; // Ensure positive modulo result
            }
            // advanceRhythmIndex(); // Rhythm index is advanced in main arpStep loop now
        }

        /**
         * Samples from a normal distribution using Box-Muller transform.
         * @param {number} mu - Mean of the distribution.
         * @param {number} sigma - Standard deviation of the distribution.
         * @returns {number} - A sample from the normal distribution.
         */
        function sampleNormalDistribution(mu, sigma) {
            let u1 = 0,
                u2 = 0;
            // Prevent Math.log(0)
            while (u1 === 0) u1 = Math.random();
            while (u2 === 0) u2 = Math.random();

            // Box-Muller transform
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            // const z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.sin(2.0 * Math.PI * u2); // We only need one sample per call

            return z0 * sigma + mu;
        }

        // --- Initialization ---
        generatePianoKeyboardUI();
        generatePlaybackPianoKeyboardUI();
        updatePlaybackKeyboardUI();
        updateRhythmDisplays(); // Generate initial rhythms
        updateModeNoteList(); // Generate initial mode list
        document.getElementById('chordNValueDisplay').textContent = chordNValue;
        document.getElementById('maxChordExtensionValue').textContent = maxChordExtension;
        document.getElementById('maxTimeExtensionValue').textContent = maxTimeExtensionDivisions;
        document.getElementById('baseVelocityValue').textContent = baseVelocityValue;
        document.getElementById('maxVelocityValue').textContent = maxVelocityValue;
        document.getElementById('walkSkewValue').textContent = walkSkew.toFixed(2);
        document.getElementById('walkDistanceValue').textContent = walkDistance.toFixed(2);
        document.getElementById('gateLengthValue').textContent = gateLengthPercentage;
        document.getElementById('subArpScaleValue').textContent = subArpScalePercentage;
        updateTempoDisplay();
        updatePatternControlsState();
        updateRhythmControlsState();
    </script>
</body>
</html>
