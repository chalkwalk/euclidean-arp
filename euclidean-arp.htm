<html>
<head>
    <title>Euclidean MPE Arpeggiator Prototype</title>
    <style>
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step { width: 20px; height: 20px; border: 1px solid #ccc; text-align: center; line-height: 20px; font-size: 12px; }
        .beat { background-color: lightgreen; }
        .rest { background-color: lightcoral; }
        .skip { background-color: lightblue; }
        .note { background-color: yellow; }
        .held-notes-display { margin-bottom: 10px; }
        .parameter-group { margin-bottom: 10px; }
        .note-selector { margin-bottom: 10px; } /* Removed display: flex; */
        .piano-keyboard { display: flex; }
        .key {
            height: 80px;
            border-left: 1px solid black;
            border-bottom: 1px solid black;
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            user-select: none; /* Prevent text selection on click */
        }
        .white-key {
            width: 30px;
            background-color: white;
            color: black;
        }
        .black-key {
            width: 20px;
            background-color: black;
            color: white;
            height: 55px;
            margin-left: -10px;
            margin-right: -10px;
            z-index: 1; /* Ensure black keys are on top */
        }
        .key.key-held-ui {
            background-color: lightblue;
            color: black; /* Ensure text is readable on highlight */
        }
        .key.key-held-midi {
            background-color: lightgreen;
            color: black; /* Ensure text is readable on highlight */
        }
        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; }
        .playback-step { width: 20px; height: 20px; border: 1px solid black; margin-right: 2px; text-align: center; line-height: 20px; font-size: 10px; }
        .playback-step.note { background-color: lightyellow; }
        .playback-step.rest { background-color: lightcoral; }
        .playback-step.skip { background-color: lightblue; }
        .device-selector { margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Euclidean MPE Arpeggiator Prototype</h1>

    <div id="midiStatus">MIDI Status: Not connected</div>

    <div class="device-selector">
        <label for="midiInputSelect">MIDI Input Device:</label>
        <select id="midiInputSelect">
            <option value="">No input device selected</option>
        </select>
    </div>

    <div class="device-selector">
        <label for="midiOutputSelect">MIDI Output Device:</label>
        <select id="midiOutputSelect">
            <option value="">No output device selected</option>
        </select>
    </div>


    <div class="held-notes-display">
        <strong>Held MIDI Notes:</strong> <span id="heldNotes"></span>
    </div>

    <div class="note-selector">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
            <!-- Piano keys will be generated here by JavaScript -->
        </div>
    </div>


    <div class="parameter-group">
        <h3>Pattern</h3>
        <label for="patternSteps">Steps:</label>
        <input type="number" id="patternSteps" value="5" min="1">
        <label for="patternBeats">Beats:</label>
        <input type="number" id="patternBeats" value="3" min="1">
        <label for="patternOffset">Offset:</label>
        <input type="number" id="patternOffset" value="4" min="0">
        <div id="patternDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arp Rhythm</h3>
        <label for="arpRhythmSteps">Steps:</label>
        <input type="number" id="arpRhythmSteps" value="7" min="1">
        <label for="arpRhythmBeats">Beats:</label>
        <input type="number" id="arpRhythmBeats" value="5" min="1">
        <label for="arpRhythmOffset">Offset:</label>
        <input type="number" id="arpRhythmOffset" value="2" min="0">
        <div id="arpRhythmDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arpeggiator & MPE Settings</h3>
        <label for="clockDivision">Clock Division (ms):</label>
        <input type="number" id="clockDivision" value="250" min="10">
        <label for="arpMode">Arp Mode:</label>
        <select id="arpMode">
            <option value="up">Up</option>
            <option value="down">Down</option>
            <option value="upDown">Up/Down</option>
            <option value="upDownInclusive">Up/Down (Incl.)</option>
            <option value="random">Random</option>
            <option value="converge">Converge</option>
            <option value="diverge">Diverge</option>
            <option value="played">Played</option>
            <option value="shuffled">Shuffled</option>
            <option value="stableShuffled">Stable Shuffled</option>
        </select><br>

        <label for="arpSyncMode">Arp Sync Mode:</label>
        <select id="arpSyncMode">
            <option value="free">Free Sync</option>
            <option value="key">Key Sync</option>
            <option value="transport">Transport Sync (Placeholder)</option>
        </select><br>

        <input type="checkbox" id="enableMPE">
        <label for="enableMPE">Enable MPE Input</label><br>

        <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
        <select id="mpeGlobalInputChannel">
            <option value="omni">Omni</option>
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select><br>

        <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
        <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15"><br>

        <label for="mpeOutputMode">MPE Output Mode:</label>
        <select id="mpeOutputMode">
            <option value="non-mpe">Non-MPE (Single Channel)</option>
            <option value="mpe">MPE</option>
        </select><br>

        <label for="mpeGlobalOutputChannel">MPE Global Output Channel / Base Channel:</label>
        <select id="mpeGlobalOutputChannel">
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select>
    </div>

    <div class="playback-display" id="playbackDisplay"></div>

    <button id="startButton">Start Arpeggiator</button>
    <button id="stopButton" disabled>Stop Arpeggiator</button>

    <script>
        let midiAccess;
        let midiOutput;
        let midiInput; // Variable to store selected MIDI input
        let heldNotes = []; // Notes from MIDI input and UI buttons
        let heldNotesUI = new Set(); // Track notes held by UI interaction
        let heldNotesMIDI = new Set(); // Track notes held by MIDI input
        let patternRhythm = [];
        let arpRhythm = [];
        let arpRunning = false;
        let arpInterval;
        let currentArpNoteIndex = 0;
        let currentArpRhythmIndex = 0;
        let currentPatternIndex = 0;
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 30; // Display steps, not notes now
        let arpMode = 'up'; // Default arp mode
        let isMPEEnabled = false; // MPE Enable Flag
        let mpeGlobalInputChannel = 'omni'; // MPE Global Input Channel Selection
        let mpeInputVoiceChannels = 8; // Number of MPE Input Voice Channels
        let mpeOutputMode = 'non-mpe'; // MPE Output Mode
        let mpeGlobalOutputChannel = '1'; // MPE Global Output Channel / Base Channel
        let arpSyncMode = 'free'; // Default sync mode is Free Sync

        // State variables for different arp modes
        let upDownDirection = 1; // 1 for up, -1 for down, for upDown modes
        let convergeDivergeDirection = 1 // 1 for converge, -1 for diverge
        let shuffledNotesOrder = [];
        let stableShuffledOrder = [];
        let stableShuffleIndex = 0;
        let lastNotesToArp = []; // To detect if notes have changed for stable shuffle
        let convergeDivergeStep = 0; // Track step in converge/diverge cycles

        document.getElementById('startButton').addEventListener('click', startArpeggiator);
        document.getElementById('stopButton').addEventListener('click', stopArpeggiator);
        document.getElementById('arpMode').addEventListener('change', function() {
            arpMode = this.value;
        });
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });
        document.getElementById('enableMPE').addEventListener('change', function() {
            isMPEEnabled = this.checked;
        });
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            mpeGlobalInputChannel = this.value;
        });
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            mpeInputVoiceChannels = parseInt(this.value);
        });
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            mpeOutputMode = this.value;
        });
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            mpeGlobalOutputChannel = this.value;
        });


        // MIDI Initialization (same as before)
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);

        function onMIDISuccess(midi) {
            midiAccess = midi;
            document.getElementById('midiStatus').innerText = "MIDI Status: Connected";

            const inputSelect = document.getElementById('midiInputSelect');
            const outputSelect = document.getElementById('midiOutputSelect');

            // Populate MIDI input select
            const inputs = midiAccess.inputs.values();
            for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                const option = document.createElement('option');
                option.value = input.value.id;
                option.text = input.value.name || 'MIDI Input ' + inputSelect.options.length;
                inputSelect.appendChild(option);
            }

            // Populate MIDI output select
            const outputs = midiAccess.outputs.values();
            for (let output = outputs.next(); output && !output.done; output = outputs.next()) {
                const option = document.createElement('option');
                option.value = output.value.id;
                option.text = output.value.name || 'MIDI Output ' + outputSelect.options.length;
                outputSelect.appendChild(option);
            }

            // Select first input and output if available
            if (inputSelect.options.length > 1) {
                inputSelect.selectedIndex = 1; // Select the first device, skipping "No input device selected"
                midiInput = midiAccess.inputs.get(inputSelect.options[1].value);
                midiInput.onmidimessage = onMIDIMessage;
            }

            if (outputSelect.options.length > 1) {
                outputSelect.selectedIndex = 1; // Select the first device, skipping "No output device selected"
                midiOutput = midiAccess.outputs.get(outputSelect.options[1].value);
            } else {
                document.getElementById('midiStatus').innerText += " No MIDI output device found.";
            }

            // Input device change listener
            inputSelect.addEventListener('change', function() {
                const selectedInputId = this.value;
                if (midiInput) {
                    midiInput.onmidimessage = null; // Remove listener from previous input
                }
                if (selectedInputId) {
                    midiInput = midiAccess.inputs.get(selectedInputId);
                    midiInput.onmidimessage = onMIDIMessage; // Add listener to new input
                } else {
                    midiInput = null; // No input device selected
                }
            });

            // Output device change listener
            outputSelect.addEventListener('change', function() {
                const selectedOutputId = this.value;
                if (selectedOutputId) {
                    midiOutput = midiAccess.outputs.get(selectedOutputId);
                } else {
                    midiOutput = null; // No output device selected
                }
            });
        }

        function onMIDIFailure() {
            document.getElementById('midiStatus').innerText = "MIDI Status: MIDI access failed.";
        }

        function onMIDIMessage(message) {
            const command = message.data[0];
            const channel = command & 0x0F; // Extract MIDI channel (lower 4 bits)
            const note = message.data[1];
            const velocity = (message.data.length > 2) ? message.data[2] : 0;

            let processMessage = false;

            if (isMPEEnabled) {
                if (mpeGlobalInputChannel === 'omni') {
                    processMessage = true; // Process all channels in Omni mode (for now, refine MPE channel range later if needed)
                } else {
                    const globalChannel = parseInt(mpeGlobalInputChannel);
                    const voiceChannelCount = mpeInputVoiceChannels;
                    if (channel + 1 >= globalChannel + 1 && channel + 1 <= globalChannel + voiceChannelCount) { // Check if channel is within MPE voice channel range
                        processMessage = true;
                    } else if (channel + 1 === globalChannel) { // Optionally process global channel messages too, if needed, for now ignoring.
                        // processMessage = true;
                    }
                }
            } else {
                processMessage = true; // Process all messages if MPE is disabled (or refine to channel 1 later if needed)
            }


            if (processMessage) {
                if (command >= 144 && command < 160) { // Note On
                    if (velocity > 0) {
                        noteOn(note, 'midi'); // Indicate MIDI source
                    } else {
                        noteOff(note, 'midi'); // Indicate MIDI source
                    }
                } else if (command >= 128 && command < 144 || (command >= 144 && command < 160 && velocity === 0)) { // Note Off
                    noteOff(note, 'midi'); // Indicate MIDI source
                }
                // In future, handle MPE specific messages (pitch bend, CC74, pressure) here if needed based on isMPEEnabled and selected channel
            }
        }

        function noteOn(note, source = 'ui') {
            if (source === 'ui') {
                if (!heldNotesUI.has(note)) {
                    heldNotesUI.add(note);
                } else {
                    heldNotesUI.delete(note); // Toggle off if already on
                }
                // Update heldNotes from both sources
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, heldNotesUI.has(note) ? 'ui' : null); // Update UI key style
            } else if (source === 'midi') {
                if (!heldNotesMIDI.has(note)) {
                    heldNotesMIDI.add(note);
                }
                // heldNotesUI takes precedence if both UI and MIDI hold the same note, in terms of visual representation.
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, 'midi'); // Update UI key style for MIDI
            }


            updateHeldNotesDisplay();
             // For stable shuffle, re-shuffle on note change
            if (arpMode === 'stableShuffled' && arpRunning) {
                let notesToArp = heldNotes.length > 0 ? heldNotes : []; // Use empty array if no held notes
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                stableShuffleIndex = 0; // Reset index as notes changed
                lastNotesToArp = [...notesToArp]; // Update last notes
            }
            // Key Sync: Start arp if it's in key sync mode and not already running
            if (arpSyncMode === 'key' && !arpRunning) {
                startArpeggiator(); // Start the arpeggiator when the first note is pressed in Key Sync mode
            }

        }

        function noteOff(note, source = 'ui') {
            if (source === 'ui') {
                // UI note-off is handled in noteOn toggle logic
            } else if (source === 'midi') {
                heldNotesMIDI.delete(note);
                // Update heldNotes from both sources
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, heldNotesUI.has(note) ? 'ui' : null); // Update UI key style, check if UI still holds it
            }

            updateHeldNotesDisplay();
             // For stable shuffle, re-shuffle on note change
            if (arpMode === 'stableShuffled' && arpRunning) {
                let notesToArp = heldNotes.length > 0 ? heldNotes : []; // Use empty array if no held notes
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                stableShuffleIndex = 0; // Reset index as notes changed
                lastNotesToArp = [...notesToArp]; // Update last notes
            }
            // Key Sync: Stop arp if it's in key sync mode and no notes are held
            if (arpSyncMode === 'key' && heldNotes.length === 0 && arpRunning) {
                stopArpeggiator(); // Stop the arpeggiator when the last note is released in Key Sync mode
            }
        }


        function updateHeldNotesDisplay() {
            const noteNames = heldNotes.map(midiNoteToName);
            document.getElementById('heldNotes').innerText = noteNames.join(", ");
        }

        function midiNoteToName(note) {
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const octave = Math.floor(note / 12) - 1;
            const noteName = notes[note % 12];
            return noteName + octave;
        }

        function generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent) {
            const rhythm = new Array(steps).fill(restEvent);
            let count = 0;
            for (let i = 0; i < steps; i++) {
                if ((count * steps) < (beats * (i + 1))) {
                    rhythm[i] = beatEvent;
                    count++;
                }
            }
            for (let i = 0; i < offset; i++) {
                rhythm.unshift(rhythm.pop());
            }
            return rhythm;
        }

        function updateRhythmDisplays() {
            const patternSteps = parseInt(document.getElementById('patternSteps').value);
            const patternBeats = parseInt(document.getElementById('patternBeats').value);
            const patternOffset = parseInt(document.getElementById('patternOffset').value);
            patternRhythm = generateEuclideanRhythm(patternSteps, patternBeats, patternOffset, 'N', 'S');
            displayRhythm(patternRhythm, 'patternDisplay');

            const arpRhythmSteps = parseInt(document.getElementById('arpRhythmSteps').value);
            const arpRhythmBeats = parseInt(document.getElementById('arpRhythmBeats').value);
            const arpRhythmOffset = parseInt(document.getElementById('arpRhythmOffset').value);
            arpRhythm = generateEuclideanRhythm(arpRhythmSteps, arpRhythmBeats, arpRhythmOffset, 'B', 'R');
            displayRhythm(arpRhythm, 'arpRhythmDisplay');
        }

        function displayRhythm(rhythmArray, displayElementId) {
            const displayElement = document.getElementById(displayElementId);
            displayElement.innerHTML = '';
            rhythmArray.forEach(event => {
                const stepElement = document.createElement('div');
                stepElement.classList.add('rhythm-step');
                stepElement.innerText = event;
                if (event === 'B') stepElement.classList.add('beat');
                else if (event === 'R') stepElement.classList.add('rest');
                else if (event === 'S') stepElement.classList.add('skip');
                else if (event === 'N') stepElement.classList.add('note');
                displayElement.appendChild(stepElement);
            });
        }

        function getArpNote(notesToArp) {
            if (notesToArp.length === 0) return null; // Handle empty notes array

            switch (arpMode) {
                case 'up':
                    return notesToArp[currentArpNoteIndex % notesToArp.length];
                case 'down':
                    return notesToArp[notesToArp.length - 1 - (currentArpNoteIndex % notesToArp.length)];
                case 'upDown':
                    const upDownLength = 2 * notesToArp.length - 2;
                    const upDownIndex = currentArpNoteIndex % upDownLength;
                    if (upDownIndex < notesToArp.length) {
                        return notesToArp[upDownIndex];
                    } else {
                        return notesToArp[notesToArp.length - 2 - (upDownIndex - notesToArp.length)];
                    }
                case 'upDownInclusive': // Corrected upDownInclusive mode
                    const noteCount = notesToArp.length;
                    if (noteCount === 0) return null;
                    const cycleLength = 2 * noteCount - 2; // Length excluding repeats, for indexing
                    const fullCycleLength = 2 * noteCount; // Length including repeats, for modulo
                    let index;

                    const currentCycleIndex = currentArpNoteIndex % fullCycleLength;

                    if (currentCycleIndex < noteCount) {
                        index = currentCycleIndex; // Upward motion
                    } else {
                        index = noteCount - 1 - (currentCycleIndex - noteCount); // Downward motion, reversed index
                    }
                    return notesToArp[index];
                case 'converge':
                    let convergeStep = currentArpNoteIndex % notesToArp.length;
                    let conNote;
                    let conAbsoluteIndex = Math.floor(convergeStep / 2);
                    if (convergeStep % 2 === 0) {
                    	conNote = notesToArp[conAbsoluteIndex];
                    } else {
                        conNote = notesToArp.at(-1-conAbsoluteIndex);
                    }
                    return conNote;
                case 'diverge':
                    let divergeStep = currentArpNoteIndex % notesToArp.length;
                    let divNote;
                    let divAbsoluteIndex = Math.floor((notesToArp.length - 1 - divergeStep) / 2);
                    if (divergeStep % 2 === 0) {
                    	divNote = notesToArp[divAbsoluteIndex];
                    } else {
                        divNote = notesToArp.at(-1-divAbsoluteIndex);
                    }
                    return divNote;
                case 'played':
                    return notesToArp[currentArpNoteIndex % notesToArp.length]; // Same as 'up' for now, can be modified to remember played order if needed.
                case 'random':
                    return notesToArp[Math.floor(Math.random() * notesToArp.length)];
                case 'shuffled':
                    // Reshuffle every time we loop around notesToArp
                    console.log("currentArpNoteIndex:", currentArpNoteIndex)
                    if (currentArpNoteIndex % notesToArp.length === 0) {
                        shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                    }
                    return shuffledNotesOrder[currentArpNoteIndex % shuffledNotesOrder.length];
                case 'stableShuffled':
                    return stableShuffledOrder[stableShuffleIndex % stableShuffledOrder.length];
                default: // 'up' is default
                    return notesToArp[currentArpNoteIndex % notesToArp.length];
            }
        }

        function advanceArpRhythmIndex(steps = 1) {
            currentArpRhythmIndex = (currentArpRhythmIndex + steps) % arpRhythm.length;
        }

        function resetArpRhythmIndex() {
            currentArpRhythmIndex = 0;
        }

        function advancePatternIndex(steps = 1) {
            currentPatternIndex = (currentPatternIndex + steps) % patternRhythm.length;
        }

        function resetPatternIndex() {
            currentPatternIndex = 0;
        }


        function startArpeggiator() {
            // if (!midiOutput && heldNotes.length === 0) {
            //    alert("No MIDI output device found and no notes selected. Please connect MIDI or select UI notes.");
            //    return;
            // }
            let notesToArp = heldNotes.length > 0 ? heldNotes : []; // Use heldNotes directly, which now includes UI notes

            // For Key Sync, arpeggiator might start in noteOn, so this check might be redundant in some cases, but keep it for 'Free Sync' and button start.
            // if (arpSyncMode !== 'key') {
            //    if (notesToArp.length === 0) {
            //        alert("Hold some notes or select UI notes to start the arpeggiator.");
            //        return;
            //    }
            //}
            if (arpRunning) return; // Prevent restart if already running

            // Sort notes for Up/Down, Converge/Diverge modes to work predictably
            notesToArp.sort((a, b) => a - b);

            // Check if notes have changed for stable shuffle reset
            if (!arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                lastNotesToArp = [...notesToArp]; // Update last notes
                stableShuffleIndex = 0; // Reset stable shuffle index when notes change on start too.
            }

            // Initialize mode specific variables on start
            upDownDirection = 1;
            convergeDivergeDirection = 1;

            // Shuffle notes for shuffled mode on start (and every restart)
            shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5);


            arpRunning = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            updateRhythmDisplays();
            resetArpRhythmIndex(); // Reset indices on start
            resetPatternIndex();

            currentArpNoteIndex = 0;
            playbackDisplayElem.innerHTML = ''; // Clear playback display here on start!

            const clockDivision = parseInt(document.getElementById('clockDivision').value);
            arpInterval = setInterval(arpStep, clockDivision);
        }

        function stopArpeggiator() {
            if (!arpRunning) return; // Prevent double stop
            arpRunning = false;
            clearInterval(arpInterval);
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            allNotesOff();
            // playbackDisplayElem.innerHTML = ''; // No need to clear here anymore
        }

        function arpStep() {
            if (!arpRunning) {
                stopArpeggiator();
                return;
            }

            let notesToArp = heldNotes.length > 0 ? heldNotes : []; // Use heldNotes directly
            if (arpSyncMode === 'free' && notesToArp.length === 0) {
                // In Free Sync mode, if no notes are held, advance rhythms silently
                advanceArpRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null); // Indicate silent step in Free Sync
                return; // Exit early, don't play notes
            }


            if (arpMode === 'stableShuffled' && !arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                stableShuffleIndex = 0;
                lastNotesToArp = [...notesToArp];
            }
            if (notesToArp.length === 0 && arpSyncMode !== 'free') { // For key sync or transport sync, stop if no notes
                stopArpeggiator();
                return;
            } else if (notesToArp.length === 0 && arpSyncMode === 'free') {
                // Free sync with no notes is handled above to advance silently
                return;
            }

            let noteForStep = '';
            let stepType = null; // Initialize stepType to null

            const currentArpRhythmEvent = arpRhythm[currentArpRhythmIndex];

            if (currentArpRhythmEvent === 'B') { // Beat in Arp Rhythm
                let patternEventProcessed = false;
                while (!patternEventProcessed) {
                    const currentPatternEvent = patternRhythm[currentPatternIndex];
                    if (currentPatternEvent === 'N') { // Note in Pattern
                        noteForStep = getArpNote(notesToArp);
                        if (noteForStep !== null) {
                            playNote(noteForStep);
                        }
                        currentArpNoteIndex++;
                        if (arpMode === 'stableShuffled') stableShuffleIndex++;
                        advancePatternIndex();
                        stepType = 'note'; // Set stepType to 'note' when a note is played
                        patternEventProcessed = true;
                    } else if (currentPatternEvent === 'S') { // Skip in Pattern
                        advancePatternIndex();
                        currentArpNoteIndex++;
                        if (arpMode === 'stableShuffled') stableShuffleIndex++;
                    } else { // Error case
                        stepType = 'error';
                        patternEventProcessed = true;
                        break;
                    }
                    if (patternEventProcessed) break;
                }
            } else if (currentArpRhythmEvent === 'R') { // Rest in Arp Rhythm
                stepType = 'rest'; // Set stepType to 'rest' for rests
            } else {
                stepType = 'error_arp_rhythm'; // For safety
            }

            if (stepType !== null) { // Only update display if stepType is set (i.e., for 'note', 'rest' or 'skip')
                updatePlaybackDisplay(stepType, (stepType === 'note') ? noteForStep : null);
            }
            advanceArpRhythmIndex();
        }

        function playNote(note) {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) -1; // Channel is 0 indexed for MIDI
                if (mpeOutputMode === 'mpe') {
                    midiOutput.send([0xE0 + outputChannel, 0, 0x40, 0x90 + outputChannel, note, 100]); // Pitch Bend to center, Note On, channel from mpeGlobalOutputChannel (for now just base channel)
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                } else {
                    midiOutput.send([0x90 + outputChannel, note, 100]); // Note On, channel from mpeGlobalOutputChannel (for non-MPE)
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                }
            }
        }

        function allNotesOff() {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) - 1;
                for (const note of heldNotes) {
                    midiOutput.send([0x80 + outputChannel, note, 0]); // Note Off for all held notes on selected output channel
                }
            }
        }

        function updatePlaybackDisplay(stepType, note) {
            if (stepType === null) return; // Do not update display for null stepType

            const stepElem = document.createElement('div');
            stepElem.classList.add('playback-step');
            stepElem.classList.add(stepType); // Add class for step type styling

            if (stepType === 'note' && note !== null) {
                stepElem.textContent = midiNoteToName(note).replace(/\d+/g, ''); // Display note name
            } else if (stepType === 'rest') {
                stepElem.textContent = 'R';
            } else if (stepType === 'skip') {
                stepElem.textContent = 'S';
            }
            else if (stepType === 'error') {
                stepElem.textContent = '!'; // Indicate error in playback
            }

            playbackDisplayElem.appendChild(stepElem);

            if (playbackDisplayElem.children.length > maxPlaybackSteps) {
                playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            }
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        // Helper function to compare arrays for stable shuffled reset
        function arraysAreEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        function generatePianoKeyboardUI() {
            const pianoKeyboard = document.getElementById('pianoKeyboard');
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const startNote = 48; // Middle C (C4)
            const numberOfKeys = 24; // One octave

            for (let i = 0; i < numberOfKeys; i++) {
                const noteValue = startNote + i;
                const noteName = notes[i % 12];
                const key = document.createElement('div');
                key.classList.add('key');
                key.dataset.note = noteValue;
                key.textContent = noteName;
                key.id = `pianoKey-${noteValue}`; // Add ID for easy access

                if (noteName.includes('#')) {
                    key.classList.add('black-key');
                } else {
                    key.classList.add('white-key');
                }

                key.addEventListener('click', function() {
                    noteOn(noteValue, 'ui'); // Identify UI source
                });

                pianoKeyboard.appendChild(key);
            }
        }

        function updatePianoKeyboardUI(note, source) {
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (!keyElement) return; // Key element might not be created if note is out of range.

            keyElement.classList.remove('key-held-ui', 'key-held-midi'); // Remove any existing held styles

            if (heldNotesUI.has(note) && source === 'ui') {
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesUI.has(note) && source === null) { // If UI still holds after MIDI off
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesMIDI.has(note) && source === 'midi') {
                 keyElement.classList.add('key-held-midi');
            }
             // If neither UI nor MIDI holds it, it will revert to default style due to removal of classes above.
        }


        // Event listeners for parameter changes (same as before)
        document.getElementById('patternSteps').addEventListener('change', updateRhythmDisplays);
        document.getElementById('patternBeats').addEventListener('change', updateRhythmDisplays);
        document.getElementById('patternOffset').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmSteps').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmBeats').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmOffset').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpMode').addEventListener('change', function() {
             // Reset indices when changing arp mode for modes that use them
            if (['converge', 'diverge'].includes(this.value)) {
                let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                convergeStartIndex = 0;
                convergeEndIndex = notesToArp.length > 0 ? notesToArp.length - 1 : 0;
                divergeStartIndex = Math.floor(notesToArp.length / 2); // Reset diverge start to middle
                divergeEndIndex = Math.ceil(notesToArp.length / 2) - 1; // Reset diverge end to middle (or just below)
                convergeDivergeStep = 0; // Reset step counter for converge/diverge
            } else if (this.value === 'stableShuffled') {
                 let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                 stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                 stableShuffledIndex = 0;
            } else if (this.value === 'shuffled') {
                let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5);
            }
            arpMode = this.value;
        });

        generatePianoKeyboardUI();
        updateRhythmDisplays();
    </script>
</body>
</html>