<html>
<head>
    <title>Euclidean MPE Arpeggiator Prototype</title>
    <style>
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step { width: 20px; height: 20px; border: 2px solid #ccc; text-align: center; line-height: 20px; font-size: 12px; }
        .beat { background-color: lightgreen; }
        .rest { background-color: lightcoral; }
        .skip { background-color: lightblue; }
        .note { background-color: yellow; }
        .held-notes-display { margin-bottom: 10px; }
        .parameter-group { margin-bottom: 10px; }
        .note-selector { margin-bottom: 10px; }
        .piano-keyboard { display: flex; }
        .key {
            height: 80px;
            border-left: 1px solid black;
            border-bottom: 1px solid black;
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            user-select: none; /* Prevent text selection on click */
        }
        .white-key {
            width: 30px;
            background-color: white;
            color: black;
        }
        .black-key {
            width: 20px;
            background-color: black;
            color: white;
            height: 55px;
            margin-left: -10px;
            margin-right: -10px;
            z-index: 1; /* Ensure black keys are on top */
        }
        .key.key-held-ui {
            background-color: lightblue;
            color: black; /* Ensure text is readable on highlight */
        }
        .key.key-held-midi {
            background-color: lightgreen;
            color: black; /* Ensure text is readable on highlight */
        }
        .key.key-current { /* New class for current key highlight */
            border: 2px solid blue; /* Example highlight style */
        }
        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; }
        .playback-step { width: 20px; height: 20px; border: 1px solid black; margin-right: 2px; text-align: center; line-height: 20px; font-size: 10px; }
        .playback-step.note { background-color: lightyellow; }
        .playback-step.rest { background-color: lightcoral; }
        .playback-step.skip { background-color: lightblue; }
        .device-selector { margin-bottom: 10px; }
        .slider-container {
            display: flex;
            align-items: center; /* Vertically align label and slider */
        }
        .slider-container label {
            margin-right: 10px; /* Space between label and slider */
            width: 60px; /* Fixed width for labels to align them */
            text-align: right; /* Right-align label text */
        }
        .slider-container input[type="range"] {
            width: 150px; /* Adjust slider width as needed */
        }
        .number-display {
            width: 30px; /* Fixed width for number display */
            text-align: center;
            margin-left: 5px;
        }
        .rhythm-step.current-step { /* New class for current rhythm step highlight */
            border: 2px solid blue; /* Example highlight style */
        }
        #chordNControls {
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <h1>Euclidean MPE Arpeggiator Prototype</h1>

    <div id="midiStatus">MIDI Status: Not connected</div>

    <div class="device-selector">
        <label for="midiInputSelect">MIDI Input Device:</label>
        <select id="midiInputSelect">
            <option value="">No input device selected</option>
        </select>
    </div>

    <div class="device-selector">
        <label for="midiOutputSelect">MIDI Output Device:</label>
        <select id="midiOutputSelect">
            <option value="">No output device selected</option>
        </select>
    </div>


    <div class="held-notes-display">
        <strong>Held MIDI Notes:</strong> <span id="heldNotes"></span>
    </div>

    <div class="note-selector">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
            <!-- Piano keys will be generated here by JavaScript -->
        </div>
    </div>


    <div class="parameter-group">
        <h3>Pattern</h3>
        <div class="slider-container">
            <label for="patternSteps">Steps:</label>
            <input type="range" id="patternSteps" value="5" min="1" max="32" step="1">
            <span id="patternStepsValue" class="number-display">5</span>
        </div>
        <div class="slider-container">
            <label for="patternBeats">Beats:</label>
            <input type="range" id="patternBeats" value="3" min="1" max="5" step="1">
            <span id="patternBeatsValue" class="number-display">3</span>
        </div>
        <div class="slider-container">
            <label for="patternOffset">Offset:</label>
            <input type="range" id="patternOffset" value="0" min="-2" max="2" step="1">
            <span id="patternOffsetValue" class="number-display">0</span>
        </div>
        <div id="patternDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arp Rhythm</h3>
        <div class="slider-container">
            <label for="arpRhythmSteps">Steps:</label>
            <input type="range" id="arpRhythmSteps" value="7" min="1" max="32" step="1">
            <span id="arpRhythmStepsValue" class="number-display">7</span>
        </div>
        <div class="slider-container">
            <label for="arpRhythmBeats">Beats:</label>
            <input type="range" id="arpRhythmBeats" value="5" min="1" max="7" step="1">
            <span id="arpRhythmBeatsValue" class="number-display">5</span>
        </div>
        <div class="slider-container">
            <label for="arpRhythmOffset">Offset:</label>
            <input type="range" id="arpRhythmOffset" value="0" min="-4" max="4" step="1">
            <span id="arpRhythmOffsetValue" class="number-display">0</span>
        </div>
        <div id="arpRhythmDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arpeggiator & MPE Settings</h3>

        <label for="tempoSource">Tempo Source:</label>
        <select id="tempoSource">
            <option value="internal">Internal</option>
            <option value="external">External MIDI Clock</option>
        </select><br>

        <label for="tempoBPM">Tempo (BPM):</label>
        <input type="number" id="tempoBPM" value="120" min="10" max="300"><br>

        <label for="clockDivision">Clock Division:</label>
        <select id="clockDivision">
            <option value="1/1">1/1</option>
            <option value="1/2">1/2</option>
            <option value="1/4" selected="selected">1/4</option>
            <option value="1/8">1/8</option>
            <option value="1/16">1/16</option>
            <option value="1/32">1/32</option>
            <option value="1/2T">1/2T</option>
            <option value="1/4T">1/4T</option>
            <option value="1/8T">1/8T</option>
            <option value="1/16T">1/16T</option>
            <option value="1/32T">1/32T</option>
        </select><br>

        <label for="arpMode">Arp Mode:</label>
        <select id="arpMode">
            <option value="up">Up</option>
            <option value="down">Down</option>
            <option value="upDown">Up/Down</option>
            <option value="upDownInclusive">Up/Down (Incl.)</option>
            <option value="random">Random</option>
            <option value="converge">Converge</option>
            <option value="diverge">Diverge</option>
            <option value="played">Played</option>
            <option value="shuffled">Shuffled</option>
            <option value="stableShuffled">Stable Shuffled</option>
            <option value="chord">Chord</option>
            <option value="chordN">ChordN</option>
        </select><br>

        <div id="chordNControls">
            <div class="slider-container">
                <label for="chordNValue">N:</label>
                <input type="range" id="chordNValue" value="2" min="1" max="16" step="1">
                <span id="chordNValueDisplay" class="number-display">2</span>
            </div>
        </div><br>

        <label for="arpSyncMode">Arp Sync Mode:</label>
        <select id="arpSyncMode">
            <option value="free">Free Sync</option>
            <option value="key">Key Sync</option>
            <option value="transport">Transport Sync (Placeholder)</option>
        </select><br>

        <input type="checkbox" id="enableMPE">
        <label for="enableMPE">Enable MPE Input</label><br>

        <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
        <select id="mpeGlobalInputChannel">
            <option value="omni">Omni</option>
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select><br>

        <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
        <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15"><br>

        <label for="mpeOutputMode">MPE Output Mode:</label>
        <select id="mpeOutputMode">
            <option value="non-mpe">Non-MPE (Single Channel)</option>
            <option value="mpe">MPE</option>
        </select><br>

        <label for="mpeGlobalOutputChannel">MPE Global Output Channel / Base Channel:</label>
        <select id="mpeGlobalOutputChannel">
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select>

        <div class="slider-container">
            <label for="octaves">Octaves:</label>
            <input type="range" id="octaves" value="1" min="1" max="4" step="1">
            <span id="octavesValue" class="number-display">1</span>
        </div>
    </div>

    <div class="playback-display" id="playbackDisplay"></div>

    <button id="startButton">Start Arpeggiator</button>
    <button id="stopButton" disabled>Stop Arpeggiator</button>

    <script>
        /**
         * @fileoverview Euclidean MPE Arpeggiator Prototype
         * Implements a dual-layer Euclidean rhythm arpeggiator with MPE and MIDI support.
         * Features include customizable patterns and arp rhythms, various arpeggio modes,
         * tempo sync options, and octave expansion.
         */

        // --- MIDI Variables ---
        let midiAccess = null;
        let midiOutput = null;
        let midiInput = null;

        // --- Note Arrays and Sets ---
        let rawHeldNotes = []; // Stores original held notes, before octave expansion
        let heldNotes = []; // Stores MIDI notes currently held, expanded by octave if needed, and sorted
        let heldNotesUI = new Set(); // Stores notes held by UI interaction
        let heldNotesMIDI = new Set(); // Stores notes held by MIDI input

        // --- Rhythm Pattern Variables ---
        let patternRhythm = []; // Euclidean rhythm for note pattern (Note/Skip)
        let arpRhythm = [];     // Euclidean rhythm for arpeggio rhythm (Beat/Rest)

        // --- Arpeggiator State Variables ---
        let arpRunning = false;         // Arpeggiator play/stop state
        let arpInterval = null;         // Interval for internal clock
        let currentArpNoteIndex = 0;    // Index for current note in arpeggio
        let currentArpRhythmIndex = 0;  // Index for current step in arp rhythm
        let currentPatternIndex = 0;     // Index for current step in pattern
        let arpMode = 'up';             // Arpeggio mode (up, down, etc.)
        let arpSyncMode = 'free';        // Arpeggio sync mode (free, key, transport)
        let currentModeNoteList = [];    // Array holding notes for the current arp mode
        let chordNValue = 2;             // Default N value for ChordN mode

        // --- MPE and MIDI Channel Settings ---
        let isMPEEnabled = false;
        let mpeGlobalInputChannel = 'omni';
        let mpeInputVoiceChannels = 8;
        let mpeOutputMode = 'non-mpe';
        let mpeGlobalOutputChannel = '1';

        // --- Tempo and Clock Variables ---
        let tempoSource = 'internal';
        let bpm = 120;
        let clockDivision = '1/4';
        let tickCounter = 0;
        let clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision); // Ticks per step based on clock division
        let internalClockInterval = null;

        // --- Arpeggio Mode Specific State ---
        let upDownDirection = 1;           // Direction for Up/Down modes (1 for up, -1 for down)
        let convergeDivergeDirection = 1;  // Direction for Converge/Diverge modes (1 for converge, -1 for diverge)
        let shuffledNotesOrder = [];        // Stores shuffled order of notes for 'shuffled' mode
        let stableShuffledOrder = [];       // Stores stable shuffled order for 'stableShuffled' mode (persists across restarts)
        let stableShuffleIndex = 0;         // Index for stable shuffled mode
        let lastNotesToArp = [];            // Last set of notes used for stable shuffle comparison

        // --- UI Elements and Display ---
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 30;
        let highlightedPianoKey = null;

        // --- Octave Expansion ---
        let octaveCount = 1;


        /**
         * Event listener for the Start Arpeggiator button.
         */
        document.getElementById('startButton').addEventListener('click', startArpeggiator);

        /**
         * Event listener for the Stop Arpeggiator button.
         */
        document.getElementById('stopButton').addEventListener('click', stopArpeggiator);

        /**
         * Event listener for changes to the Arp Mode dropdown.
         * Updates the arpeggio mode and resets related state.
         */
        document.getElementById('arpMode').addEventListener('change', function() {
            const previousArpMode = arpMode;
            arpMode = this.value;
            const previousModeNoteList = [...currentModeNoteList]; // Copy for comparison
            const newModeNoteList = updateModeNoteList();

            if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge'].includes(arpMode) && previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                currentArpNoteIndex = findClosestNoteIndex(previousModeNoteList[currentArpNoteIndex % previousModeNoteList.length], previousModeNoteList, newModeNoteList, currentArpNoteIndex);
            } else {
                currentArpNoteIndex = 0; // Reset index for other modes or empty lists
            }

            const chordNControls = document.getElementById('chordNControls');
            if (arpMode === 'chordN') {
                chordNControls.style.display = 'block';
            } else {
                chordNControls.style.display = 'none';
            }
        });

        /**
         * Event listener for changes to the Arp Sync Mode dropdown.
         * Updates the arpeggio sync mode.
         */
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });

        /**
         * Event listener for changes to the Enable MPE checkbox.
         * Toggles MPE input processing.
         */
        document.getElementById('enableMPE').addEventListener('change', function() {
            isMPEEnabled = this.checked;
        });

        /**
         * Event listener for changes to the MPE Global Input Channel dropdown.
         * Sets the MPE global input channel.
         */
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            mpeGlobalInputChannel = this.value;
        });

        /**
         * Event listener for changes to the MPE Input Voice Channels input.
         * Sets the number of MPE input voice channels.
         */
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            mpeInputVoiceChannels = parseInt(this.value);
        });

        /**
         * Event listener for changes to the MPE Output Mode dropdown.
         * Sets the MPE output mode.
         */
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            mpeOutputMode = this.value;
        });

        /**
         * Event listener for changes to the MPE Global Output Channel dropdown.
         * Sets the MPE global output channel.
         */
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            mpeGlobalOutputChannel = this.value;
        });

        /**
         * Event listener for changes to the Octaves slider.
         * Updates the octave count and regenerates held notes.
         */
        document.getElementById('octaves').addEventListener('input', function() {
            octaveCount = parseInt(this.value);
            document.getElementById('octavesValue').textContent = octaveCount;
            heldNotes = generateOctaveExpandedNotes(rawHeldNotes, octaveCount);
            updateHeldNotesDisplay();
            updateModeNoteList();
        });

        /**
         * Event listener for changes to the Tempo Source dropdown.
         * Switches between internal and external tempo sources.
         */
        document.getElementById('tempoSource').addEventListener('change', function() {
            tempoSource = this.value;
            if (tempoSource === 'internal') {
                setupInternalClock();
            } else {
                clearInterval(internalClockInterval);
            }
        });

        /**
         * Event listener for changes to the Tempo BPM input.
         * Updates the tempo in BPM and resets internal clock if active.
         */
        document.getElementById('tempoBPM').addEventListener('change', function() {
            bpm = parseInt(this.value);
            if (tempoSource === 'internal') {
                setupInternalClock();
            }
        });

        /**
         * Event listener for changes to the Clock Division dropdown.
         * Updates the clock division and resets internal clock if active.
         */
        document.getElementById('clockDivision').addEventListener('change', function() {
            clockDivision = this.value;
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            if (tempoSource === 'internal') {
                setupInternalClock();
            }
        });

        /**
         * Event listener for changes to the ChordN Value slider.
         * Updates the N value for ChordN mode.
         */
        document.getElementById('chordNValue').addEventListener('input', function() {
            chordNValue = parseInt(this.value);
            document.getElementById('chordNValueDisplay').textContent = chordNValue;
            updateModeNoteList(); // Re-generate note list when N changes
        });


        /**
         * Initializes WebMIDI and sets up MIDI input and output device selectors.
         */
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);

        /**
         * Handles successful MIDI access.
         * Populates MIDI input and output selectors and sets up default devices.
         * @param {MIDIAccess} midi - MIDI access object.
         */
        function onMIDISuccess(midi) {
            midiAccess = midi;
            document.getElementById('midiStatus').innerText = "MIDI Status: Connected";

            const inputSelect = document.getElementById('midiInputSelect');
            const outputSelect = document.getElementById('midiOutputSelect');

            // Populate MIDI input select
            midiAccess.inputs.forEach(input => {
                const option = document.createElement('option');
                option.value = input.id;
                option.text = input.name || 'MIDI Input ' + (inputSelect.options.length);
                inputSelect.appendChild(option);
            });

            // Populate MIDI output select
            midiAccess.outputs.forEach(output => {
                const option = document.createElement('option');
                option.value = output.id;
                option.text = output.name || 'MIDI Output ' + (outputSelect.options.length);
                outputSelect.appendChild(option);
            });

            // Select first input and output if available (skip "No input device selected" option)
            if (inputSelect.options.length > 1) {
                inputSelect.selectedIndex = 1;
                selectMidiInput(inputSelect.options[1].value);
            }

            if (outputSelect.options.length > 1) {
                outputSelect.selectedIndex = 1;
                selectMidiOutput(outputSelect.options[1].value);
            } else {
                document.getElementById('midiStatus').innerText += " No MIDI output device found.";
            }

            // Input device change listener
            inputSelect.addEventListener('change', function() {
                selectMidiInput(this.value);
            });

            // Output device change listener
            outputSelect.addEventListener('change', function() {
                selectMidiOutput(this.value);
            });
        }

        /**
         * Handles MIDI access failure.
         */
        function onMIDIFailure() {
            document.getElementById('midiStatus').innerText = "MIDI Status: MIDI access failed.";
        }

        /**
         * Selects a MIDI input device and attaches the MIDI message handler.
         * @param {string} inputId - ID of the MIDI input device.
         */
        function selectMidiInput(inputId) {
            if (midiInput) {
                midiInput.onmidimessage = null; // Remove listener from previous input
            }
            if (inputId) {
                midiInput = midiAccess.inputs.get(inputId);
                midiInput.onmidimessage = onMIDIMessage; // Add listener to new input
            } else {
                midiInput = null; // No input device selected
            }
        }

        /**
         * Selects a MIDI output device.
         * @param {string} outputId - ID of the MIDI output device.
         */
        function selectMidiOutput(outputId) {
            if (outputId) {
                midiOutput = midiAccess.outputs.get(outputId);
            } else {
                midiOutput = null; // No output device selected
            }
        }


        /**
         * Expands a list of MIDI notes to include octaves above the original notes.
         * Removes duplicate notes and sorts the result.
         * @param {number[]} rawNotes - Array of MIDI note numbers to expand.
         * @param {number} octaves - Number of octaves to expand to (including the original octave).
         * @returns {number[]} - Array of octave-expanded, unique, and sorted MIDI note numbers.
         */
        function generateOctaveExpandedNotes(rawNotes, octaves) {
            if (octaves <= 1) {
                return [...new Set(rawNotes)].sort((a, b) => a - b);
            }
            let expandedNotes = [];
            for (const note of rawNotes) {
                for (let i = 0; i < octaves; i++) {
                    expandedNotes.push(note + (12 * i));
                }
            }
            return [...new Set(expandedNotes)].sort((a, b) => a - b);
        }


        /**
         * Handles note on and note off events from both UI and MIDI sources.
         * Updates held notes, UI, and starts/stops arpeggiator in Key Sync mode.
         * @param {number} note - MIDI note number.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         */
        function noteOn(note, source = 'ui') {
            const isUI = source === 'ui';
            const heldSet = isUI ? heldNotesUI : heldNotesMIDI;

            const previousModeNoteList = [...currentModeNoteList]; // Copy for comparison
            const previousArpNoteIndexVal = currentArpNoteIndex;

            if (isUI) {
                if (!heldSet.has(note)) {
                    heldSet.add(note);
                    rawHeldNotes.push(note);
                } else {
                    heldSet.delete(note);
                    const indexToRemove = rawHeldNotes.indexOf(note);
                    if (indexToRemove > -1) {
                        rawHeldNotes.splice(indexToRemove, 1);
                    }
                }
                heldNotes = generateOctaveExpandedNotes(rawHeldNotes, octaveCount);
                updatePianoKeyboardUI(note, heldSet.has(note) ? 'ui' : null);
            } else { // source === 'midi'
                if (!heldNotesMIDI.has(note)) {
                    heldNotesMIDI.add(note);
                    rawHeldNotes.push(note);
                }
                heldNotes = generateOctaveExpandedNotes(rawHeldNotes, octaveCount);
                updatePianoKeyboardUI(note, 'midi');
            }

            updateHeldNotesDisplay();

            if (arpSyncMode === 'key' && !arpRunning) {
                startArpeggiator();
            }
            const newModeNoteList = updateModeNoteList();


            if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge'].includes(arpMode) && previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                 currentArpNoteIndex = findClosestNoteIndex(previousModeNoteList[previousArpNoteIndexVal % previousModeNoteList.length], previousModeNoteList, newModeNoteList, previousArpNoteIndexVal);
            } else {
                currentArpNoteIndex = 0; // Reset index for other modes or empty lists
            }


            if (arpMode === 'shuffled' && arpRunning && shuffledNotesOrder.length > 0) {
                const insertionIndex = Math.floor(Math.random() * shuffledNotesOrder.length);
                shuffledNotesOrder.splice(insertionIndex, 0, note);
                if (insertionIndex <= currentArpNoteIndex) {
                    currentArpNoteIndex++;
                }
            } else if (arpMode === 'stableShuffled' && arpRunning && stableShuffledOrder.length > 0) {
                const insertionIndex = Math.floor(Math.random() * stableShuffledOrder.length);
                stableShuffledOrder.splice(insertionIndex, 0, note);
                 if (insertionIndex <= stableShuffleIndex) {
                    stableShuffleIndex++;
                }
            } else if (arpMode === 'shuffled' && arpRunning && shuffledNotesOrder.length === 0) {
                shuffledNotesOrder.push(note);
            } else if (arpMode === 'stableShuffled' && arpRunning && stableShuffledOrder.length === 0) {
                stableShuffledOrder.push(note);
            }
        }


        /**
         * Handles note off events from MIDI sources.
         * Updates held notes, UI, and stops arpeggiator in Key Sync mode if no notes are held.
         * @param {number} note - MIDI note number.
         * @param {string} source - Source of the note event ('ui' or 'midi').
         */
        function noteOff(note, source = 'midi') { // UI note-off is handled in noteOn toggle logic
            const previousModeNoteList = [...currentModeNoteList]; // Copy for comparison
            const previousArpNoteIndexVal = currentArpNoteIndex;


            if (source === 'midi') {
                heldNotesMIDI.delete(note);
                const indexToRemove = rawHeldNotes.indexOf(note);
                if (indexToRemove > -1) {
                    rawHeldNotes.splice(indexToRemove, 1);
                }
                heldNotes = generateOctaveExpandedNotes(rawHeldNotes, octaveCount);
                updatePianoKeyboardUI(note, heldNotesUI.has(note) ? 'ui' : null);
            }

            updateHeldNotesDisplay();

            if (arpSyncMode === 'key' && heldNotes.length === 0 && arpRunning) {
                stopArpeggiator();
            }
            const newModeNoteList = updateModeNoteList();

             if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge'].includes(arpMode) && previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                currentArpNoteIndex = findClosestNoteIndex(previousModeNoteList[previousArpNoteIndexVal % previousModeNoteList.length], previousModeNoteList, newModeNoteList, previousArpNoteIndexVal);
            } else {
                currentArpNoteIndex = 0; // Reset index for other modes or empty lists
            }


            if (arpMode === 'shuffled' && arpRunning) {
                const noteIndex = shuffledNotesOrder.indexOf(note);
                if (noteIndex !== -1) {
                    shuffledNotesOrder.splice(noteIndex, 1);
                    if (noteIndex < currentArpNoteIndex && currentArpNoteIndex > 0) {
                        currentArpNoteIndex--;
                    } else if (currentArpNoteIndex >= shuffledNotesOrder.length && shuffledNotesOrder.length > 0) {
                        currentArpNoteIndex = shuffledNotesOrder.length - 1;
                    } else if (shuffledNotesOrder.length === 0) {
                        currentArpNoteIndex = 0;
                    }
                }
            } else if (arpMode === 'stableShuffled' && arpRunning) {
                const noteIndex = stableShuffledOrder.indexOf(note);
                if (noteIndex !== -1) {
                    stableShuffledOrder.splice(noteIndex, 1);
                    if (noteIndex < stableShuffleIndex && stableShuffleIndex > 0) {
                        stableShuffleIndex--;
                    } else if (stableShuffleIndex >= stableShuffledOrder.length && stableShuffledOrder.length > 0) {
                        stableShuffleIndex = stableShuffledOrder.length - 1;
                    } else if (stableShuffledOrder.length === 0) {
                        stableShuffleIndex = 0;
                    }
                }
            }
        }


        /**
         * Updates the display of currently held notes.
         */
        function updateHeldNotesDisplay() {
            const noteNames = heldNotes.map(midiNoteToName);
            document.getElementById('heldNotes').innerText = noteNames.join(", ");
        }

        /**
         * Converts a MIDI note number to a note name (e.g., "C4").
         * @param {number} note - MIDI note number.
         * @returns {string} - Note name with octave.
         */
        function midiNoteToName(note) {
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const octave = Math.floor(note / 12) - 1;
            const noteName = notes[note % 12];
            return noteName + octave;
        }

        /**
         * Generates a Euclidean rhythm pattern.
         * @param {number} steps - Number of steps in the rhythm.
         * @param {number} beats - Number of beats in the rhythm.
         * @param {number} offset - Offset/rotation of the rhythm.
         * @param {string} beatEvent - Event character for beats.
         * @param {string} restEvent - Event character for rests.
         * @returns {string[]} - Array representing the Euclidean rhythm pattern.
         */
        function generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent) {
            const rhythm = new Array(steps).fill(restEvent);
            let count = 0;
            for (let i = 0; i < steps; i++) {
                if ((count * steps) < (beats * (i + 1))) {
                    rhythm[i] = beatEvent;
                    count++;
                }
            }
            const positiveOffset = offset >= 0 ? offset : steps + offset;
            for (let i = 0; i < positiveOffset; i++) {
                rhythm.unshift(rhythm.pop());
            }
            return rhythm;
        }

        /**
         * Updates both pattern and arpeggio rhythm displays based on slider values.
         */
        function updateRhythmDisplays() {
            const patternStepsSlider = document.getElementById('patternSteps');
            const patternBeatsSlider = document.getElementById('patternBeats');
            const patternOffsetSlider = document.getElementById('patternOffset');
            const arpRhythmStepsSlider = document.getElementById('arpRhythmSteps');
            const arpRhythmBeatsSlider = document.getElementById('arpRhythmBeats');
            const arpRhythmOffsetSlider = document.getElementById('arpRhythmOffset');

            const patternSteps = parseInt(patternStepsSlider.value);
            const patternBeats = parseInt(patternBeatsSlider.value);
            const patternOffset = parseInt(patternOffsetSlider.value);
            patternRhythm = generateEuclideanRhythm(patternSteps, patternBeats, patternOffset, 'N', 'S');
            displayRhythm(patternRhythm, 'patternDisplay');
            document.getElementById('patternStepsValue').textContent = patternSteps;
            document.getElementById('patternBeatsValue').textContent = patternBeats;
            document.getElementById('patternOffsetValue').textContent = patternOffset;


            const arpRhythmSteps = parseInt(arpRhythmStepsSlider.value);
            const arpRhythmBeats = parseInt(arpRhythmBeatsSlider.value);
            const arpRhythmOffset = parseInt(arpRhythmOffsetSlider.value);
            arpRhythm = generateEuclideanRhythm(arpRhythmSteps, arpRhythmBeats, arpRhythmOffset, 'B', 'R');
            displayRhythm(arpRhythm, 'arpRhythmDisplay');
            document.getElementById('arpRhythmStepsValue').textContent = arpRhythmSteps;
            document.getElementById('arpRhythmBeatsValue').textContent = arpRhythmBeats;
            document.getElementById('arpRhythmOffsetValue').textContent = arpRhythmOffset;

            patternBeatsSlider.max = patternSteps;
            arpRhythmBeatsSlider.max = arpRhythmSteps;

            const patternOffsetMax = Math.floor(patternSteps / 2);
            patternOffsetSlider.min = -patternOffsetMax;
            patternOffsetSlider.max = patternOffsetMax;

            const arpRhythmOffsetMax = Math.floor(arpRhythmSteps / 2);
            arpRhythmOffsetSlider.min = -arpRhythmOffsetMax;
            arpRhythmOffsetSlider.max = arpRhythmOffsetMax;

            resetArpRhythmIndex();
            resetPatternIndex();
        }

        /**
         * Displays a rhythm pattern in the UI.
         * @param {string[]} rhythmArray - Array of rhythm events.
         * @param {string} displayElementId - ID of the HTML element to display the rhythm in.
         */
        function displayRhythm(rhythmArray, displayElementId) {
            const displayElement = document.getElementById(displayElementId);
            displayElement.innerHTML = '';
            rhythmArray.forEach((event, index) => {
                const stepElement = document.createElement('div');
                stepElement.classList.add('rhythm-step');
                stepElement.innerText = event;
                stepElement.id = `${displayElementId}-step-${index}`;
                if (event === 'B') stepElement.classList.add('beat');
                else if (event === 'R') stepElement.classList.add('rest');
                else if (event === 'S') stepElement.classList.add('skip');
                else if (event === 'N') stepElement.classList.add('note');
                displayElement.appendChild(stepElement);
            });
        }

        /**
         * --- Arpeggio Mode Note List Generators ---
         * These functions generate the ordered list of notes based on the selected arpeggio mode.
         */

        /** @returns {number[]} - Notes in ascending order. */
        function generateUpNoteList(notes) { return [...notes]; }

        /** @returns {number[]} - Notes in descending order. */
        function generateDownNoteList(notes) { return [...notes].reverse(); }

        /** @returns {number[]} - Notes in up-down sequence, excluding крайние notes in descent. */
        function generateUpDownNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const upDownList = [...notes];
            for (let i = notes.length - 2; i >= 1; i--) {
                upDownList.push(notes[i]);
            }
            return upDownList;
        }

        /** @returns {number[]} - Notes in up-down sequence, including крайние notes in descent. */
        function generateUpDownInclusiveNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const upDownInclusiveList = [...notes];
            for (let i = notes.length - 1; i >= 0; i--) {
                upDownInclusiveList.push(notes[i]);
            }
            return upDownInclusiveList;
        }

        /** @returns {number[]} - Notes converging from outer to inner. */
        function generateConvergeNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const convergeList = [];
            let start = 0;
            let end = notes.length - 1;
            while (start <= end) {
                convergeList.push(notes[start]);
                if (start !== end) {
                    convergeList.push(notes[end]);
                }
                start++;
                end--;
            }
            return convergeList;
        }

        /** @returns {number[]} - Notes diverging from inner to outer. */
        function generateDivergeNoteList(notes) {
             if (notes.length <= 1) return [...notes];
            const divergeList = [];
            let start = Math.floor((notes.length - 1) / 2);
            let end = Math.ceil((notes.length - 1) / 2);
            while (start >= 0 && end < notes.length) {
                divergeList.push(notes[start]);
                if (start !== end) {
                    divergeList.push(notes[end]);
                }
                start--;
                end++;
            }
            return divergeList;
        }

        /** @returns {number[]} - Notes in the order they were played/held. */
        function generatePlayedNoteList(notes) { return [...notes]; }

        /** @returns {number[]} - Empty array, random note selection happens in arpStep. */
        function generateRandomNoteList(notes) { return []; }

        /** @returns {number[]} - Notes shuffled randomly each time the list is generated. */
        function generateShuffledNoteList(notes) { return [...notes].sort(() => Math.random() - 0.5); }

        /** @returns {number[]} - Returns the stable shuffled note order. */
        function generateStableShuffledNoteList(notes) { return stableShuffledOrder; }

        /** @returns {number[]} - Returns all held notes as a chord. */
        function generateChordNoteList(notes) { return [...notes]; }

        /**
         * Generates a list of chord combinations from held notes for ChordN mode.
         * @param {number[]} notes - Held MIDI notes.
         * @param {number} n - Number of notes per chord in ChordN.
         * @returns {number[][]} - List of chord combinations.
         */
        function generateChordNNoteList(notes, n) {
            if (notes.length === 0 || n <= 0) return [];
            n = Math.min(n, notes.length); // Limit n to the number of held notes

            const combinations = [];
            function combine(currentCombination, startIndex) {
                if (currentCombination.length === n) {
                    combinations.push([...currentCombination]); // Add a copy of the combination
                    return;
                }

                for (let i = startIndex; i < notes.length; i++) {
                    currentCombination.push(notes[i]);
                    combine(currentCombination, i + 1); // Ensure notes are added in ascending order
                    currentCombination.pop(); // Backtrack
                }
            }
            combine([], 0);
            return combinations;
        }


        /**
         * Updates the currentModeNoteList based on the selected arpeggio mode and held notes.
         * @returns {number[]} - The newly generated mode note list.
         */
        function updateModeNoteList() {
            let notesToArp = heldNotes.length > 0 ? heldNotes : [];
            switch (arpMode) {
                case 'up': currentModeNoteList = generateUpNoteList(notesToArp); break;
                case 'down': currentModeNoteList = generateDownNoteList(notesToArp); break;
                case 'upDown': currentModeNoteList = generateUpDownNoteList(notesToArp); break;
                case 'upDownInclusive': currentModeNoteList = generateUpDownInclusiveNoteList(notesToArp); break;
                case 'converge': currentModeNoteList = generateConvergeNoteList(notesToArp); break;
                case 'diverge': currentModeNoteList = generateDivergeNoteList(notesToArp); break;
                case 'played': currentModeNoteList = generatePlayedNoteList(notesToArp); break;
                case 'random': currentModeNoteList = generateRandomNoteList(notesToArp); break;
                case 'shuffled': currentModeNoteList = generateShuffledNoteList(notesToArp); break;
                case 'stableShuffled': currentModeNoteList = generateStableShuffledNoteList(notesToArp); break;
                case 'chord': currentModeNoteList = generateChordNoteList(notesToArp); break;
                case 'chordN': currentModeNoteList = generateChordNNoteList(notesToArp, chordNValue); break;
                default: currentModeNoteList = generateUpNoteList(notesToArp); break; // 'up' is default
            }
            return currentModeNoteList;
        }

        /**
         * Finds the closest note index in the new note list to the previous note, for continuity.
         * Implements fallback to the 'next' note if the 'current' note is not found.
         * @param {number} previousNote - The note that was playing at the current arp index in the old list.
         * @param {number[]} oldNoteList - The previous mode note list.
         * @param {number[]} newNoteList - The newly generated mode note list.
         * @param {number} previousIndex - The previous arpeggio note index.
         * @returns {number} - The adjusted arpeggio note index in the new note list.
         */
        function findClosestNoteIndex(previousNote, oldNoteList, newNoteList, previousIndex) {
            if (newNoteList.length === 0) return 0; // Reset if new list is empty

            let foundIndex = -1;
            let minDistance = Infinity;
            let currentNoteFound = false;

            // -- First, try to find the *current* note --
            for (let i = 0; i < newNoteList.length; i++) {
                if (newNoteList[i] === previousNote) {
                    currentNoteFound = true;
                    const distance = Math.min(Math.abs(i - previousIndex), newNoteList.length - Math.abs(i - previousIndex)); // Circular distance
                    if (distance < minDistance) {
                        minDistance = distance;
                        foundIndex = i;
                    }
                }
            }

            if (currentNoteFound) {
                return foundIndex; // Return index of current note if found
            }

            // -- Fallback: If current note not found, search for the *next* note --
            let nextNote = oldNoteList[(previousIndex + 1) % oldNoteList.length];
            if (oldNoteList.length === 0) nextNote = -1; // No next note if old list was empty.

            if (nextNote !== -1) {
                minDistance = Infinity; // Reset minDistance for next note search
                foundIndex = -1; // Reset foundIndex for next note search
                for (let i = 0; i < newNoteList.length; i++) {
                    if (newNoteList[i] === nextNote) {
                        const distance = Math.min(Math.abs(i - previousIndex), newNoteList.length - Math.abs(i - previousIndex)); // Circular distance
                        if (distance < minDistance) {
                            minDistance = distance;
                            foundIndex = i;
                        }
                    }
                }
                if (foundIndex !== -1) {
                    return foundIndex; // Return index of next note if found
                }
            }

            return 0; // Default to 0 if neither current nor next note is found
        }


        /** Advances the arpeggio rhythm index by a specified number of steps (default 1). */
        function advanceArpRhythmIndex(steps = 1) {
            currentArpRhythmIndex = (currentArpRhythmIndex + steps) % arpRhythm.length;
        }

        /** Resets the arpeggio rhythm index to 0. */
        function resetArpRhythmIndex() {
            currentArpRhythmIndex = 0;
        }

        /** Advances the pattern index by a specified number of steps (default 1). */
        function advancePatternIndex(steps = 1) {
            currentPatternIndex = (currentPatternIndex + steps) % patternRhythm.length;
        }

        /** Resets the pattern index to 0. */
        function resetPatternIndex() {
            currentPatternIndex = 0;
        }


        /**
         * Calculates the number of MIDI ticks per arpeggiator step based on the clock division.
         * Assumes 24 ticks per quarter note (PPQN).
         * @param {string} division - Clock division value (e.g., '1/4', '1/8T').
         * @returns {number} - Number of ticks per step.
         */
        function calculateClockDivisionCounterMax(division) {
            switch (division) {
                case '1/1': return 96;
                case '1/2': return 48;
                case '1/4': return 24;
                case '1/8': return 12;
                case '1/16': return 6;
                case '1/32': return 3;
                case '1/2T': return 32;
                case '1/4T': return 16;
                case '1/8T': return 8;
                case '1/16T': return 4;
                case '1/32T': return 2;
                default: return 24; // Default to 1/4
            }
        }

        /**
         * Sets up the internal clock for tempo and arpeggiation timing.
         * Clears any existing interval, calculates interval in milliseconds, and starts a new interval.
         */
        function setupInternalClock() {
            clearInterval(internalClockInterval);
            const intervalMs = 60000 / (bpm * 24); // Milliseconds per tick (24 PPQN)
            internalClockInterval = setInterval(tick, intervalMs);
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            tickCounter = 0;
            console.log(`Internal clock setup: BPM=${bpm}, Division=${clockDivision}, Interval=${intervalMs.toFixed(2)}ms, Ticks per step=${clockDivisionCounterMax}`);
        }


        /**
         * Starts the arpeggiator. Initializes rhythms, note lists, and clock based on tempo source.
         * If already running, this function does nothing.
         */
        function startArpeggiator() {
            if (arpRunning) return;

            let notesToArp = heldNotes.length > 0 ? heldNotes : [];
            notesToArp.sort((a, b) => a - b);
            updateModeNoteList();

            // Reset stable shuffle order only if held notes have changed
            if (!arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                lastNotesToArp = [...notesToArp];
                stableShuffleIndex = 0;
            }

            upDownDirection = 1; // Reset direction on start
            convergeDivergeDirection = 1; // Reset direction on start
            shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5); // Reset shuffled order

            arpRunning = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            updateRhythmDisplays();
            resetArpRhythmIndex();
            resetPatternIndex();
            currentArpNoteIndex = 0;
            playbackDisplayElem.innerHTML = '';

            if (tempoSource === 'internal') {
                setupInternalClock();
            } else {
                clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
                tickCounter = 0;
                console.log(`External clock mode active, division=${clockDivision}, ticksPerStep=${clockDivisionCounterMax}`);
            }
        }

        /**
         * Stops the arpeggiator. Clears intervals and UI states.
         * If not running, this function does nothing.
         */
        function stopArpeggiator() {
            if (!arpRunning) return;
            arpRunning = false;
            if (tempoSource === 'internal') {
                clearInterval(internalClockInterval);
            }
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            allNotesOff();
            unhighlightCurrentStep();
        }

        /**
         * Called on each clock tick (internal or external).
         * Increments tick counter and calls arpStep when enough ticks have accumulated for the current clock division.
         */
        function tick() {
            tickCounter++;
            if (tickCounter % clockDivisionCounterMax === 0) {
                arpStep();
            }
        }

        /** Handles MIDI clock tick messages (0xF8). */
        function handleMIDITick() {
            if (tempoSource === 'external') {
                tick();
            }
        }

        /**
         * Handles incoming MIDI messages. Processes note on/off and MIDI clock messages.
         * @param {MIDIMessageEvent} message - MIDI message event.
         */
        function onMIDIMessage(message) {
            const command = message.data[0];
            const channel = command & 0x0F;
            const note = message.data[1];
            const velocity = (message.data.length > 2) ? message.data[2] : 0;

            if (command === 248) { // MIDI Clock Tick - 0xF8 (248 in decimal)
                handleMIDITick();
                return;
            }

            let processMessage = false;

            if (isMPEEnabled) {
                const globalChannel = parseInt(mpeGlobalInputChannel);
                const voiceChannelCount = mpeInputVoiceChannels;
                if (mpeGlobalInputChannel === 'omni' || (channel >= globalChannel && channel < globalChannel + voiceChannelCount)) {
                    processMessage = true;
                }
            } else {
                processMessage = true;
            }

            if (processMessage) {
                if (command >= 144 && command < 160) { // Note On
                    if (velocity > 0) {
                        noteOn(note, 'midi');
                    } else {
                        noteOff(note, 'midi'); // Note Off with velocity 0
                    }
                } else if (command >= 128 && command < 144 || (command >= 144 && command < 160 && velocity === 0)) { // Note Off or Note On with velocity 0
                    noteOff(note, 'midi');
                }
            }
        }

        /**
         * Executes a single arpeggiator step. Determines note to play based on rhythms, patterns and arpeggio mode.
         * Called by the clock tick.
         */
        function arpStep() {
            if (!arpRunning) {
                stopArpeggiator();
                return;
            }

            unhighlightCurrentStep();

            let notesToArp = heldNotes.length > 0 ? heldNotes : [];
            if (arpSyncMode === 'free' && notesToArp.length === 0) {
                advanceArpRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null);
                highlightCurrentStep('rest', null);
                return;
            }

            if (arpMode === 'shuffled') {
                if (currentArpNoteIndex % notesToArp.length === 0) {
                    currentModeNoteList = generateShuffledNoteList(notesToArp);
                }
            } else if (arpMode === 'stableShuffled' && !arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                stableShuffleIndex = 0;
                lastNotesToArp = [...notesToArp];
                currentModeNoteList = generateStableShuffledNoteList(notesToArp);
            }


            if (notesToArp.length === 0 && arpSyncMode !== 'free') {
                stopArpeggiator();
                return;
            } else if (notesToArp.length === 0 && arpSyncMode === 'free') {
                return; // Silent advance already handled above
            }

            let noteForStep = '';
            let stepType = null;

            const currentArpRhythmEvent = arpRhythm[currentArpRhythmIndex];

            if (currentArpRhythmEvent === 'B') { // Beat in Arp Rhythm
                let patternEventProcessed = false;
                while (!patternEventProcessed) {
                    const currentPatternEvent = patternRhythm[currentPatternIndex];
                    if (currentPatternEvent === 'N') { // Note in Pattern
                        if (arpMode === 'chord' || arpMode === 'chordN') { // Chord Mode Logic
                            if (currentModeNoteList.length > 0) {
                                let chordToPlay;
                                if (arpMode === 'chordN') {
                                    chordToPlay = currentModeNoteList[currentArpNoteIndex % currentModeNoteList.length];
                                    highlightPianoKeysForChord(chordToPlay); // Highlight only current chord notes for ChordN
                                } else { // arpMode === 'chord'
                                    chordToPlay = currentModeNoteList;
                                    highlightPianoKeysForChord(chordToPlay); // Highlight all chord notes for Chord
                                }
                                playChord(chordToPlay);
                                advancePatternIndex();
                                stepType = 'note';
                                highlightCurrentStep('note', null, true); // Indicate chord with highlightAllKeys=true
                                patternEventProcessed = true;
                            } else {
                                stepType = 'rest';
                                patternEventProcessed = true;
                                highlightCurrentStep('rest', null);
                            }
                        }
                        else if (currentModeNoteList.length > 0 && arpMode !== 'random') { // Regular Arp Modes
                            noteForStep = currentModeNoteList[currentArpNoteIndex % currentModeNoteList.length];
                        } else if (arpMode === 'random' && notesToArp.length > 0) {
                            noteForStep = notesToArp[Math.floor(Math.random() * notesToArp.length)];
                        }

                        if (arpMode !== 'chord' && arpMode !== 'chordN') { // Play single note for non-chord modes
                            if (noteForStep !== '') {
                                playNote(noteForStep);
                                currentArpNoteIndex++;
                                if (arpMode === 'stableShuffled') stableShuffleIndex++;
                                advancePatternIndex();
                                stepType = 'note';
                                highlightCurrentStep('note', noteForStep);
                                patternEventProcessed = true;
                            }  else {
                                stepType = 'rest';
                                patternEventProcessed = true;
                                advancePatternIndex();
                                highlightCurrentStep('rest', null);
                            }
                        } else if ((arpMode === 'chord' || arpMode === 'chordN') && currentModeNoteList.length === 0) {
                            stepType = 'rest';
                            patternEventProcessed = true;
                            advancePatternIndex();
                            highlightCurrentStep('rest', null);
                        }
                        if (arpMode === 'chordN') {
                            currentArpNoteIndex++; // Advance chord index for chordN mode
                        }


                    } else if (currentPatternEvent === 'S') { // Skip in Pattern
                        advancePatternIndex();
                        currentArpNoteIndex++;
                        if (arpMode === 'stableShuffled') stableShuffleIndex++;
                    } else { // Error case
                        stepType = 'error';
                        patternEventProcessed = true;
                        highlightCurrentStep('error', null);
                        break;
                    }
                    if (patternEventProcessed) break;
                }
            } else if (currentArpRhythmEvent === 'R') { // Rest in Arp Rhythm
                stepType = 'rest';
                highlightCurrentStep('rest', null);
            } else {
                stepType = 'error_arp_rhythm';
                highlightCurrentStep('error', null);
            }

            if (stepType !== null) {
                updatePlaybackDisplay(stepType, (stepType === 'note' && arpMode !== 'chord' && arpMode !== 'chordN') ? noteForStep : null, (arpMode === 'chord' || arpMode === 'chordN'));
            }
            advanceArpRhythmIndex();
        }

        /**
         * Sends a MIDI note on and note off message for a given note.
         * Respects MPE output mode and channel settings.
         * @param {number} note - MIDI note number to play.
         */
        function playNote(note) {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) - 1;
                if (mpeOutputMode === 'mpe') {
                    midiOutput.send([0xE0 + outputChannel, 0, 0x40, 0x90 + outputChannel, note, 100]); // Pitch Bend, Note On
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                } else {
                    midiOutput.send([0x90 + outputChannel, note, 100]); // Note On
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                }
            }
        }

        /**
         * Sends MIDI note on and note off messages for a chord (multiple notes).
         * @param {number[]} notes - Array of MIDI note numbers to play as a chord.
         */
        function playChord(notes) {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) - 1;
                for (const note of notes) {
                    if (mpeOutputMode === 'mpe') {
                        midiOutput.send([0xE0 + outputChannel, 0, 0x40, 0x90 + outputChannel, note, 100]); // Pitch Bend, Note On
                    } else {
                        midiOutput.send([0x90 + outputChannel, note, 100]); // Note On
                    }
                }
                setTimeout(() => {
                    for (const note of notes) {
                        midiOutput.send([0x80 + outputChannel, note, 0]); // Note Off for each note
                    }
                }, 50);
            }
        }


        /** Sends MIDI note off messages for all held notes. */
        function allNotesOff() {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) - 1;
                for (const note of heldNotes) {
                    midiOutput.send([0x80 + outputChannel, note, 0]);
                }
            }
        }

        /**
         * Updates the playback display with the latest arpeggiator step.
         * @param {string} stepType - Type of step ('note', 'rest', 'skip', 'error').
         * @param {number|null} note - MIDI note number for 'note' steps, null otherwise.
         * @param {boolean} isChord - True if a chord was played in this step, false otherwise.
         */
        function updatePlaybackDisplay(stepType, note, isChord = false) {
            if (stepType === null) return;

            const stepElem = document.createElement('div');
            stepElem.classList.add('playback-step');
            stepElem.classList.add(stepType);

            if (stepType === 'note') {
                if (isChord) {
                    if (arpMode === 'chordN') {
                        stepElem.textContent = `Ch${((currentArpNoteIndex + currentModeNoteList.length - 1) % currentModeNoteList.length) + 1}`; // Display 'Ch1', 'Ch2' etc for ChordN
                    } else {
                        stepElem.textContent = 'Ch'; // Display 'Ch' for chord
                    }
                } else if (note !== null) {
                    stepElem.textContent = midiNoteToName(note);
                }
            } else if (stepType === 'rest') {
                stepElem.textContent = 'R';
            } else if (stepType === 'skip') {
                stepElem.textContent = 'S';
            }
            else if (stepType === 'error') {
                stepElem.textContent = '!';
            }

            playbackDisplayElem.appendChild(stepElem);

            if (playbackDisplayElem.children.length > maxPlaybackSteps) {
                playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            }
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        /**
         * Helper function to compare if two arrays are equal.
         * @param {array} arr1
         * @param {array} arr2
         * @returns {boolean}
         */
        function arraysAreEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        /** Generates the piano keyboard UI. */
        function generatePianoKeyboardUI() {
            const pianoKeyboard = document.getElementById('pianoKeyboard');
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const startNote = 48; // Middle C (C4)
            const numberOfKeys = 24;

            for (let i = 0; i < numberOfKeys; i++) {
                const noteValue = startNote + i;
                const noteName = notes[i % 12];
                const key = document.createElement('div');
                key.classList.add('key');
                key.dataset.note = noteValue;
                key.textContent = noteName;
                key.id = `pianoKey-${noteValue}`;

                if (noteName.includes('#')) {
                    key.classList.add('black-key');
                } else {
                    key.classList.add('white-key');
                }

                key.addEventListener('click', function() {
                    noteOn(noteValue, 'ui');
                });

                pianoKeyboard.appendChild(key);
            }
        }

        /**
         * Updates the visual state of a piano key in the UI.
         * @param {number} note - MIDI note number of the key.
         * @param {string|null} source - Source of the hold ('ui', 'midi', or null to reset).
         */
        function updatePianoKeyboardUI(note, source) {
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (!keyElement) return;

            keyElement.classList.remove('key-held-ui', 'key-held-midi', 'key-current');

            if (heldNotesUI.has(note) && source === 'ui') {
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesUI.has(note) && source === null) {
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesMIDI.has(note) && source === 'midi') {
                 keyElement.classList.add('key-held-midi');
            }
        }

        /**
         * Highlights a piano key in the UI to indicate it's the current arpeggio note.
         * Unhighlights any previously highlighted key.
         * @param {number} note - MIDI note number of the key to highlight.
         */
        function highlightPianoKey(note) {
            unhighlightPianoKey();
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (keyElement) {
                keyElement.classList.add('key-current');
                highlightedPianoKey = keyElement;
            }
        }

        /**
         * Highlights a specific set of piano keys in the UI to indicate a chord is being played.
         * @param {number[]} chordNotes - Array of MIDI note numbers to highlight as a chord.
         */
        function highlightPianoKeysForChord(chordNotes) {
            unhighlightPianoKey(); // Clear any single note highlights first
            if (chordNotes && chordNotes.length > 0) { // Check if chordNotes is valid
                chordNotes.forEach(note => {
                    const keyElement = document.getElementById(`pianoKey-${note}`);
                    if (keyElement) {
                        keyElement.classList.add('key-current');
                    }
                });
            }
        }


        /** Unhighlights all highlighted piano keys. */
        function unhighlightPianoKey() {
	            const currentHighlightedKeys = document.querySelectorAll('#pianoKeyboard .key.key-current');
	            currentHighlightedKeys.forEach(key => {
	                key.classList.remove('key-current');
	            });
	            highlightedPianoKey = null; // Optionally reset highlightedPianoKey as well
        }

        /**
         * Highlights a rhythm step in the UI to indicate it's the current step.
         * Unhighlights any previously highlighted step in the same rhythm display.
         * @param {string} displayElementId - ID of the rhythm display ('patternDisplay' or 'arpRhythmDisplay').
         * @param {number} stepIndex - Index of the step to highlight.
         */
        function highlightRhythmStep(displayElementId, stepIndex) {
            unhighlightRhythmStep(displayElementId);
            const stepElement = document.getElementById(`${displayElementId}-step-${stepIndex}`);
            if (stepElement) {
                stepElement.classList.add('current-step');
            }
        }

        /**
         * Unhighlights the currently highlighted rhythm step for a given rhythm display.
         * @param {string} displayElementId - ID of the rhythm display ('patternDisplay' or 'arpRhythmDisplay').
         */
        function unhighlightRhythmStep(displayElementId) {
            const currentHighlighted = (displayElementId === 'patternDisplay') ? document.querySelector('#patternDisplay .current-step') : document.querySelector('#arpRhythmDisplay .current-step');
            if (currentHighlighted) {
                currentHighlighted.classList.remove('current-step');
            }
        }


        /** Unhighlights all current step highlights (rhythm steps and piano key). */
        function unhighlightCurrentStep() {
            unhighlightRhythmStep('patternDisplay');
            unhighlightRhythmStep('arpRhythmDisplay');
            unhighlightPianoKey();
        }


        /**
         * Highlights the current arpeggiator step in the UI (rhythm steps and piano key).
         * @param {string} stepType - Type of step ('note', 'rest', 'skip').
         * @param {number|null} note - MIDI note number to highlight on the piano key, null otherwise.
         * @param {boolean} highlightAllKeys - If true, highlights all held keys (for chord mode).
         */
        function highlightCurrentStep(stepType, note, highlightAllKeys = false) {
            unhighlightPianoKey(); // Always unhighlight keys at the start of highlightCurrentStep

            highlightRhythmStep('arpRhythmDisplay', (currentArpRhythmIndex + arpRhythm.length - 1) % arpRhythm.length);
            highlightRhythmStep('patternDisplay', (currentPatternIndex + patternRhythm.length - 1) % patternRhythm.length);

            if (stepType === 'note') {
                if (arpMode === 'chordN') {
                    const currentChord = currentModeNoteList[currentArpNoteIndex % currentModeNoteList.length];
                    highlightPianoKeysForChord(currentChord); // Highlight specific chord notes for ChordN
                } else if (highlightAllKeys) {
                    highlightPianoKeysForChord(heldNotes); // Highlight all held keys for chord mode
                } else if (note !== null) {
                    highlightPianoKey(note); // Highlight single note for other modes
                }
            }
            // If stepType is 'rest' or 'skip', we unhighlighted at the start, and do nothing more with piano keys, which is correct.
        }


        // --- Event listeners for parameter changes (sliders and dropdowns) ---
        document.getElementById('patternSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('patternOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('arpRhythmSteps').addEventListener('input', updateRhythmDisplays);
        document.getElementById('arpRhythmBeats').addEventListener('input', updateRhythmDisplays);
        document.getElementById('arpRhythmOffset').addEventListener('input', updateRhythmDisplays);
        document.getElementById('arpMode').addEventListener('change', function() {
            const previousArpMode = arpMode;
            arpMode = this.value;
            const previousModeNoteList = [...currentModeNoteList]; // Copy for comparison
            const newModeNoteList = updateModeNoteList();

            if (['up', 'down', 'upDown', 'upDownInclusive', 'converge', 'diverge'].includes(arpMode) && previousModeNoteList.length > 0 && newModeNoteList.length > 0 && arpRunning) {
                currentArpNoteIndex = findClosestNoteIndex(previousModeNoteList[currentArpNoteIndex % previousModeNoteList.length], previousModeNoteList, newModeNoteList, currentArpNoteIndex);
            } else {
                currentArpNoteIndex = 0; // Reset index for other modes or empty lists
            }

            const chordNControls = document.getElementById('chordNControls');
            if (arpMode === 'chordN') {
                chordNControls.style.display = 'block';
            } else {
                chordNControls.style.display = 'none';
            }
        });
        document.getElementById('chordNValue').addEventListener('input', function() {
            chordNValue = parseInt(this.value);
            document.getElementById('chordNValueDisplay').textContent = chordNValue;
            updateModeNoteList(); // Update note list when chordN value changes
        });


        // --- Initialization ---
        generatePianoKeyboardUI();
        updateRhythmDisplays();
        updateModeNoteList(); // Initial note list generation on load
        document.getElementById('chordNValueDisplay').textContent = chordNValue; // Initialize ChordN display

    </script>
</body>
</html>
