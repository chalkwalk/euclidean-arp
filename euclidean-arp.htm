<html>
<head>
    <title>Euclidean MPE Arpeggiator Prototype</title>
    <style>
        body { font-family: sans-serif; }
        .rhythm-display { display: flex; margin-bottom: 10px; }
        .rhythm-step { width: 20px; height: 20px; border: 1px solid #ccc; text-align: center; line-height: 20px; font-size: 12px; }
        .beat { background-color: lightgreen; }
        .rest { background-color: lightcoral; }
        .skip { background-color: lightblue; }
        .note { background-color: yellow; }
        .held-notes-display { margin-bottom: 10px; }
        .parameter-group { margin-bottom: 10px; }
        .note-selector { margin-bottom: 10px; } /* Removed display: flex; */
        .piano-keyboard { display: flex; }
        .key {
            height: 80px;
            border-left: 1px solid black;
            border-bottom: 1px solid black;
            box-sizing: border-box;
            cursor: pointer;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 5px;
            font-size: 10px;
            user-select: none; /* Prevent text selection on click */
        }
        .white-key {
            width: 30px;
            background-color: white;
            color: black;
        }
        .black-key {
            width: 20px;
            background-color: black;
            color: white;
            height: 55px;
            margin-left: -10px;
            margin-right: -10px;
            z-index: 1; /* Ensure black keys are on top */
        }
        .key.key-held-ui {
            background-color: lightblue;
            color: black; /* Ensure text is readable on highlight */
        }
        .key.key-held-midi {
            background-color: lightgreen;
            color: black; /* Ensure text is readable on highlight */
        }
        .playback-display { display: flex; overflow-x: hidden; border: 1px solid #ccc; height: 30px; margin-bottom: 10px; }
        .playback-step { width: 20px; height: 20px; border: 1px solid black; margin-right: 2px; text-align: center; line-height: 20px; font-size: 10px; }
        .playback-step.note { background-color: lightyellow; }
        .playback-step.rest { background-color: lightcoral; }
        .playback-step.skip { background-color: lightblue; }
        .device-selector { margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Euclidean MPE Arpeggiator Prototype</h1>

    <div id="midiStatus">MIDI Status: Not connected</div>

    <div class="device-selector">
        <label for="midiInputSelect">MIDI Input Device:</label>
        <select id="midiInputSelect">
            <option value="">No input device selected</option>
        </select>
    </div>

    <div class="device-selector">
        <label for="midiOutputSelect">MIDI Output Device:</label>
        <select id="midiOutputSelect">
            <option value="">No output device selected</option>
        </select>
    </div>


    <div class="held-notes-display">
        <strong>Held MIDI Notes:</strong> <span id="heldNotes"></span>
    </div>

    <div class="note-selector">
        <strong>Select UI Notes:</strong>
        <div class="piano-keyboard" id="pianoKeyboard">
            <!-- Piano keys will be generated here by JavaScript -->
        </div>
    </div>


    <div class="parameter-group">
        <h3>Pattern</h3>
        <label for="patternSteps">Steps:</label>
        <input type="number" id="patternSteps" value="5" min="1">
        <label for="patternBeats">Beats:</label>
        <input type="number" id="patternBeats" value="3" min="1">
        <label for="patternOffset">Offset:</label>
        <input type="number" id="patternOffset" value="4" min="0">
        <div id="patternDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arp Rhythm</h3>
        <label for="arpRhythmSteps">Steps:</label>
        <input type="number" id="arpRhythmSteps" value="7" min="1">
        <label for="arpRhythmBeats">Beats:</label>
        <input type="number" id="arpRhythmBeats" value="5" min="1">
        <label for="arpRhythmOffset">Offset:</label>
        <input type="number" id="arpRhythmOffset" value="2" min="0">
        <div id="arpRhythmDisplay" class="rhythm-display"></div>
    </div>

    <div class="parameter-group">
        <h3>Arpeggiator & MPE Settings</h3>

        <label for="tempoSource">Tempo Source:</label>
        <select id="tempoSource">
            <option value="internal">Internal</option>
            <option value="external">External MIDI Clock</option>
        </select><br>

        <label for="tempoBPM">Tempo (BPM):</label>
        <input type="number" id="tempoBPM" value="120" min="10" max="300"><br>

        <label for="clockDivision">Clock Division:</label>
        <select id="clockDivision">
            <option value="1/1">1/1</option>
            <option value="1/2">1/2</option>
            <option value="1/4" selected="selected">1/4</option>
            <option value="1/8">1/8</option>
            <option value="1/16">1/16</option>
            <option value="1/32">1/32</option>
            <option value="1/2T">1/2T</option>
            <option value="1/4T">1/4T</option>
            <option value="1/8T">1/8T</option>
            <option value="1/16T">1/16T</option>
            <option value="1/32T">1/32T</option>
        </select><br>

        <label for="arpMode">Arp Mode:</label>
        <select id="arpMode">
            <option value="up">Up</option>
            <option value="down">Down</option>
            <option value="upDown">Up/Down</option>
            <option value="upDownInclusive">Up/Down (Incl.)</option>
            <option value="random">Random</option>
            <option value="converge">Converge</option>
            <option value="diverge">Diverge</option>
            <option value="played">Played</option>
            <option value="shuffled">Shuffled</option>
            <option value="stableShuffled">Stable Shuffled</option>
        </select><br>

        <label for="arpSyncMode">Arp Sync Mode:</label>
        <select id="arpSyncMode">
            <option value="free">Free Sync</option>
            <option value="key">Key Sync</option>
            <option value="transport">Transport Sync (Placeholder)</option>
        </select><br>

        <input type="checkbox" id="enableMPE">
        <label for="enableMPE">Enable MPE Input</label><br>

        <label for="mpeGlobalInputChannel">MPE Global Input Channel:</label>
        <select id="mpeGlobalInputChannel">
            <option value="omni">Omni</option>
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select><br>

        <label for="mpeInputVoiceChannels">MPE Input Voice Channels:</label>
        <input type="number" id="mpeInputVoiceChannels" value="8" min="1" max="15"><br>

        <label for="mpeOutputMode">MPE Output Mode:</label>
        <select id="mpeOutputMode">
            <option value="non-mpe">Non-MPE (Single Channel)</option>
            <option value="mpe">MPE</option>
        </select><br>

        <label for="mpeGlobalOutputChannel">MPE Global Output Channel / Base Channel:</label>
        <select id="mpeGlobalOutputChannel">
            <option value="1">Channel 1</option>
            <option value="2">Channel 2</option>
            <option value="3">Channel 3</option>
            <option value="4">Channel 4</option>
            <option value="5">Channel 5</option>
            <option value="6">Channel 6</option>
            <option value="7">Channel 7</option>
            <option value="8">Channel 8</option>
            <option value="9">Channel 9</option>
            <option value="10">Channel 10</option>
            <option value="11">Channel 11</option>
            <option value="12">Channel 12</option>
            <option value="13">Channel 13</option>
            <option value="14">Channel 14</option>
            <option value="15">Channel 15</option>
            <option value="16">Channel 16</option>
        </select>
    </div>

    <div class="playback-display" id="playbackDisplay"></div>

    <button id="startButton">Start Arpeggiator</button>
    <button id="stopButton" disabled>Stop Arpeggiator</button>

    <script>
        let midiAccess;
        let midiOutput;
        let midiInput;
        let heldNotes = [];
        let heldNotesUI = new Set();
        let heldNotesMIDI = new Set();
        let patternRhythm = [];
        let arpRhythm = [];
        let arpRunning = false;
        let arpInterval; // Will be used for internal clock interval
        let currentArpNoteIndex = 0;
        let currentArpRhythmIndex = 0;
        let currentPatternIndex = 0;
        const playbackDisplayElem = document.getElementById('playbackDisplay');
        const maxPlaybackSteps = 30;
        let arpMode = 'up';
        let isMPEEnabled = false;
        let mpeGlobalInputChannel = 'omni';
        let mpeInputVoiceChannels = 8;
        let mpeOutputMode = 'non-mpe';
        let mpeGlobalOutputChannel = '1';
        let arpSyncMode = 'free';

        // Tempo and Clock variables
        let tempoSource = 'internal'; // Default to internal tempo
        let bpm = 120; // Default BPM
        let clockDivision = '1/4'; // Default clock division
        let tickCounter = 0; // Counter for ticks
        let clockDivisionCounterMax = 24; // Default to 1/4 note (24 ticks per step at 24ppqn) - now correctly initialized for 1/4
        let internalClockInterval; // Variable to hold the setInterval ID for internal clock

        // State variables for different arp modes
        let upDownDirection = 1;
        let convergeDivergeDirection = 1
        let shuffledNotesOrder = [];
        let stableShuffledOrder = [];
        let stableShuffleIndex = 0;
        let lastNotesToArp = [];
        let convergeDivergeStep = 0;
        let currentModeNoteList = []; // NEW: Array to hold the current arp mode's note list


        document.getElementById('startButton').addEventListener('click', startArpeggiator);
        document.getElementById('stopButton').addEventListener('click', stopArpeggiator);
        document.getElementById('arpMode').addEventListener('change', function() {
            arpMode = this.value;
            updateModeNoteList(); // NEW: Update note list on mode change
            currentArpNoteIndex = 0; // Reset index on mode change
        });
        document.getElementById('arpSyncMode').addEventListener('change', function() {
            arpSyncMode = this.value;
        });
        document.getElementById('enableMPE').addEventListener('change', function() {
            isMPEEnabled = this.checked;
        });
        document.getElementById('mpeGlobalInputChannel').addEventListener('change', function() {
            mpeGlobalInputChannel = this.value;
        });
        document.getElementById('mpeInputVoiceChannels').addEventListener('change', function() {
            mpeInputVoiceChannels = parseInt(this.value);
        });
        document.getElementById('mpeOutputMode').addEventListener('change', function() {
            mpeOutputMode = this.value;
        });
        document.getElementById('mpeGlobalOutputChannel').addEventListener('change', function() {
            mpeGlobalOutputChannel = this.value;
        });

        // New Event listeners for tempo controls
        document.getElementById('tempoSource').addEventListener('change', function() {
            tempoSource = this.value;
            if (tempoSource === 'internal') {
                setupInternalClock(); // Initialize internal clock if switching to internal
            } else {
                clearInterval(internalClockInterval); // Stop internal clock if switching to external
            }
        });

        document.getElementById('tempoBPM').addEventListener('change', function() {
            bpm = parseInt(this.value);
            if (tempoSource === 'internal') {
                setupInternalClock(); // Re-setup internal clock with new BPM
            }
        });

        document.getElementById('clockDivision').addEventListener('change', function() {
            clockDivision = this.value;
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision); // Update clock division counter
            if (tempoSource === 'internal') {
                setupInternalClock(); // Re-setup internal clock as interval might need adjustment
            }
        });


        // MIDI Initialization (same as before)
        navigator.requestMIDIAccess()
            .then(onMIDISuccess, onMIDIFailure);

        function onMIDISuccess(midi) {
            midiAccess = midi;
            document.getElementById('midiStatus').innerText = "MIDI Status: Connected";

            const inputSelect = document.getElementById('midiInputSelect');
            const outputSelect = document.getElementById('midiOutputSelect');

            // Populate MIDI input select
            const inputs = midiAccess.inputs.values();
            for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                const option = document.createElement('option');
                option.value = input.value.id;
                option.text = input.value.name || 'MIDI Input ' + inputSelect.options.length;
                inputSelect.appendChild(option);
            }

            // Populate MIDI output select
            const outputs = midiAccess.outputs.values();
            for (let output = outputs.next(); output && !output.done; output = outputs.next()) {
                const option = document.createElement('option');
                option.value = output.value.id;
                option.text = output.value.name || 'MIDI Output ' + outputSelect.options.length;
                outputSelect.appendChild(option);
            }

            // Select first input and output if available
            if (inputSelect.options.length > 1) {
                inputSelect.selectedIndex = 1; // Select the first device, skipping "No input device selected"
                midiInput = midiAccess.inputs.get(inputSelect.options[1].value);
                midiInput.onmidimessage = onMIDIMessage;
            }

            if (outputSelect.options.length > 1) {
                outputSelect.selectedIndex = 1; // Select the first device, skipping "No output device selected"
                midiOutput = midiAccess.outputs.get(outputSelect.options[1].value);
            } else {
                document.getElementById('midiStatus').innerText += " No MIDI output device found.";
            }

            // Input device change listener
            inputSelect.addEventListener('change', function() {
                const selectedInputId = this.value;
                if (midiInput) {
                    midiInput.onmidimessage = null; // Remove listener from previous input
                }
                if (selectedInputId) {
                    midiInput = midiAccess.inputs.get(selectedInputId);
                    midiInput.onmidimessage = onMIDIMessage; // Add listener to new input
                } else {
                    midiInput = null; // No input device selected
                }
            });

            // Output device change listener
            outputSelect.addEventListener('change', function() {
                const selectedOutputId = this.value;
                if (selectedOutputId) {
                    midiOutput = midiAccess.outputs.get(selectedOutputId);
                } else {
                    midiOutput = null; // No output device selected
                }
            });
        }

        function onMIDIFailure() {
            document.getElementById('midiStatus').innerText = "MIDI Status: MIDI access failed.";
        }

        function onMIDIMessage(message) {
            const command = message.data[0];
            const channel = command & 0x0F; // Extract MIDI channel (lower 4 bits)
            const note = message.data[1];
            const velocity = (message.data.length > 2) ? message.data[2] : 0;

            // MIDI Clock Tick - 0xF8 (248 in decimal)
            if (command === 248) {
                handleMIDITick();
                return; // Important: Exit to prevent tick from being processed as note message
            }


            let processMessage = false;

            if (isMPEEnabled) {
                if (mpeGlobalInputChannel === 'omni') {
                    processMessage = true; // Process all channels in Omni mode (for now, refine MPE channel range later if needed)
                } else {
                    const globalChannel = parseInt(mpeGlobalInputChannel);
                    const voiceChannelCount = mpeInputVoiceChannels;
                    if (channel + 1 >= globalChannel + 1 && channel + 1 <= globalChannel + voiceChannelCount) { // Check if channel is within MPE voice channel range
                        processMessage = true;
                    } else if (channel + 1 === globalChannel) { // Optionally process global channel messages too, if needed, for now ignoring.
                        // processMessage = true;
                    }
                }
            } else {
                processMessage = true; // Process all messages if MPE is disabled (or refine to channel 1 later if needed)
            }


            if (processMessage) {
                if (command >= 144 && command < 160) { // Note On
                    if (velocity > 0) {
                        noteOn(note, 'midi'); // Indicate MIDI source
                    } else {
                        noteOff(note, 'midi'); // Indicate MIDI source
                    }
                } else if (command >= 128 && command < 144 || (command >= 144 && command < 160 && velocity === 0)) { // Note Off
                    noteOff(note, 'midi'); // Indicate MIDI source
                }
                // In future, handle MPE specific messages (pitch bend, CC74, pressure) here if needed based on isMPEEnabled and selected channel
            }
        }

        function noteOn(note, source = 'ui') {
            if (source === 'ui') {
                if (!heldNotesUI.has(note)) {
                    heldNotesUI.add(note);
                } else {
                    heldNotesUI.delete(note); // Toggle off if already on
                }
                // Update heldNotes from both sources
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, heldNotesUI.has(note) ? 'ui' : null); // Update UI key style
            } else if (source === 'midi') {
                if (!heldNotesMIDI.has(note)) {
                    heldNotesMIDI.add(note);
                }
                // heldNotesUI takes precedence if both UI and MIDI hold the same note, in terms of visual representation.
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, 'midi'); // Update UI key style for MIDI
            }


            updateHeldNotesDisplay();

            // Key Sync: Start arp if it's in key sync mode and not already running
            if (arpSyncMode === 'key' && !arpRunning) {
                startArpeggiator(); // Start the arpeggiator when the first note is pressed in Key Sync mode
            }
            updateModeNoteList(); // NEW: Update note list on note change
            currentArpNoteIndex = 0; // Reset index on note change (for now)

            // --- SHUFFLED/STABLE SHUFFLED NOTE ADDITION ---
            if (arpMode === 'shuffled' && arpRunning && shuffledNotesOrder.length > 0) { // Added length check
                const insertionIndex = Math.floor(Math.random() * shuffledNotesOrder.length); // Random insertion index
                shuffledNotesOrder.splice(insertionIndex, 0, note); // Insert note at random index
                if (insertionIndex <= currentArpNoteIndex) {
                    currentArpNoteIndex++; // Increment index if insertion is before or at current index
                }
            } else if (arpMode === 'stableShuffled' && arpRunning && stableShuffledOrder.length > 0) { // Added length check
                const insertionIndex = Math.floor(Math.random() * stableShuffledOrder.length); // Random insertion index
                stableShuffledOrder.splice(insertionIndex, 0, note); // Insert note at random index
                 if (insertionIndex <= stableShuffleIndex) {
                    stableShuffleIndex++; // Increment index if insertion is before or at current index
                }
            } else if (arpMode === 'shuffled' && arpRunning && shuffledNotesOrder.length === 0) {
                shuffledNotesOrder.push(note); // If list is empty, just push
            } else if (arpMode === 'stableShuffled' && arpRunning && stableShuffledOrder.length === 0) {
                stableShuffledOrder.push(note); // If list is empty, just push
            }
        }

        function noteOff(note, source = 'ui') {
            if (source === 'ui') {
                // UI note-off is handled in noteOn toggle logic
            } else if (source === 'midi') {
                heldNotesMIDI.delete(note);
                // Update heldNotes from both sources
                heldNotes = Array.from(new Set([...heldNotesUI, ...heldNotesMIDI])).sort((a, b) => a - b);
                updatePianoKeyboardUI(note, heldNotesUI.has(note) ? 'ui' : null); // Update UI key style, check if UI still holds it
            }

            updateHeldNotesDisplay();
            // Key Sync: Stop arp if it's in key sync mode and no notes are held
            if (arpSyncMode === 'key' && heldNotes.length === 0 && arpRunning) {
                stopArpeggiator(); // Stop the arpeggiator when the last note is released in Key Sync mode
            }
            updateModeNoteList(); // NEW: Update note list on note change
            currentArpNoteIndex = 0; // Reset index on note change (for now)

            // --- SHUFFLED/STABLE SHUFFLED NOTE REMOVAL ---
            if (arpMode === 'shuffled' && arpRunning) {
                const noteIndex = shuffledNotesOrder.indexOf(note);
                if (noteIndex !== -1) {
                    shuffledNotesOrder.splice(noteIndex, 1); // Remove note from shuffled list
                    if (noteIndex < currentArpNoteIndex && currentArpNoteIndex > 0) { // Changed <= to <
                        currentArpNoteIndex--; // Decrement index if removal is before current index
                    } else if (currentArpNoteIndex >= shuffledNotesOrder.length && shuffledNotesOrder.length > 0) {
                        currentArpNoteIndex = shuffledNotesOrder.length - 1; // Correct index if it's out of bounds after removal
                    } else if (shuffledNotesOrder.length === 0) {
                        currentArpNoteIndex = 0; // Reset to 0 if list becomes empty
                    }
                }
            } else if (arpMode === 'stableShuffled' && arpRunning) {
                const noteIndex = stableShuffledOrder.indexOf(note);
                if (noteIndex !== -1) {
                    stableShuffledOrder.splice(noteIndex, 1); // Remove from stable shuffled list
                    if (noteIndex < stableShuffleIndex && stableShuffleIndex > 0) { // Changed <= to <
                        stableShuffleIndex--; // Decrement stable shuffle index if removal is before it
                    } else if (stableShuffleIndex >= stableShuffledOrder.length && stableShuffledOrder.length > 0) {
                        stableShuffleIndex = stableShuffledOrder.length - 1; // Correct index if out of bounds
                    } else if (stableShuffledOrder.length === 0) {
                        stableShuffleIndex = 0; // Reset to 0 if list becomes empty
                    }
                }
            }
        }


        function updateHeldNotesDisplay() {
            const noteNames = heldNotes.map(midiNoteToName);
            document.getElementById('heldNotes').innerText = noteNames.join(", ");
        }

        function midiNoteToName(note) {
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const octave = Math.floor(note / 12) - 1;
            const noteName = notes[note % 12];
            return noteName + octave;
        }

        function generateEuclideanRhythm(steps, beats, offset, beatEvent, restEvent) {
            const rhythm = new Array(steps).fill(restEvent);
            let count = 0;
            for (let i = 0; i < steps; i++) {
                if ((count * steps) < (beats * (i + 1))) {
                    rhythm[i] = beatEvent;
                    count++;
                }
                }
            for (let i = 0; i < offset; i++) {
                rhythm.unshift(rhythm.pop());
            }
            return rhythm;
        }

        function updateRhythmDisplays() {
            const patternSteps = parseInt(document.getElementById('patternSteps').value);
            const patternBeats = parseInt(document.getElementById('patternBeats').value);
            const patternOffset = parseInt(document.getElementById('patternOffset').value);
            patternRhythm = generateEuclideanRhythm(patternSteps, patternBeats, patternOffset, 'N', 'S');
            displayRhythm(patternRhythm, 'patternDisplay');

            const arpRhythmSteps = parseInt(document.getElementById('arpRhythmSteps').value);
            const arpRhythmBeats = parseInt(document.getElementById('arpRhythmBeats').value);
            const arpRhythmOffset = parseInt(document.getElementById('arpRhythmOffset').value);
            arpRhythm = generateEuclideanRhythm(arpRhythmSteps, arpRhythmBeats, arpRhythmOffset, 'B', 'R');
            displayRhythm(arpRhythm, 'arpRhythmDisplay');
        }

        function displayRhythm(rhythmArray, displayElementId) {
            const displayElement = document.getElementById(displayElementId);
            displayElement.innerHTML = '';
            rhythmArray.forEach(event => {
                const stepElement = document.createElement('div');
                stepElement.classList.add('rhythm-step');
                stepElement.innerText = event;
                if (event === 'B') stepElement.classList.add('beat');
                else if (event === 'R') stepElement.classList.add('rest');
                else if (event === 'S') stepElement.classList.add('skip');
                else if (event === 'N') stepElement.classList.add('note');
                displayElement.appendChild(stepElement);
            });
        }

        // NEW: Mode Note List Generation Functions
        function generateUpNoteList(notes) {
            return [...notes];
        }

        function generateDownNoteList(notes) {
            return [...notes].reverse();
        }

        function generateUpDownNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const upDownList = [...notes];
            for (let i = notes.length - 2; i >= 1; i--) {
                upDownList.push(notes[i]);
            }
            return upDownList;
        }

        function generateUpDownInclusiveNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const upDownInclusiveList = [...notes];
            for (let i = notes.length - 1; i >= 0; i--) { // Corrected loop condition
                upDownInclusiveList.push(notes[i]);
            }
            return upDownInclusiveList;
        }

        function generateConvergeNoteList(notes) {
            if (notes.length <= 1) return [...notes];
            const convergeList = [];
            let start = 0;
            let end = notes.length - 1;
            while (start <= end) {
                convergeList.push(notes[start]);
                if (start !== end) { // Prevent duplicates for odd length arrays
                    convergeList.push(notes[end]);
                }
                start++;
                end--;
            }
            return convergeList;
        }

        function generateDivergeNoteList(notes) {
             if (notes.length <= 1) return [...notes];
            const divergeList = [];
            let start = Math.floor((notes.length - 1) / 2);
            let end = Math.ceil((notes.length - 1) / 2);
            while (start >= 0 && end < notes.length) {
                divergeList.push(notes[start]);
                if (start !== end) { // Prevent duplicates for odd length arrays
                    divergeList.push(notes[end]);
                }
                start--;
                end++;
            }
            return divergeList;
        }


        function generatePlayedNoteList(notes) {
            return [...notes]; // Played mode is just the notes in the order they are held (which is already sorted)
        }

        function generateRandomNoteList(notes) {
            return []; // Random mode doesn't need a pre-generated list
        }

        function generateShuffledNoteList(notes) {
            return [...notes].sort(() => Math.random() - 0.5);
        }

        function generateStableShuffledNoteList(notes) {
            return stableShuffledOrder; // Relies on stableShuffledOrder being updated elsewhere
        }


        // NEW: Function to update currentModeNoteList based on arpMode
        function updateModeNoteList() {
            let notesToArp = heldNotes.length > 0 ? heldNotes : [];
            switch (arpMode) {
                case 'up':
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
                case 'down':
                    currentModeNoteList = generateDownNoteList(notesToArp);
                    break;
                case 'upDown':
                    currentModeNoteList = generateUpDownNoteList(notesToArp);
                    break;
                case 'upDownInclusive':
                    currentModeNoteList = generateUpDownInclusiveNoteList(notesToArp);
                    break;
                case 'converge':
                    currentModeNoteList = generateConvergeNoteList(notesToArp);
                    break;
                case 'diverge':
                    currentModeNoteList = generateDivergeNoteList(notesToArp);
                    break;
                case 'played':
                    currentModeNoteList = generatePlayedNoteList(notesToArp);
                    break;
                case 'random':
                    currentModeNoteList = generateRandomNoteList(notesToArp); // Set to empty list for random
                    break;
                case 'shuffled':
                    currentModeNoteList = generateShuffledNoteList(notesToArp);
                    break;
                case 'stableShuffled':
                    currentModeNoteList = generateStableShuffledNoteList(notesToArp);
                    break;
                default: // 'up' is default
                    currentModeNoteList = generateUpNoteList(notesToArp);
                    break;
            }
        }


        function advanceArpRhythmIndex(steps = 1) {
            currentArpRhythmIndex = (currentArpRhythmIndex + steps) % arpRhythm.length;
        }

        function resetArpRhythmIndex() {
            currentArpRhythmIndex = 0;
        }

        function advancePatternIndex(steps = 1) {
            currentPatternIndex = (currentPatternIndex + steps) % patternRhythm.length;
        }

        function resetPatternIndex() {
            currentPatternIndex = 0;
        }


        function calculateClockDivisionCounterMax(division) {
            switch (division) {
                case '1/1': return 96;  // 1 bar = 4 quarter notes = 96 ticks
                case '1/2': return 48;  // 1/2 note = 2 quarter notes = 48 ticks
                case '1/4': return 24;  // 1/4 note = 1 quarter note = 24 ticks
                case '1/8': return 12;  // 1/8 note = 12 ticks
                case '1/16': return 6;  // 1/16 note = 6 ticks
                case '1/32': return 3;  // 1/32 note = 3 ticks
                case '1/2T': return 32; // 1/2 triplet = (2/3) * 48 = 32 ticks
                case '1/4T': return 16; // 1/4 triplet = (2/3) * 24 = 16 ticks
                case '1/8T': return 8;  // 1/8 triplet = (2/3) * 12 = 8 ticks
                case '1/16T': return 4; // 1/16 triplet = (2/3) * 6 = 4 ticks
                case '1/32T': return 2; // 1/32 triplet = (2/3) * 3 = 2 ticks
                default: return 24; // Default to 1/4
            }
        }

        function setupInternalClock() {
            clearInterval(internalClockInterval); // Clear any existing interval
            const intervalMs = 60000 / (bpm * 24); // Milliseconds per tick
            internalClockInterval = setInterval(tick, intervalMs);
            clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision);
            tickCounter = 0; // Reset tick counter on setup/tempo change
            console.log(`Internal clock setup: BPM=${bpm}, Division=${clockDivision}, Interval=${intervalMs.toFixed(2)}ms, Ticks per step=${clockDivisionCounterMax}`);
        }


        function startArpeggiator() {
            let notesToArp = heldNotes.length > 0 ? heldNotes : [];

            if (arpRunning) return;

            notesToArp.sort((a, b) => a - b);
            updateModeNoteList(); // NEW: Generate initial note list on start

            // Stable across arp restarts, but not note changes
            if (!arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                lastNotesToArp = [...notesToArp];
                stableShuffleIndex = 0;
            }

            upDownDirection = 1;
            convergeDivergeDirection = 1;
            shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5);

            arpRunning = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;
            updateRhythmDisplays();
            resetArpRhythmIndex();
            resetPatternIndex();
            currentArpNoteIndex = 0;
            playbackDisplayElem.innerHTML = '';

            if (tempoSource === 'internal') {
                setupInternalClock(); // Setup internal clock if not already running or tempo changed
            } else {
                clockDivisionCounterMax = calculateClockDivisionCounterMax(clockDivision); // Still need to update this for external sync
                tickCounter = 0; // Reset counter for external sync too
                console.log(`External clock mode active, division=${clockDivision}, ticksPerStep=${clockDivisionCounterMax}`);
                // External clock will drive the 'tick' function via MIDI ticks
            }
        }

        function stopArpeggiator() {
            if (!arpRunning) return;
            arpRunning = false;
            if (tempoSource === 'internal') {
                clearInterval(internalClockInterval); // Clear internal interval only in internal mode
            }
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            allNotesOff();
            // playbackDisplayElem.innerHTML = ''; // No need to clear here anymore
        }

        function tick() {
            tickCounter++;
            if (tickCounter % clockDivisionCounterMax === 0) {
                arpStep();
            }
        }


        function handleMIDITick() {
            if (tempoSource === 'external') {
                tick();
            }
        }

        function onMIDIMessage(message) {
            const command = message.data[0];
            const channel = command & 0x0F;
            const note = message.data[1];
            const velocity = (message.data.length > 2) ? message.data[2] : 0;

            // MIDI Clock Tick - 0xF8 (248 in decimal)
            if (command === 248) {
                handleMIDITick();
                return; // Important: Exit to prevent tick from being processed as note message
            }

            let processMessage = false;

            if (isMPEEnabled) {
                if (mpeGlobalInputChannel === 'omni') {
                    processMessage = true; // Process all channels in Omni mode (for now, refine MPE channel range later if needed)
                } else {
                    const globalChannel = parseInt(mpeGlobalInputChannel);
                    const voiceChannelCount = mpeInputVoiceChannels;
                    if (channel + 1 >= globalChannel + 1 && channel + 1 <= globalChannel + voiceChannelCount) { // Check if channel is within MPE voice channel range
                        processMessage = true;
                    } else if (channel + 1 === globalChannel) { // Optionally process global channel messages too, if needed, for now ignoring.
                        // processMessage = true;
                    }
                }
            } else {
                processMessage = true; // Process all messages if MPE is disabled (or refine to channel 1 later if needed)
            }


            if (processMessage) {
                if (command >= 144 && command < 160) {
                    if (velocity > 0) {
                        noteOn(note, 'midi');
                    } else {
                        noteOff(note, 'midi');
                    }
                } else if (command >= 128 && command < 144 || (command >= 144 && command < 160 && velocity === 0)) {
                    noteOff(note, 'midi');
                }
            }
        }

        function arpStep() {
            if (!arpRunning) {
                stopArpeggiator();
                return;
            }

            let notesToArp = heldNotes.length > 0 ? heldNotes : []; // Use heldNotes directly
            if (arpSyncMode === 'free' && notesToArp.length === 0) {
                // In Free Sync mode, if no notes are held, advance rhythms silently
                advanceArpRhythmIndex();
                advancePatternIndex();
                updatePlaybackDisplay('rest', null); // Indicate silent step in Free Sync
                return; // Exit early, don't play notes
            }

            if (arpMode === 'shuffled') {
                if (currentArpNoteIndex % notesToArp.length === 0) {
                    currentModeNoteList = generateShuffledNoteList(notesToArp); // Regenerate shuffled list every loop
                }
            } else if (arpMode === 'stableShuffled' && !arraysAreEqual(notesToArp, lastNotesToArp)) {
                stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                stableShuffleIndex = 0;
                lastNotesToArp = [...notesToArp];
                currentModeNoteList = generateStableShuffledNoteList(notesToArp); // Update currentModeNoteList for stable shuffled too
            }


            if (notesToArp.length === 0 && arpSyncMode !== 'free') { // For key sync or transport sync, stop if no notes
                stopArpeggiator();
                return;
            } else if (notesToArp.length === 0 && arpSyncMode === 'free') {
                // Free sync with no notes is handled above to advance silently
                return;
            }

            let noteForStep = '';
            let stepType = null; // Initialize stepType to null

            const currentArpRhythmEvent = arpRhythm[currentArpRhythmIndex];

            if (currentArpRhythmEvent === 'B') { // Beat in Arp Rhythm
                let patternEventProcessed = false;
                while (!patternEventProcessed) {
                    const currentPatternEvent = patternRhythm[currentPatternIndex];
                    if (currentPatternEvent === 'N') { // Note in Pattern
                        if (currentModeNoteList.length > 0 && arpMode !== 'random') { // NEW: Check if note list is populated and not random mode
                            noteForStep = currentModeNoteList[currentArpNoteIndex % currentModeNoteList.length]; // NEW: Get note from list
                        } else if (arpMode === 'random' && notesToArp.length > 0) {
                            noteForStep = notesToArp[Math.floor(Math.random() * notesToArp.length)]; // Pick random note directly
                        }

                        if (noteForStep !== '') { // Play note if we have one
                            playNote(noteForStep);
                            currentArpNoteIndex++;
                            if (arpMode === 'stableShuffled') stableShuffleIndex++;
                            advancePatternIndex();
                            stepType = 'note'; // Set stepType to 'note' when a note is played
                            patternEventProcessed = true;
                        }  else { // No notes to play (e.g., random mode with no held notes)
                            stepType = 'rest';
                            patternEventProcessed = true;
                            advancePatternIndex();
                        }


                    } else if (currentPatternEvent === 'S') { // Skip in Pattern
                        advancePatternIndex();
                        currentArpNoteIndex++;
                        if (arpMode === 'stableShuffled') stableShuffleIndex++;
                    } else { // Error case
                        stepType = 'error';
                        patternEventProcessed = true;
                        break;
                    }
                    if (patternEventProcessed) break;
                }
            } else if (currentArpRhythmEvent === 'R') { // Rest in Arp Rhythm
                stepType = 'rest'; // Set stepType to 'rest' for rests
            } else {
                stepType = 'error_arp_rhythm'; // For safety
            }

            if (stepType !== null) { // Only update display if stepType is set (i.e., for 'note', 'rest' or 'skip')
                updatePlaybackDisplay(stepType, (stepType === 'note') ? noteForStep : null);
            }
            advanceArpRhythmIndex();
        }

        function playNote(note) {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) -1; // Channel is 0 indexed for MIDI
                if (mpeOutputMode === 'mpe') {
                    midiOutput.send([0xE0 + outputChannel, 0, 0x40, 0x90 + outputChannel, note, 100]); // Pitch Bend to center, Note On, channel from mpeGlobalOutputChannel (for now just base channel)
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                } else {
                    midiOutput.send([0x90 + outputChannel, note, 100]); // Note On, channel from mpeGlobalOutputChannel (for non-MPE)
                    setTimeout(() => { midiOutput.send([0x80 + outputChannel, note, 0]); }, 50); // Note Off
                }
            }
        }

        function allNotesOff() {
            if (midiOutput) {
                let outputChannel = parseInt(mpeGlobalOutputChannel) - 1;
                for (const note of heldNotes) {
                    midiOutput.send([0x80 + outputChannel, note, 0]); // Note Off for all held notes on selected output channel
                }
            }
        }

        function updatePlaybackDisplay(stepType, note) {
            if (stepType === null) return; // Do not update display for null stepType

            const stepElem = document.createElement('div');
            stepElem.classList.add('playback-step');
            stepElem.classList.add(stepType); // Add class for step type styling

            if (stepType === 'note' && note !== null) {
                stepElem.textContent = midiNoteToName(note).replace(/\d+/g, ''); // Display note name
            } else if (stepType === 'rest') {
                stepElem.textContent = 'R';
            } else if (stepType === 'skip') {
                stepElem.textContent = 'S';
            }
            else if (stepType === 'error') {
                stepElem.textContent = '!'; // Indicate error in playback
            }

            playbackDisplayElem.appendChild(stepElem);

            if (playbackDisplayElem.children.length > maxPlaybackSteps) {
                playbackDisplayElem.removeChild(playbackDisplayElem.firstChild);
            }
            playbackDisplayElem.scrollLeft = playbackDisplayElem.scrollWidth;
        }

        // Helper function to compare arrays for stable shuffled reset
        function arraysAreEqual(arr1, arr2) {
            if (arr1.length !== arr2.length) return false;
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) return false;
            }
            return true;
        }

        function generatePianoKeyboardUI() {
            const pianoKeyboard = document.getElementById('pianoKeyboard');
            const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            const startNote = 48; // Middle C (C4)
            const numberOfKeys = 24; // One octave

            for (let i = 0; i < numberOfKeys; i++) {
                const noteValue = startNote + i;
                const noteName = notes[i % 12];
                const key = document.createElement('div');
                key.classList.add('key');
                key.dataset.note = noteValue;
                key.textContent = noteName;
                key.id = `pianoKey-${noteValue}`; // Add ID for easy access

                if (noteName.includes('#')) {
                    key.classList.add('black-key');
                } else {
                    key.classList.add('white-key');
                }

                key.addEventListener('click', function() {
                    noteOn(noteValue, 'ui'); // Identify UI source
                });

                pianoKeyboard.appendChild(key);
            }
        }

        function updatePianoKeyboardUI(note, source) {
            const keyElement = document.getElementById(`pianoKey-${note}`);
            if (!keyElement) return; // Key element might not be created if note is out of range.

            keyElement.classList.remove('key-held-ui', 'key-held-midi'); // Remove any existing held styles

            if (heldNotesUI.has(note) && source === 'ui') {
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesUI.has(note) && source === null) { // If UI still holds after MIDI off
                keyElement.classList.add('key-held-ui');
            } else if (heldNotesMIDI.has(note) && source === 'midi') {
                 keyElement.classList.add('key-held-midi');
            }
             // If neither UI nor MIDI holds it, it will revert to default style due to removal of classes above.
        }


        // Event listeners for parameter changes (same as before)
        document.getElementById('patternSteps').addEventListener('change', updateRhythmDisplays);
        document.getElementById('patternBeats').addEventListener('change', updateRhythmDisplays);
        document.getElementById('patternOffset').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmSteps').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmBeats').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpRhythmOffset').addEventListener('change', updateRhythmDisplays);
        document.getElementById('arpMode').addEventListener('change', function() {
             // Reset indices when changing arp mode for modes that use them
            if (['converge', 'diverge'].includes(this.value)) {
                let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                convergeStartIndex = 0;
                convergeEndIndex = notesToArp.length > 0 ? notesToArp.length - 1 : 0;
                divergeStartIndex = Math.floor(notesToArp.length / 2); // Reset diverge start to middle
                divergeEndIndex = Math.ceil(notesToArp.length / 2) - 1; // Reset diverge end to middle (or just below)
                convergeDivergeStep = 0; // Reset step counter for converge/diverge
            } else if (this.value === 'stableShuffled') {
                 let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                 stableShuffledOrder = [...notesToArp].sort(() => Math.random() - 0.5);
                 stableShuffledIndex = 0;
            } else if (this.value === 'shuffled') {
                let notesToArp = heldNotes.length > 0 ? heldNotes : [];
                shuffledNotesOrder = [...notesToArp].sort(() => Math.random() - 0.5);
            }
            arpMode = this.value;
            updateModeNoteList(); // NEW: Update note list on mode change - duplicated above for clarity
            currentArpNoteIndex = 0; // Reset index on mode change - duplicated above for clarity
        });

        generatePianoKeyboardUI();
        updateRhythmDisplays();
        updateModeNoteList(); // NEW: Initial note list generation on page load
    </script>
</body>
</html>